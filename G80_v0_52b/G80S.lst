              	; --------------------------------------
              	; zasm: assemble "G80S.asm"
              	; date: 2021-06-07 13:46:00
              	; --------------------------------------


              	;-------------------------------------------------------------------------------
              	;                   G-DOS (Prototype) Operating System
              	;
              	;  A firmware OS designed specifically for the G80-S, G80-USB, and G80-UVK
              	;   z80 Computers.
              	;
              	;  By:  Doug Gabbard ( 2017 - 20XX )
              	;  Dev-Team:    Mike Veit
              	;               Amardeep Chana
              	;
              	;-------------------------------------------------------------------------------
              	
              	
              	
              	;-------------------------------------------------------------------------------
              	;       BOARD SETTINGS
              	;-------------------------------------------------------------------------------
              	;  Due to the growing design of this computer project, it has become necessary
              	;   to begin conditional assembly for specific boards.  This can be done easily
              	;   in code to allow for different sets of code to be compiled depending on the
              	;   specific board.  The 'BOARD' equate is the key.  Depending on the value
              	;   given, the board will either compile for either the G80-S/USB variants, or
              	;   the G80-UVK (and G80-S/USB with add-on cards for compatibility).  To specify
              	;   which board is to be used, please set 'BOARD' to one of the following
              	;   settings:
              	;
              	;       0 = G80-S or G80-USB
              	;       1 = G80-UVK (or G80-S/USB with add-on card)
              	;
              	;  A second setting is available to allow serial communication for the G80-S/USB
              	;   over either Port A or B.  On the G80-USB the USB Serial Port is Port A, and
              	;   the RS-232 port is Port B. To enable serial over a specific serial port
              	;   choose one of the following settings for 'SERIAL':
              	;
              	;       0 = Serial Port A
              	;       1 = Serial Port B
              	;
              	;  Option 3 is the BAUD Rate settings for both Port A, and Port B.  These can be
              	;   mixed however the user chooses:  115200 Baud, 57600 Baud, and 28800 Baud.
              	;   This allows for a greater window of communication options.  Changing the
              	;   frequency oscillator for Serial Communication can allow for other varieties
              	;   of combinations.  The settings for SIOA_BAUD and SIOB_BAUD are:
              	;
              	;       DEFAULT = X32 - MOST RELIABLE
              	;       0 = Divide by 16
              	;       1 = Divide by 32
              	;       2 = Divide by 64
              	;-------------------------------------------------------------------------------
              	
0000:         	BOARD           EQU     0
0000:         	SERIAL          EQU     0
0001:         	SIOA_BAUD       EQU     1
0001:         	SIOB_BAUD       EQU     1
              	
              	        INCLUDE "equates.asm"         ;DEFINITIONS OF VALUES
              	;-------------------------------------------------------------------------------
              	;       DEFINITIONS OF NAMES
              	;-------------------------------------------------------------------------------
              	; SIO LABLES
              	;-------------------------------------------------------------------------------
0000:         	SIOA_D          EQU     00H    ;SIO CHANNEL A DATA REGISTER
0002:         	SIOA_C          EQU     02H    ;SIO CHANNEL A CONTROL REGISTER
0001:         	SIOB_D          EQU     01H    ;SIO CHANNEL B DATA REGISTER
0003:         	SIOB_C          EQU     03H    ;SIO CHANNEL B CONTROL REGISTER
              	        IF (SIOA_BAUD = 0)
              	SIOA_CLK        EQU     4CH     ;SIO 1/16 CLOCK
              	        ENDIF
              	        IF (SIOA_BAUD = 1)
008C:         	SIOA_CLK        EQU     8CH     ;SIO 1/32 CLOCK
              	        ENDIF
              	        IF (SIOA_BAUD = 2)
              	SIOA_CLK        EQU     0CCH    ;SIO 1/64 CLOCK
              	        ENDIF
              	        IF (SIOB_BAUD = 0)
              	SIOB_CLK        EQU     4CH     ;SIO 1/16 CLOCK
              	        ENDIF
              	        IF (SIOB_BAUD = 1)
008C:         	SIOB_CLK        EQU     8CH     ;SIO 1/32 CLOCK
              	        ENDIF
              	        IF (SIOB_BAUD = 2)
              	SIOB_CLK        EQU     0CCH    ;SIO 1/64 CLOCK
              	        ENDIF
              	;-------------------------------------------------------------------------------
              	; PIO LABELS
              	;-------------------------------------------------------------------------------
0080:         	PIOA            EQU     80H    ;PIO PORT A
0081:         	PIOB            EQU     81H    ;PIO PORT B
0082:         	PIOC            EQU     82H    ;PIO PORT C
0083:         	PIOCMD          EQU     83H    ;PIO CONTROL PORT
              	;-------------------------------------------------------------------------------
              	; OS LABELS
              	;-------------------------------------------------------------------------------
7FFF:         	ROM_TOP         EQU     07FFFH
8000:         	RAM_BOT         EQU     08000H
FFFF:         	RAM_TOP         EQU     0FFFFH
FDFF:         	USRSPC_TOP      EQU     0FDFFH          ; Doug had as 0FAFFH
8000:         	USRSPC_BOT      EQU     08000H
FEFF:         	STACK           EQU     0FEFFH          ; Doug had as 0FBFF
FFDA:         	BUF_BOT         EQU     0FFDAH
FFFF:         	BUF_TOP         EQU     0FFFFH
FFD9:         	BUF_POINTER     EQU     0FFD9H
FF00:         	IRQ_VECTOR      EQU     0FF00H
FF1E:         	INKEYVALUE      EQU     0FF1EH
FF1F:         	tb_dir_count    EQU     0FF1FH          ; 1 byte to store directory items found in dir command - this limits to 255 files for now...
FF20:         	filename_buffer EQU     0FF20H          ; 16 byte buffer for the file name which is 8.3+null = 13 bytes max
FF30:         	disk_buffer     EQU     0FF30H          ; 32 byte buffer for file - not sur eif I will use it in the memorystick_low_level commands
              	
0020:         	SPACE           EQU     020H            ; Space
0009:         	TAB             EQU     09H             ; HORIZONTAL TAB
0003:         	CTRLC           EQU     03H             ; Control "C"
0007:         	CTRLG           EQU     07H             ; Control "G"
0008:         	BKSP            EQU     08H             ; Back space
000A:         	LF              EQU     0AH             ; Line feed
000C:         	CS              EQU     0CH             ; Clear screen
000D:         	CR              EQU     0DH             ; Carriage return
000F:         	CTRLO           EQU     0FH             ; Control "O"
0011:         	CTRLQ	        EQU     011H            ; Control "Q"
0012:         	CTRLR           EQU     012H            ; Control "R"
0013:         	CTRLS           EQU     013H            ; Control "S"
0015:         	CTRLU           EQU     015H            ; Control "U"
001B:         	ESC             EQU     01BH            ; Escape
007F:         	DEL             EQU     07FH            ; Delete
              	
              	
0218:         	MON_LOOP        EQU     MAIN_LOOP
              	
              	;-------------------------------------------------------------------------------
              	; LABELS FOR TINYBASIC
              	;-------------------------------------------------------------------------------
FFFF:         	STACKB          EQU     0FFFFH          ; STACKB
8000:         	OCSW            EQU     08000H          ;SWITCH FOR OUTPUT
8001:         	CURRNT          EQU     OCSW+1          ;POINTS FOR OUTPUT
8003:         	STKGOS          EQU     OCSW+3          ;SAVES SP IN 'GOSUB'
8005:         	VARNXT          EQU     OCSW+5          ;TEMP STORAGE
8007:         	STKINP          EQU     OCSW+7          ;SAVES SP IN 'INPUT'
8009:         	LOPVAR          EQU     OCSW+9          ;'FOR' LOOP SAVE AREA
800B:         	LOPINC          EQU     OCSW+11         ;INCREMENT
800D:         	LOPLMT          EQU     OCSW+13         ;LIMIT
800F:         	LOPLN           EQU     OCSW+15         ;LINE NUMBER
8011:         	LOPPT           EQU     OCSW+17         ;TEXT POINTER
8013:         	RANPNT          EQU     OCSW+19         ;RANDOM NUMBER POINTER
8015:         	IN_BYTE         EQU     OCSW+21         ;STORE FOR 'IN' COMMAND
8016:         	CALL_LOC        EQU     OCSW+22
8018:         	TXTUNF          EQU     OCSW+24         ;->UNFILLED TEXT AREA
801A:         	TXTBGN          EQU     OCSW+26         ;TEXT SAVE AREA BEGINS
              	
FF00:         	TXTEND          EQU     0FF00H          ;TEXT SAVE AREA ENDS
              	;-------------------------------------------------------------------------------
              	
              	;-------------------------------------------------------------------------------
              	; PICK YOUR PROGRAMMING LANGUAGES
              	;
              	;       0 = NOT INCLUDED
              	;       1 = INCLUDED
              	;
              	;       IF MS_BASIC is enabled, you cannot have BASIC or CFORTH Enabled
              	;-------------------------------------------------------------------------------
              	
0000:         	BASIC           EQU     0
0001:         	MS_BASIC        EQU     1             ; if enabled, cannot have BASIC and CFORTH = 1
0000:         	CFORTH          EQU     0
              	
              	;-------------------------------------------------------------------------------
              	; BEGINNING OF CODE
              	;-------------------------------------------------------------------------------
0000:         	                ORG     0000h
0000:         	BOOT:
0000: F3      	        DI
0001: 31FFFE  	        LD SP,STACK                     ;STACK OCCUPIES FBFF AND BELOW.
0004: C30002  	        JP INIT                         ;GO INITIALIZE THE SYSTEM.
              	
              	;-------------------------------------------------------------------------------
              	; ZERO PAGE FOR BASIC IF INCLUDED
              	;-------------------------------------------------------------------------------
              	
              	        IF (BASIC = 1)
              	        INCLUDE "basic_pg0.asm"         ;ZERO PAGE FOR TINY BASIC
              	        ENDIF
              	
              	        IF (MS_BASIC = 1)
              	        INCLUDE "msbasic_pg0.asm"
              	;==============================================================================
              	; G80-USB/S Driver for Grant Searle's version of Microsoft Basic 4.7b
              	;
              	;  Changes are Copyright Doug Gabbard 2019, retrodepot.net
              	;
              	;  You have permission to distribute and use this for NON COMMERCIAL USE.
              	;
              	;  Portions of this code were adapted or copied from Grant Searle's original
              	;   works.  His copyright applies.
              	;
              	;==============================================================================
              	; Contents of this file are copyright Grant Searle
              	;
              	; You have permission to use this for NON COMMERCIAL USE ONLY
              	; If you wish to use it elsewhere, please include an acknowledgement to myself.
              	;
              	; http://searle.hostei.com/grant/index.html
              	;
              	; eMail: home.micros01@btinternet.com
              	;
              	; If the above don't work, please perform an Internet search to see if I have
              	; updated the web page hosting service.
              	;
              	;==============================================================================
              	
003F:         	SER_BUFSIZE     EQU     3FH
0030:         	SER_FULLSIZE    EQU     30H
0005:         	SER_EMPTYSIZE   EQU     5
              	
              	; Note that I hard coded both SIOA's to the second RS-232 port since I don't have the USB chip yet
              	; and this file was not properly setup to use the SERIAL define from what I could tell (Pat Dziuk)
              	; I may come back later and fix this
              	
              	;SIOA_D          EQU     01H     ;SIO CHANNEL A DATA REGISTER
              	;SIOA_C          EQU     03H     ;SIO CHANNEL A CONTROL REGISTER
              	;SIOB_D          EQU     01H     ;SIO CHANNEL B DATA REGISTER
              	;SIOB_C          EQU     03H     ;SIO CHANNEL B CONTROL REGISTER
              	
8000:         	serBuf          EQU     8000H
803F:         	serInPtr        EQU     serBuf+SER_BUFSIZE
8041:         	serRdPtr        EQU     serInPtr+2
8043:         	serBufUsed      EQU     serRdPtr+2
8044:         	basicStarted    EQU     serBufUsed+1
80ED:         	TEMPSTACK       EQU     80EDH   ;Top of BASIC line input buffer
              	                                 ;so is "free ram" when BASIC resets
              	
              	;CR              EQU     0DH
              	;LF              EQU     0AH
              	;CS              EQU     0CH             ; Clear screen
              	
              	;                .ORG 0000H
              	;------------------------------------------------------------------------------
              	; Reset
              	;RST00:
              	;        DI                       ;Disable interrupts
              	;        JP       INITG80            ;Initialize Hardware and go
              	;------------------------------------------------------------------------------
              	;TX a character over RS232
0007: FF      	                ORG     0008H
0008:         	RST08:
0008: C3C600  	        JP TXDOS
              	;------------------------------------------------------------------------------
              	;RX a character over RS232 Channel A [Console], hold here until char ready.
000B: FFFFFFFF	                ORG 0010H
000F: FF      	
0010:         	RST10:
0010: C3DF00  	        JP GET_KEYB
              	;------------------------------------------------------------------------------
              	;Check serial status
0013: FFFFFFFF	                ORG 0018H
0017: FF      	
0018:         	RST18:
0018: C5      	        PUSH BC
              	        
              	        IF (SERIAL = 0)
0019: CDC103  	        CALL RXA_RDY
              	        ENDIF
              	        
              	        IF (SERIAL = 1)
              	        CALL RXB_RDY
              	        ENDIF
              	        
001C: CA2400  	        JP Z,HASCHR             ; If character on port RXB_RDY is zero otherwise it will be non zero
001F: 3E00    	        LD A,00H                ; No Character on port set A=00H
0021: C32600  	        JP RST18DONE
0024: 3E01    	HASCHR: LD A,01H                ; Character on port set A=01H
              	        
0026:         	RST18DONE:
0026: FE00    	        CP 00H
0028: C1      	        POP BC
0029: C9      	        RET
              	
              	;------------------------------------------------------------------------------
              	;RST 38 - INTERRUPT VECTOR [ for IM 1 ]
002A: FFFFFFFF	                ORG     0038H
002E: FF...   	
0038:         	RST38:
0038: 2A00FF  	        LD HL,(IRQ_VECTOR)      ;LOAD INTERRUPT VECTOR AT ADDRESS FF00H
003B: E9      	        JP (HL)                 ;AND JUMP TO THE MODE 1 INTERRUPT HANDLER
              	        ;RETI
              	        
              	
003C:         	BASSETUP:
003C: 21ED80  	        LD HL,TEMPSTACK         ;TEMP STACK
003F: F9      	        LD SP,HL                ;SETUP TEMP STACK
              	
0040: 21BE00  	        LD HL,CLSBASMSG         ;CLEAR SCREEN
0043: CD8F03  	        CALL PRINT_STRING       ;OUTPUT STRING
0046: 217F00  	        LD HL,SIGNONBAS1           ;SIGN-ON MESSAGE
0049: CD8F03  	        CALL PRINT_STRING       ;OUTPUT STRING
004C: 3A4480  	        LD A,(basicStarted)     ;CHECK BASIC FLAG
004F: FE59    	        CP 'Y'                  ;TO SEE IF THIS IS POWER-UP
0051: 2016    	        JR NZ,COLDSTART         ;IF COLD, COLD START
0053: 219E00  	        LD HL,SIGNONBAS2           ;COLD/WARM MESSAGE
0056: CD8F03  	        CALL PRINT_STRING
              	        
0059:         	COLD_OR_WARM:
0059: CDDF00  	        CALL GET_KEYB
005C: E6DF    	        AND 0DFH                ;LOWER TO UPPER CASE
005E: FE43    	        CP 'C'
0060: 200F    	        JR NZ,CHECKWARM
0062: CF      	        RST 08H
0063: 3E0D    	        LD A,CR
0065: CF      	        RST 08H
0066: 3E0A    	        LD A,LF
0068: CF      	        RST 08H
0069:         	COLDSTART:
0069: 3E59    	        LD A,'Y'                ;SET BASIC STARTED FLAG
006B: 324480  	        LD (basicStarted),A
006E: C3F714  	        JP COLD          ;START BASIC COLD
0071:         	CHECKWARM:
0071: FE57    	        CP 'W'
0073: 20E4    	        JR NZ,COLD_OR_WARM
0075: CF      	        RST 08H
0076: 3E0D    	        LD A,CR
0078: CF      	        RST 08H
0079: 3E0A    	        LD A,LF
007B: CF      	        RST 08H
007C: C3FA14  	        JP COLD+3        ;START BASIC WARM
              	
007F:         	SIGNONBAS1:
007F: 0C      	        DB      CS
0080: 4738302D	        DB      "G80-USB/S - Pat Dziuk, 2021",CR,LF,0
0084: 5553422F	
0088: 53202D20	
008C: 50617420	
0090: 447A6975	
0094: 6B2C2032	
0098: 3032310D	
009C: 0A00    	
009E:         	SIGNONBAS2:
009E: 0D0A    	        DB      CR,LF
00A0: 436F6C64	        DB      "Cold or Warm Start (C or W)? ",0
00A4: 206F7220	
00A8: 5761726D	
00AC: 20537461	
00B0: 72742028	
00B4: 43206F72	
00B8: 2057293F	
00BC: 2000    	
00BE:         	CLSBASMSG: 
00BE: 1B5B324A	        DB      ESC,"[2J",ESC,"[H",00H
00C2: 1B5B4800	
              	
00C6: E5      	TXDOS:  PUSH HL
00C7: F5      	        PUSH AF
00C8: C5      	        PUSH BC
00C9:         	TXDOS_RDY:			;CHECK IF SIO IS READY TO TRANSMIT.
00C9: 3E00    	        LD A,00H
              	        
              	        IF (SERIAL = 0)
00CB: D302    	        OUT (SIOA_C),A          ;SELECT REGISTER 0
00CD: DB02    	        IN A,(SIOA_C)           ;READ REGISTER 0
              	        ENDIF
              	        
              	        IF (SERIAL = 1)
              	        OUT (SIOB_C),A          ;SELECT REGISTER 0
              	        IN A,(SIOB_C)           ;READ REGISTER 0
              	        ENDIF
              	        
00CF: CB0F    	        RRC A
00D1: CB0F    	        RRC A
00D3: 0E01    	        LD C,01H                ;ROTATE, AND, THEN SUB
00D5: A1      	        AND C
00D6: 91      	        SUB C
00D7: 20F0    	        JR NZ,TXDOS_RDY           ;TRY AGAIN IF NOT READY
00D9: C1      	        POP BC
00DA: F1      	        POP AF
00DB: E1      	        POP HL
              	        
              	        IF (SERIAL = 0)
00DC: D300    	        OUT (SIOA_D),A
              	        ENDIF
              	        
              	        IF (SERIAL = 1)
              	        OUT (SIOB_D),A
              	        ENDIF
              	        
00DE: C9      	        RET
              	
00DF:         	GET_KEYB:
00DF: C5      	        PUSH BC
00E0:         	RXDOS_RDY:
00E0: 3E00    	        LD A,00H                ;SETUP THE STATUS REGISTER
              	        
              	        IF (SERIAL = 0)
00E2: D302    	        OUT (SIOA_C),A
00E4: DB02    	        IN A,(SIOA_C)           ;LOAD THE STATUS BYTE
              	        ENDIF
              	        
              	        IF (SERIAL = 1)
              	        OUT (SIOB_C),A
              	        IN A,(SIOB_C)           ;LOAD THE STATUS BYTE
              	        ENDIF
              	        
00E6: 0E01    	        LD C,01H                ;LOAD BYTE TO COMPARE THE BIT, AND COMPARE
00E8: A1      	        AND C
00E9: 91      	        SUB C
00EA: 20F4    	        JR NZ, RXDOS_RDY
              	        
              	        IF (SERIAL = 0)
00EC: DB00    	        IN A,(SIOA_D)
              	        ENDIF
              	        
              	        IF (SERIAL = 1)
              	        IN A,(SIOB_D)
              	        ENDIF
              	        
00EE: C1      	        POP BC
00EF: C9      	        RET
              	        ENDIF
              	
              	;-------------------------------------------------------------------------------
              	; DOS CALLS
              	;-------------------------------------------------------------------------------
00F0: FFFFFFFF	                ORG     0100h
00F4: FF...   	
0100:         	DCALL0:                         ;CALL 00100h
0100: C36B02  	        JP RAM_CLR
0103:         	DCALL1:                         ;CALL 0103h
0103: C38C02  	        JP DELAY
0106:         	DCALL2:                         ;CALL 0106h
0106: C39902  	        JP MILLI_DLY
0109:         	DCALL3:                         ;CALL 0109h
0109: C3A602  	        JP BUF_CLR
010C:         	DCALL4:                         ;CALL 010Ch
010C: C3BD02  	        JP BUF_WRITE
010F:         	DCALL5:                         ;CALL 010Fh
010F: C35C03  	        JP PRINT_CHAR
0112:         	DCALL6:                         ;CALL 0112h
0112: C36603  	        JP PRINT_HEX
0115:         	DCALL7:                         ;CALL 0115h
0115: C38F03  	        JP PRINT_STRING
0118:         	DCALL8:                         ;CALL 0118h
0118: C39F03  	        JP TXA_RDY
011B:         	DCALL9:                         ;CALL 011Bh
011B: C3C103  	        JP RXA_RDY
011E:         	DCALL10:                        ;CALL 011Eh
011E: C3B003  	        JP TXB_RDY
0121:         	DCALL11:                        ;CALL 0121h
0121: C3CC03  	        JP RXB_RDY
0124:         	DCALL12:                        ;CALL 0124h
0124: C3D703  	        JP GET_KEY
0127:         	DCALL13:                        ;CALL 0127h
0127: C3F203  	        JP ASCIIHEX_TO_BYTE
012A:         	DCALL14:                        ;CALL 012Ah
012A: C30304  	        JP CONVERT_HEX_VAL
              	
              	;DCALL15 .. DCALL24
              	
              	;-------------------------------------------------------------------------------
              	; MONITOR/OS
              	;-------------------------------------------------------------------------------
012D: FFFFFFFF	                ORG     0200H
0131: FF...   	
              	; INIT IS THE ROUTINE THAT SETS UP, OR INITIALIZES, THE PERIPHERALS.
0200:         	INIT:
0200: CD2802  	        CALL SERIAL_INIT
              	
              	        IF (BOARD = 1)
              	        CALL PIO_INIT                   ;G80-UVK Only
              	        CALL DELAY
              	        CALL DELAY
              	        CALL DELAY
              	        CALL DELAY
              	        ENDIF
              	
0203: 218006  	        LD HL,CS_MSG
0206: CD8F03  	        CALL PRINT_STRING
0209: 218806  	        LD HL,SIGNON_MSG
020C: CD8F03  	        CALL PRINT_STRING
              	
020F: CD0310  	        CALL configure_memorystick
0212: CD8410  	        CALL get_module_version
              	
0215: CDDF03  	        CALL PRINT_PROMPT
              	
              	; SERMAIN_LOOP, THE MAIN LOOP FOR THE SERIAL MONITOR.
0218:         	MAIN_LOOP:
0218: CDD703  	        CALL GET_KEY                    ;IF SET, GET THE KEY.
021B: CDBD02  	        CALL BUF_WRITE                  ;WRITE TO BUFFER
021E: 0E0D    	        LD C,CR                         ;CHECK IF CARRAGE RETURN
0220: 91      	        SUB C
0221: 20F5    	        JR NZ,MAIN_LOOP                 ;IF NOT LINE FEED, RESTART LOOP
0223: CD770D  	        CALL IN_CMD_CHK                 ;CHECK IF COMMAND
0226: 18F0    	        JR MAIN_LOOP
              	
              	
              	        INCLUDE "sys_routines.asm"
              	
              	;System Routines
              	
              	;-------------------------------------------------------------------------------
              	; SERIAL_INIT IS A ROUTINE TO INITALIZE THE Z80 DART OR SIO-0 FOR SERIAL
              	;  TRANSMITTING AND RECEIVING ON BOTH PORT A AND PORT B.  THIS SETS UP
              	;  BOTH PORTS FOR 57,600 BAUD (WITH 1.8432MHZ CLOCK) WITHOUT HANDSHANKING,
              	;  AND NO INTERRUPTS. THEN RETURNS.  DESTROYS REGISTERS: A.
              	;-------------------------------------------------------------------------------
0228:         	SERIAL_INIT:                    ;WORKING MODEL OF SERIAL INITIALIZATION
              	                                ;SETTING UP FOR 57600 BAUD
              	        ;SETUP PORT A
0228: 3E00    	        LD A,00H                ;REQUEST REGISTER #0
022A: D302    	        OUT (SIOA_C),A
022C: 3E18    	        LD A,18H                ;LOAD #0 WITH 18H - CHANNEL RESET
022E: D302    		OUT (SIOA_C),A
0230: 00      	        NOP
              	
0231: 3E04    		LD A,04H                ;REQUEST TRANSFER TO REGISTER #4
0233: D302    		OUT (SIOA_C),A
0235: 3E8C    	        LD A,SIOA_CLK           ;WRITE #4 WITH X/32 CLOCK 1X STOP BIT
0237: D302    	        OUT (SIOA_C),A          ;  AND NO PARITY
              	
0239: 3E03    	        LD A,03H                ;REQUEST TRANSFER TO REGISTER #3
023B: D302    	        OUT (SIOA_C),A
023D: 3EC1    	        LD A,0C1H
023F: D302    	        OUT (SIOA_C),A          ;WRITE #3 WITH C1H - RECEIVER 8 BITS & RX ENABLE
              	
0241: 3E05    	        LD A,05H                ;REQUEST TRANSFER TO REGISTER #5
0243: D302    	        OUT (SIOA_C),A
0245: 3E68    	        LD A,068H
0247: D302    	        OUT (SIOA_C),A          ;WRITE #5 WITH 60H - TRANSMIT 8 BITS & TX ENABLE
              	
              	        ;SETUP PORT B
0249: 3E00    	        LD A,00H                ;REQUEST REGISTER #0
024B: D303    	        OUT (SIOB_C),A
024D: 3E18    	        LD A,18H                ;LOAD #0 WITH 18H - CHANNEL RESET
024F: D303    		OUT (SIOB_C),A
0251: 00      	        NOP
              	
0252: 3E04    		LD A,04H                ;REQUEST TRANSFER TO REGISTER #4
0254: D303    		OUT (SIOB_C),A
0256: 3E8C    	        LD A,SIOB_CLK           ;WRITE #4 WITH X/32 CLOCK 1X STOP BIT
0258: D303    	        OUT (SIOB_C),A          ;  AND NO PARITY
              	
025A: 3E03    	        LD A,03H                ;REQUEST TRANSFER TO REGISTER #3
025C: D303    	        OUT (SIOB_C),A
025E: 3EC1    	        LD A,0C1H
0260: D303    	        OUT (SIOB_C),A          ;WRITE #3 WITH C1H - RECEIVER 8 BITS & RX ENABLE
              	
0262: 3E05    	        LD A,05H                ;REQUEST TRANSFER TO REGISTER #5
0264: D303    	        OUT (SIOB_C),A
0266: 3E68    	        LD A,068H
0268: D303    	        OUT (SIOB_C),A          ;WRITE #5 WITH 60H - TRANSMIT 8 BITS & TX ENABLE
              	
026A: C9      	        RET
              	
              	;-------------------------------------------------------------------------------
              	; PIO_INIT IS A ROUTINE FOR SETTING THE PIO UP FOR THE G80-UVK COMPUTER.
              	;-------------------------------------------------------------------------------
026B:         	PIO_INIT:
              	        IF (BOARD = 1)
              	        LD A,82H
              	        OUT (PIOCMD),A
              	        RET
              	        ENDIF
              	;-------------------------------------------------------------------------------
              	; RAMCLR IS A FUNCTION THAT CLEARS THE RAM FROM BOTTOM TO TOP.
              	;  IT LOADS THE ADDRESS INTO B&C AND LOADS THE ADDRESS WITH
              	;  00h UNTIL THE ADDRESS REACHES FAF9h (LEAVING THE STACK INTACT), THEN CLEARS
              	;  THE MEMORY ABOVE THE STACK, THEN RETURNS.
              	;  IT DESTROYS: A,B & C REGISTERS
              	;-------------------------------------------------------------------------------
026B:         	RAM_CLR:
026B: 213308  	        LD HL,MEMORY_CLR_MSG
026E: CD8F03  	        CALL PRINT_STRING
0271: 01FF7F  	        LD  BC,ROM_TOP
0274:         	RAM_CLRL:
0274: 03      		INC BC
0275: 3EFF    		LD A, 0FFH
0277: 02      	    	LD (BC),A
0278: 3EFA    	        LD A,0FAH
027A: 90      		SUB B
027B: 20F7    		JR NZ,RAM_CLRL
027D: 3EF9    		LD A, 0F9H
027F: 91      	    	SUB C
0280: 20F2    	    	JR NZ ,RAM_CLRL
0282: 21F308  	        LD HL,DONE_MSG
0285: CD8F03  	        CALL PRINT_STRING
0288: CDDF03  	        CALL PRINT_PROMPT
028B: C9      	        RET
              	
              	;-------------------------------------------------------------------------------
              	; DELAY IS A FUNCTION THAT BURNS 1,499,992 CLOCK CYCLES.
              	;  AT 6MHZ [(57,692 LOOPS X 26 CLOCKS CYCLES) / 6,000,000] = 0.249998 SECONDS
              	;  THIS IS A GENERAL PURPOSE DELAY TIMER THAT CAN BE USED TO DEBOUNCE INPUTS,
              	;  OR ANY OTHER APPLICATION WHERE A DELAY IS NEEDED.
              	;-------------------------------------------------------------------------------
028C:         	DELAY:
028C: F5      	        PUSH AF
028D: C5      	        PUSH BC
028E: 015CE1  	        LD  BC,0E15CH           ; 57,692 LOOPS
0291:         	DELAYL:
0291: 0B      		DEC BC
0292: 79      		LD  A,C
0293: B0      		OR  B
0294: 20FB    		JR  NZ,DELAYL
0296: C1      	        POP BC
0297: F1      	        POP AF
0298: C9      		RET
              	;-------------------------------------------------------------------------------
              	; HALF_DELAY IS A FUNCTION THAT IS FUNCTIONALLY IDENTICAL TO DELAY.
              	;  IT IS DESIGNED TO BURN 749,996 CLOCK CYCLES.
              	;  AT 6MHZ [(28,846 LOOPS X 26 CLOCK CYCLES) / 6,000,000] = 0.124999 SECONDS
              	; DELAY OF 1 MILLISECOND
              	;-------------------------------------------------------------------------------
0299:         	MILLI_DLY:
0299: F5      	        PUSH AF
029A: C5      	        PUSH BC
029B: 01E700  	        LD  BC,00E7H           ; 6006 INSTRUCTIONS
029E:         	MILLI_DLYL:
029E: 0B      		DEC BC
029F: 79      		LD  A,C
02A0: B0      		OR  B
02A1: 20FB    		JR  NZ,MILLI_DLYL
02A3: C1      	        POP BC
02A4: F1      	        POP AF
02A5: C9      		RET
              	;-------------------------------------------------------------------------------
              	; BUF_CLR IS A FUNCTION THAT CLEARS THE BUFFER FROM BOTTOM TO TOP.
              	;  IT LOADS THE ADDRESS INTO B&C AND LOADS THE ADDRESS WITH
              	;  00h UNTIL THE ADDRESS REACHES FFFFh, THEN RETURNS.
              	;-------------------------------------------------------------------------------
02A6:         	BUF_CLR:
02A6: F5      	        PUSH AF                 ;SAVE THE REGISTERS
02A7: C5      	        PUSH BC
02A8: 01D9FF  	        LD  BC,BUF_POINTER      ;LOAD UP THE POINTER ADDRESS
02AB:         	BUF_CLRL:
02AB: 03      		INC BC                  ;INCREMENT THE COUNTER
02AC: 3E00    		LD A, 00H               ;LOAD BYTE TO FILL WITH, AND WRITE
02AE: 02      	    	LD (BC),A
02AF: 3EFF    	        LD A,0FFH               ;NOW CHECK IF END OF BUFFER
02B1: 91      		SUB C
02B2: 20F7    		JR NZ,BUF_CLRL          ;IF NOT DO AGAIN
02B4: 01D9FF  	        LD BC,BUF_POINTER       ;IF YES RELOAD THE POINTER ADDRESS
02B7: 3E01    	        LD A,01H
02B9: 02      	        LD (BC),A               ;WRITE THE POINTER.
02BA: C1      	        POP BC
02BB: F1      	        POP AF
02BC: C9      		RET
              	;-------------------------------------------------------------------------------
              	; BUF_WRITE IS THE ROUTINE FOR WRITING TO THE KEYBOARD BUFFER FROM REGISTER A.
              	;  IT EXPECTS THE CHARACTER TO BE IN REGISTER A, AND ALSO CHECKS TO MAKE SURE
              	;  THAT THE BUFFER IS NOT GOING TO OVERFLOW.
              	;-------------------------------------------------------------------------------
02BD:         	BUF_WRITE:
02BD: F5      	        PUSH AF                 ;SAVE THE REGISTERS
02BE: E5      	        PUSH HL
02BF: C5      	        PUSH BC
              	
02C0: 47      	        LD B,A                  ;SAVE THE CHARACTER
02C1: 0E0D    	        LD C,CR
02C3: 91      	        SUB C                   ;CHECK IF CARRIAGE RETURN
02C4: CAF802  	        JP Z,BUF_RESTORE
              	
              	
02C7: 78      	        LD A,B                  ;RESTORE THE BYTE
02C8: 0E0A    	        LD C,LF
02CA: 91      	        SUB C                   ;NOW CHECK IF LINE FEED
02CB: CAF802  	        JP Z,BUF_RESTORE
              	
02CE: 78      	        LD A,B
02CF: 0E08    	        LD C,BKSP
02D1: 91      	        SUB C
02D2: CA0B03  	        JP Z,BUF_BACKSPACE
              	
02D5: 78      	        LD A,B                  ;RESTORE THE BYTE
02D6: CD5C03  	        CALL PRINT_CHAR         ;ECHO THE CHARACTER BACK TO TERMINAL
              	
02D9: CD3D03  	        CALL BUF_LOWERCASE_UPPER ;CALL ROUTINE TO CONVERT THE BYTE TO UPPERCASE
              	
02DC: 21D9FF  	        LD HL,BUF_POINTER       ;LOAD UP THE POINTER
02DF: 010000  	        LD BC,0000H             ;ZERO THE REGISTER, SO THAT THERE IS NO ERROR
02E2: 4E      	        LD C,(HL)
02E3: 09      	        ADD HL,BC               ;DETERMINE BUFFER LOCATION, STORES IN HL
02E4:         	BUF_WR_CHK:
02E4: 47      	        LD B,A                  ;SAVE THE BYTE TO BE WRITTEN
02E5: 3EFF    	        LD A,0FFH               ;LOAD TOP OF BUFFER.
02E7: 4D      	        LD C,L                  ;COMPARE
02E8: 91      	        SUB C
02E9: CA4A03  	        JP Z,OVERFLOW           ;IF OVERFLOW, GO TO OVERFLOW ROUTINE
02EC:         	BUF_WR:
02EC: 78      	        LD A,B                  ;RESTORE THE BYTE
02ED: 77      	        LD (HL),A               ;WRITE THE BYTE TO THE BUFFER
02EE: 21D9FF  	        LD HL,BUF_POINTER
02F1: 7E      	        LD A,(HL)               ;LOAD THE POINTER
02F2: 3C      	        INC A                   ;INC THE POINTER
02F3: 77      	        LD (HL),A               ;STORE THE POINTER
02F4: C1      	        POP BC
02F5: E1      	        POP HL                  ;RESTORE THE REGISTERS
02F6: F1      	        POP AF
02F7: C9      	        RET
              	
02F8:         	BUF_RESTORE:
02F8: 78      	        LD A,B
02F9: CD5C03  	        CALL PRINT_CHAR         ;ECHO THE CHARACTER
              	
02FC: 21D9FF  	        LD HL,BUF_POINTER       ;LOAD UP THE POINTER
02FF: 010000  	        LD BC,0000H             ;ZERO THE REGISTER, SO THAT THERE IS NO ERROR
0302: 4E      	        LD C,(HL)
0303: 09      	        ADD HL,BC               ;DETERMINE BUFFER LOCATION, STORES IN HL
0304: 3E20    	        LD A,SPACE
0306: 77      	        LD (HL),A               ;WRITE A SPACE SO THAT CMD RECOG CAN DETERMINE
              	
0307: C1      	        POP BC                  ;RESTORE THE REGISTERS
0308: E1      	        POP HL
0309: F1      	        POP AF
030A: C9      	        RET                     ;RETURN
              	
030B:         	BUF_BACKSPACE:
030B: 21D9FF  	        LD HL,BUF_POINTER       ;FIRST, TEST IF THERE IS SOMETHING TO DELETE
030E: 7E      	        LD A,(HL)
030F: 0E01    	        LD C,01H
0311: 91      	        SUB C
0312: CA3903  	        JP Z,BUF_BACKSPACE_RET  ;RETURN IF SO.
              	        IF (SERIAL = 0)
0315: CD9F03  	        CALL TXA_RDY
              	        ENDIF
              	        IF (SERIAL = 1)
              	        CALL TXB_RDY
              	        ENDIF
0318: 78      	        LD A,B
0319: CD5C03  	        CALL PRINT_CHAR         ;SEND THE BACKSPACE TO THE TERMINAL
              	        IF (SERIAL = 0)
031C: CD9F03  	        CALL TXA_RDY
              	        ENDIF
              	        IF (SERIAL = 1)
              	        CALL TXB_RDY
              	        ENDIF
031F: 3E20    	        LD A,SPACE
0321: CD5C03  	        CALL PRINT_CHAR
              	        IF (SERIAL = 0)
0324: CD9F03  	        CALL TXA_RDY
              	        ENDIF
              	        IF (SERIAL = 1)
              	        CALL TXB_RDY
              	        ENDIF
0327: 78      	        LD A,B
0328: CD5C03  	        CALL PRINT_CHAR
032B: 3E00    	        LD A,00H
032D: 010000  	        LD BC,0000H             ;ZERO THE REGISTER, SO THAT THERE IS NO ERROR
0330: 4E      	        LD C,(HL)
0331: 09      	        ADD HL,BC
0332: 77      	        LD (HL),A               ;CLEAR THE ITEM FROM THE BUFFER
0333: 21D9FF  	        LD HL,BUF_POINTER
0336: 7E      	        LD A,(HL)               ;NOW ADJUST THE POINTER
0337: 3D      	        DEC A
0338: 77      	        LD (HL),A
0339:         	BUF_BACKSPACE_RET:
0339: C1      	        POP BC
033A: E1      	        POP HL                  ;RESTORE REGISTERS AND RETURN
033B: F1      	        POP AF
033C: C9      	        RET
              	
033D:         	BUF_LOWERCASE_UPPER:            ;CONVERT TO UPPERCASE, OR RETURN IF UPPER
033D: 0E61    	        LD C,061H
033F: 91      	        SUB C
0340: FA4803  	        JP M,BUF_UPPER_RETURN   ;RETURN IF UPPER
0343: 78      	        LD A,B
0344: 0E20    	        LD C,020H
0346: 91      	        SUB C
0347: C9      	        RET
0348:         	BUF_UPPER_RETURN:
0348: 78      	        LD A,B                  ;RESTORE THE CHARACTER THEN RETURN
0349: C9      	        RET
              	;-------------------------------------------------------------------------------
              	; OVERFLOW IS THE ROUTINE TO ACKNOWLEDGE THAT THE BUFFER HAS OVERFLOWED, INFORM
              	;  THE USER OF THE OVERFLOW, CLEAR THE BUFFER, RESETS THE POINTER, RESET THE
              	;  STACK, AND RETURN TO THE MAIN PROGRAM LOOP. THE SYSTEM ESSENTIALLY RESETS TO
              	;  THE PROMPT.
              	;-------------------------------------------------------------------------------
034A:         	OVERFLOW:
034A: 21C608  	        LD HL,OVERFLOW_ERROR_MSG
034D: CD8F03  	        CALL PRINT_STRING
0350: CDA602  	        CALL BUF_CLR
0353: 31FFFE  	        LD SP,STACK
0356: CDDF03  	        CALL PRINT_PROMPT
0359: C31802  	        JP MAIN_LOOP
              	;-------------------------------------------------------------------------------
              	; PRINT_CHAR IS A ROUTINE THAT PRINTS A CHARACTER TO SERIAL PORT A.
              	;  IT CALLS TXA_RDY TO SEE IF THE SERIAL PORT IS READY TO TRANSMIT, THEN
              	;  SENDS WHATEVER CHARACTER IS IN REGISTER A.
              	;-------------------------------------------------------------------------------
035C:         	PRINT_CHAR:
              	        IF (BOARD = 0)
035C: F5      	        PUSH AF
035D: C5      	        PUSH BC
              	        IF (SERIAL = 0)
035E: CD9F03  	        CALL TXA_RDY            ; CHECK IF READY TO SEND
              	        ENDIF
              	        IF (SERIAL = 1)
              	        CALL TXB_RDY
              	        ENDIF
0361: C1      	        POP BC
0362: F1      	        POP AF
              	        IF (SERIAL = 0)
0363: D300    	        OUT (SIOA_D),A          ; PRINT IT
              	        ENDIF
              	        IF (SERIAL = 1)
              	        OUT (SIOB_D),A
              	        ENDIF
0365: C9      	        RET
              	        ENDIF
              	
              	        IF (BOARD = 1)
              	        PUSH AF                 ;Save the Registers
              	        PUSH BC
              	        OUT (PIOA),A            ;Latch the data
              	PRINT_CHAR2:
              	        IN A,(PIOB)             ;Get Status Byte Value
              	        LD C,01H
              	        AND C                   ;Mask the bit off.
              	        CP 00H                  ;Is it a 1 or 0?
              	        JR Z,PRINT_CHAR3        ;Move on if 0.
              	        LD A,00H                ;If not make it 0.
              	        JR PRINT_CHAR4
              	PRINT_CHAR3:
              	        LD A,01H                ;Make it a 1.
              	PRINT_CHAR4:
              	        LD C,0FEH               ;Unmask the bit.
              	        OR C
              	        OUT (PIOC),A            ;Flip the bit.
              	PRINT_CHAR5:
              	        IN A,(PIOB)             ;Get the Status Byte
              	        LD C,03H
              	        AND C                   ;Mask it off
              	        CP 03H                  ;Acknowledged?
              	        JR Z,PRINT_CHAR6        ;If so go on.
              	        CP 00H
              	        JR Z,PRINT_CHAR6
              	        JR PRINT_CHAR5          ;If not, try again.
              	PRINT_CHAR6:
              	        POP BC
              	        POP AF
              	        RET
              	        ENDIF
              	;-------------------------------------------------------------------------------
              	; PRINT_HEX IS A ROUTINE THAT CONVERTS A NUMBER TO THE ASCII REPRESENTATION
              	;  OF THE NUMBER, AND SENDS THE CHARACTERS TO THE PRINT_CHAR ROUTINE TO BE
              	;  SENT OVER SERIAL.  IT EXPECTS THE NUMBER TO PRINT TO BE STORED IN A. I HAVE
              	;  MADE MODIFICATIONS TO THE CODE TO ALLOW IT TO RUN ON THE G80. THIS CODE IS
              	;  AVAILABLE ON SEVERAL PLACES THROUGHOUT THE WEB, AND I DO NOT KNOW IF THE
              	;  ORIGINAL AUTHOR'S NAME HAS BEEN LOST TO TIME. THE VERSION I USED IS BELOW.
              	;  ORIGIN:  WWW.KNOERIG.DE/ELEKTRONIK/Z80/BILDER/MONITOR.ASM
              	;-------------------------------------------------------------------------------
0366:         	PRINT_HEX:
0366: F5      	        PUSH AF
0367: C5      	        PUSH BC
0368: D5      	        PUSH DE
0369: 47      	        LD B,A          ;STORE THE NUMBER
036A: CD7503  	        CALL PRINT_HEX_1
036D: 78      	        LD A,B          ;RESTORE THE NUMBER
036E: CD8403  	        CALL PRINT_HEX_3
0371: D1      	        POP DE
0372: C1      	        POP BC
0373: F1      	        POP AF
0374: C9      	        RET
0375:         	PRINT_HEX_1:
0375: 1F      	        RRA
0376: 1F      	        RRA
0377: 1F      	        RRA
0378: 1F      	        RRA
0379:         	PRINT_HEX_2:
0379: F6F0    	        OR 0F0H
037B: 27      	        DAA
037C: C6A0    	        ADD A,0A0H
037E: CE40    	        ADC A,040H
0380: CD5C03  	        CALL PRINT_CHAR
              	        ;INC DE         ;I DO NOT THINK THIS IS NEEDED, IF NOT, PRINT_HEX_3
0383: C9      	        RET             ;IS NOT NEEDED EITHER.
0384:         	PRINT_HEX_3:
0384: F6F0    	        OR 0F0H
0386: 27      	        DAA
0387: C6A0    	        ADD A,0A0H
0389: CE40    	        ADC A,040H
038B: CD5C03  	        CALL PRINT_CHAR
038E: C9      	        RET
              	;-------------------------------------------------------------------------------
              	; PRINT_STRING IS A ROUTINE THAT PRINTS A STRING TO SERIAL PORT A.
              	;  IT CALLS TXA_RDY TO SEE IF THE SERIAL PORT IS READY TO TRANSMIT, LOADS
              	;  A CHARACTER FROM THE MEMORY ADDRESS POINTED TO BY HL, CHECKS IF IT IS 00H,
              	;  RETURNS IF IT IS 00H, IF NOT IT SENDS THE CHARACTER, INCREMENTS HL,
              	;  THEN JUMPS BACK TO THE BEGINNING.
              	;-------------------------------------------------------------------------------
038F:         	PRINT_STRING:
              	        IF (BOARD = 0)
038F: F5      	        PUSH AF
0390: C5      	        PUSH BC
              	        IF (SERIAL = 0)
0391: CD9F03  	        CALL TXA_RDY            ;CHECK IF READY TO SEND
              	        ENDIF
              	        IF (SERIAL = 1)
              	        CALL TXB_RDY
              	        ENDIF
0394: C1      	        POP BC
0395: F1      	        POP AF
              	        ENDIF
0396: 7E      	        LD A,(HL)               ;GET CHARACTER
0397: B7      	        OR A
0398: C8      	        RET Z                   ;RETURN IF ZERO
0399: CD5C03  	        CALL PRINT_CHAR         ;SEND CHARACTER
039C: 23      	        INC HL
039D: 18F0    	        JR PRINT_STRING         ;LOOP FOR NEXT BYTE
              	;-------------------------------------------------------------------------------
              	; TX*_RDY IS A ROUTINE THAT CHECKS THE STATUS OF THE SERIAL PORT A TO SEE IF
              	;  THE PORT IS DONE TRANSMITTING THE PREVIOUS BYTE.  IT READS THE STATUS BYTE
              	;  OF PORT A, ROTATES RIGHT TWICE, THEN ANDS WITH 01h AND SUBS 01h TO DETERMINE
              	;  IF THE TRANSMIT BUSY FLAG IS SET.  IF NOT IT RETURNS, IF IT IS SET IT
              	;  CONTINUES TO CHECK BY LOOPING.
              	;  DESTROYS A & C.
              	;-------------------------------------------------------------------------------
039F:         	TXA_RDY:
039F: 3E00    	        LD A,00H
03A1: D302    	        OUT (SIOA_C),A          ;SELECT REGISTER 0
03A3: DB02    	        IN A,(SIOA_C)           ;READ REGISTER 0
03A5: CB0F    	        RRC A
03A7: CB0F    	        RRC A
03A9: 0E01    	        LD C,01H                ;ROTATE, AND, THEN SUB
03AB: A1      	        AND C
03AC: 91      	        SUB C
03AD: C8      	        RET Z                   ;RETURN IF AVAILABLE
03AE: 18EF    	        JR TXA_RDY
03B0:         	TXB_RDY:
03B0: 3E00    	        LD A,00H
03B2: D303    	        OUT (SIOB_C),A          ;SELECT REGISTER 0
03B4: DB03    	        IN A,(SIOB_C)           ;READ REGISTER 0
03B6: CB0F    	        RRC A
03B8: CB0F    	        RRC A
03BA: 0E01    	        LD C,01H                ;ROTATE, AND, THEN SUB
03BC: A1      	        AND C
03BD: 91      	        SUB C
03BE: C8      	        RET Z                   ;RETURN IF AVAILABLE
03BF: 18EF    	        JR TXB_RDY
              	;-------------------------------------------------------------------------------
              	; RX*_RDY IS A ROUTINE THAT CHECKS THE STATUS OF THE SERIAL PORT A TO SEE IF
              	;  THE PORT HAS RECEIVED A BYTE.  IT READS THE STATUS BYTE OF PORT A,
              	;  ANDS WITH 01h AND SUBS 01h. THE RESULT IS THEN RETURNED TO THE CALLER.
              	;  DESTROYS REGISTERS: A & C.
              	;-------------------------------------------------------------------------------
03C1:         	RXA_RDY:
03C1: 3E00    	        LD A,00H                ;SETUP THE STATUS REGISTER
03C3: D302    	        OUT (SIOA_C),A
03C5: DB02    	        IN A,(SIOA_C)           ;LOAD THE STATUS BYTE
03C7: 0E01    	        LD C,01H                ;LOAD BYTE TO COMPARE THE BIT, AND COMPARE
03C9: A1      	        AND C
03CA: 91      	        SUB C
03CB: C9      	        RET
03CC:         	RXB_RDY:
03CC: 3E00    	        LD A,00H                ;SETUP THE STATUS REGISTER
03CE: D303    	        OUT (SIOB_C),A
03D0: DB03    	        IN A,(SIOB_C)           ;LOAD THE STATUS BYTE
03D2: 0E01    	        LD C,01H                ;LOAD BYTE TO COMPARE THE BIT, AND COMPARE
03D4: A1      	        AND C
03D5: 91      	        SUB C
03D6: C9      	        RET
              	;-------------------------------------------------------------------------------
              	; GET_KEY SIMPLY GETS THE KEY PRESS IF AVAILABLE.
              	;-------------------------------------------------------------------------------
03D7:         	GET_KEY:
              	        IF (BOARD = 0)          ;G80-S/USB VERSION
              	        IF (SERIAL = 0)
03D7: CDC103  	        CALL RXA_RDY
              	        ENDIF
              	        IF (SERIAL = 1)
              	        CALL RXB_RDY
              	        ENDIF
03DA: 20FB    	        JR NZ, GET_KEY
              	        IF (SERIAL = 0)
03DC: DB00    	        IN A,(SIOA_D)
              	        ENDIF
              	        IF (SERIAL = 1)
              	        IN A,(SIOB_D)
              	        ENDIF
03DE: C9      	        RET
              	        ENDIF
              	
              	        IF (BOARD = 1)          ;G80-UVK VERSION
              	        IF (SERIAL = 0)
              	        CALL RXA_RDY
              	        ENDIF
              	        IF (SERIAL = 1)
              	        CALL RXB_RDY
              	        ENDIF
              	        JR NZ, GET_KEY
              	        IF (SERIAL = 0)
              	        IN A,(SIOA_D)
              	        ENDIF
              	        IF (SERIAL = 1)
              	        IN A,(SIOB_D)
              	        ENDIF
              	        RET
              	        ENDIF
              	;-------------------------------------------------------------------------------
              	; PRINT_PROMPT DOES EXACTLY WHAT IT SAYS, IT PRINTS A PROMPT TO SERIAL
              	;  PORT A, THEN RETURNS.
              	;  DESTROYS A.
              	;-------------------------------------------------------------------------------
03DF:         	PRINT_PROMPT:
03DF: 3E0D    	        LD A,CR
03E1: CD5C03  	        CALL PRINT_CHAR
03E4: 3E0A    	        LD A,LF
03E6: CD5C03  	        CALL PRINT_CHAR
03E9: 3E3E    	        LD A,'>'               ;PRINT A ">"
03EB: CD5C03  	        CALL PRINT_CHAR
03EE: CDA602  	        CALL BUF_CLR
03F1: C9      	        RET
              	;-------------------------------------------------------------------------------
              	; ASCIIHEX_TO_BYTE IS A ROUTINE THAT CONVERTS TWO ASCII BYTES REPRESENTING A HEX
              	;  NUMBER IN DE TO THE BINARY NUMBER TO BE RETURNED IN THE ACCUMULATOR.
              	;  THE D REGISTER SHOULD BE THE MOST SIGNIFICANT NIBBLE, AND THE E REGISTER
              	;  SHOULD BE THE LEAST SIGNIFICANT NIBBLE.  THIS CODE IS A MODIFIED VERSION
              	;  OF SOME CODE I FOUND FLOATING AROUND ON THE INTERNET.  I DO NOT KNOW THE
              	;  SOURCE OF THE ORIGINAL CODE.
              	;-------------------------------------------------------------------------------
03F2:         	ASCIIHEX_TO_BYTE:
03F2: C5      	        PUSH BC                 ;SAVE REGISTERS
03F3: 7A      	        LD A,D                  ;LOAD UPPER CHARACTER
03F4: CD0304  	        CALL CONVERT_HEX_VAL    ;CONVERT THE CHARACTER
03F7: 17      	        RLA
03F8: 17      	        RLA
03F9: 17      	        RLA
03FA: 17      	        RLA
03FB: 47      	        LD B,A                  ;STORE THE FIRST NIBBLE
03FC: 7B      	        LD A,E                  ;GET SECOND CHARACTER
03FD: CD0304  	        CALL CONVERT_HEX_VAL    ;CONVERT THE CHARACTER
0400: 80      	        ADD A,B                 ;ADD THE TWO NIBBLES
0401: C1      	        POP BC
0402: C9      	        RET
              	;-------------------------------------------------------------------------------
              	; CONVERTS THE ASCII CHARACTER IN A TO IT'S HEX VALUE IN A, ERROR RETURNS 0FFH
              	;-------------------------------------------------------------------------------
0403:         	CONVERT_HEX_VAL:
0403: FE47    	        CP 'G'                  ;GREATER THAN "F"
0405: F21D04  	        JP P,CONVERT_HEX_ERROR    ;IF SO, ERROR.
0408: FE30    	        CP '0'                  ;LESS THAN "ZERO"
040A: FA1D04  	        JP M,CONVERT_HEX_ERROR    ;IF SO, ERROR.
040D: FE3A    	        CP 03AH                 ;LESS THAN OR EQUAL TO "9"
040F: FA1A04  	        JP M,CONVERT_MASK         ;IF SO, CONVERT AND RETURN.
0412: FE41    	        CP 'A'                  ;LESS THAN "A"
0414: FA1D04  	        JP M,CONVERT_HEX_ERROR    ;IF SO, ERROR.
0417: D637    	        SUB 037H                ;MUST BE "A" TO "F", CONVERT.
0419: C9      	        RET
041A:         	CONVERT_MASK:
041A: E60F    	        AND 0FH
041C: C9      	        RET
041D:         	CONVERT_HEX_ERROR:
041D: 3EFF    	        LD A,0FFH               ;IF ERROR, RETURN 0FFH
041F: C9      	        RET
              	;-------------------------------------------------------------------------------
              	        INCLUDE "mon_opt.asm"
              	;-------------------------------------------------------------------------------
              	;COMMANDS
              	;-------------------------------------------------------------------------------
              	; TEST IS A TEST ROUTINE TO SEE IF THE COMMAND RECOGINITION ROUTINES WORK.
              	;  IT SHOULD JUST PRINT SOME VERY BASIC STUFF TO THE SCREEN.
0420:         	TEST:
0420: 21FB08  	        LD HL,TEST_MSG
0423: CD8F03  	        CALL PRINT_STRING
0426: CDDF03  	        CALL PRINT_PROMPT
0429: C9      	        RET
              	
042A:         	CALL_CMD:
              	
042A: 3ADFFF  	        LD A,(BUF_BOT+5)        ;GET THE BYTES, CONVERT TO BINARY ADDRESS
042D: 57      	        LD D,A
042E: 3AE0FF  	        LD A,(BUF_BOT+6)
0431: 5F      	        LD E,A
0432: CDF203  	        CALL ASCIIHEX_TO_BYTE
0435: 67      	        LD H,A                  ;PLACE UPPER BYTE IN H
0436: 3AE1FF  	        LD A,(BUF_BOT+7)
0439: 57      	        LD D,A
043A: 3AE2FF  	        LD A,(BUF_BOT+8)        ;FOR NICE ROUND-NUMBER DUMP.
043D: 5F      	        LD E,A
043E: CDF203  	        CALL ASCIIHEX_TO_BYTE
0441: 6F      	        LD L,A                  ;PLACE LOWER BYTE IN L
0442: 114704  	        LD DE,RETLOC            ;SIMULATE A CALL FUNCTION BY GETTING RETURN ADDRESS
0445: D5      	        PUSH DE                 ;AND PUSHING ONTO THE STACK...
0446: E9      	CLOC:   JP (HL)                 ;GO TO MEMORY ADDRESS TO EXECUTE
0447: CDA602  	RETLOC  CALL BUF_CLR            ;RET IN THE CALLED CODE WILL COME BACK HERE
044A: CDDF03  	        CALL PRINT_PROMPT       ;WHERE WE CLEAR BUFFER AND PRINT COMMAND PROMPT
044D: C9      	        RET                     ;RETURN TO MONITOR MAIN LOOP WITH CLEARED BUFFER AND PROMPT READY TO DO IT AGAIN
              	
044E:         	CLS:
044E: 218006  	        LD HL,CS_MSG
0451: CD8F03  	        CALL PRINT_STRING
0454: CDDF03  	        CALL PRINT_PROMPT
0457: C9      	        RET
              	
0458:         	MON_DIR:
0458: CDBB12  	        CALL directory          ;Directory
045B: CDA602  	        CALL BUF_CLR
045E: CDDF03  	        CALL PRINT_PROMPT
0461: C9      	        RET
              	
0462:         	MON_DEL:
0462: 1120FF  	        LD DE,filename_buffer   ;Pointer to filename buffer
0465: 21DEFF  	        LD HL,BUF_BOT+4         ;Point to start of filename
0468: 7E      	EFNAME: LD A,(HL)               ;GET THE CHAR FROM BUFFER
0469: 0E00    	        LD C,00H                ;CHECK IF END OF LINE
046B: B9      	        CP C
046C: 2806    	        JR Z,DO_ERASE           ;IF END OF WORD TRY TO ERASE
046E: 12      	        LD (DE),A               ;STORE IN FILENAME BUFFER
046F: 13      	        INC DE
0470: 23      	        INC HL
0471: C36804  	        JP EFNAME              ;GET NEXT CHARACTER
0474:         	DO_ERASE:
0474: 3E00    	        LD A,00H
0476: 12      	        LD (DE),A
0477: CD4B14  	        CALL ERASE
047A: CDA602  	        CALL BUF_CLR
047D: CDDF03  	        CALL PRINT_PROMPT
0480: C9      	        RET
              	
0481:         	MON_LOAD:
0481: 1120FF  	        LD DE,filename_buffer   ;Pointer to filename buffer
0484: 21DFFF  	        LD HL,BUF_BOT+5         ;Point to start of filename
0487: 7E      	LFNAME: LD A,(HL)               ;GET THE CHAR FROM BUFFER
0488: 0E00    	        LD C,00H                ;CHECK IF END OF LINE
048A: B9      	        CP C
048B: 2806    	        JR Z,DO_LOAD            ;IF END OF WORD TRY TO LOAD
048D: 12      	        LD (DE),A               ;STORE IN FILENAME BUFFER
048E: 13      	        INC DE
048F: 23      	        INC HL
0490: C38704  	        JP LFNAME              ;GET NEXT CHARACTER
0493:         	DO_LOAD:
0493: 3E00    	        LD A,00H
0495: 12      	        LD (DE),A
0496: CDE013  	        CALL load
0499: CDA602  	        CALL BUF_CLR
049C: CDDF03  	        CALL PRINT_PROMPT
049F: C9      	        RET
              	
04A0:         	MON_SAVE:
04A0: 1120FF  	        LD DE,filename_buffer   ;Pointer to filename buffer
04A3: 21DFFF  	        LD HL,BUF_BOT+5         ;Point to start of filename
04A6: 7E      	SFNAME: LD A,(HL)               ;GET THE CHAR FROM BUFFER
04A7: 0E00    	        LD C,00H                ;CHECK IF END OF LINE
04A9: B9      	        CP C
04AA: 2806    	        JR Z,DO_SAVE            ;IF END OF WORD TRY TO SAVE
04AC: 12      	        LD (DE),A               ;STORE IN FILENAME BUFFER
04AD: 13      	        INC DE
04AE: 23      	        INC HL
04AF: C3A604  	        JP SFNAME              ;GET NEXT CHARACTER
04B2:         	DO_SAVE:
04B2: 3E00    	        LD A,00H
04B4: 12      	        LD (DE),A
04B5: CD3713  	        CALL save
04B8: CDA602  	        CALL BUF_CLR
04BB: CDDF03  	        CALL PRINT_PROMPT
04BE: C9      	        RET
              	
              	;DUMP COMMAND
              	;-------------------------
04BF:         	DUMP:
04BF: 218006  	        LD HL,CS_MSG
04C2: CD8F03  	        CALL PRINT_STRING
04C5: 212109  	        LD HL,DUMP_HEADER_MSG
04C8: CD8F03  	        CALL PRINT_STRING
04CB: 3ADFFF  	        LD A,(BUF_BOT+5)          ;GET THE BYTES, CONVERT TO BINARY ADDRESS
04CE: 57      	        LD D,A
04CF: 3AE0FF  	        LD A,(BUF_BOT+6)
04D2: 5F      	        LD E,A
04D3: CDF203  	        CALL ASCIIHEX_TO_BYTE
04D6: 67      	        LD H,A                  ;PLACE UPPER BYTE IN H
04D7: 3AE1FF  	        LD A,(BUF_BOT+7)
04DA: 57      	        LD D,A
04DB: 3E30    	        LD A,030H                ;FOR NICE ROUND-NUMBER DUMP.
04DD: 5F      	        LD E,A
04DE: CDF203  	        CALL ASCIIHEX_TO_BYTE
04E1: 6F      	        LD L,A                  ;PLACE LOWER BYTE IN L
04E2: 060F    	        LD B,0FH                ;LOAD ROW COUNTER BYTE
04E4: 0E10    	        LD C,010H                ;LOAD COLUMN COUNTER BYTE
04E6: 3E20    	        LD A, SPACE
04E8: CD5C03  	        CALL PRINT_CHAR
04EB: 3E7C    	        LD A,'|'
04ED: CD5C03  	        CALL PRINT_CHAR
04F0: CD8005  	        CALL DUMP_ADDR
04F3: 3E20    	        LD A,SPACE
04F5: CD5C03  	        CALL PRINT_CHAR
04F8: CD5C03  	        CALL PRINT_CHAR
04FB:         	DUMP2:
04FB: 79      	        LD A,C
04FC: FE00    	        CP 00H
04FE: 2810    	        JR Z,DUMP4
0500: 4F      	        LD C,A
0501:         	DUMP3:
0501: 7E      	        LD A,(HL)
0502: CD6603  	        CALL PRINT_HEX
0505: 23      	        INC HL
0506: 79      	        LD A,C
0507: 3D      	        DEC A
0508: 4F      	        LD C,A
0509: 3E20    	        LD A,SPACE
050B: CD5C03  	        CALL PRINT_CHAR
050E: 18EB    	        JR DUMP2
0510:         	DUMP4:
0510: CD3D05  	        CALL DUMP_ASCII
0513: 78      	        LD A,B
0514: FE00    	        CP 00H
0516: 2871    	        JR Z,DUMP_EXIT
0518: 3D      	        DEC A
0519: 47      	        LD B,A
051A: 0E10    	        LD C,010H
051C: 3E0D    	        LD A,CR
051E: CD5C03  	        CALL PRINT_CHAR
0521: 3E0A    	        LD A,LF
0523: CD5C03  	        CALL PRINT_CHAR
0526: 3E20    	        LD A,SPACE
0528: CD5C03  	        CALL PRINT_CHAR
052B: 3E7C    	        LD A,'|'
052D: CD5C03  	        CALL PRINT_CHAR
0530: CD8005  	        CALL DUMP_ADDR
0533: 3E20    	        LD A,SPACE
0535: CD5C03  	        CALL PRINT_CHAR
0538: CD5C03  	        CALL PRINT_CHAR
053B: 18BE    	        JR DUMP2
053D:         	DUMP_ASCII:
053D: F5      	        PUSH AF
053E: C5      	        PUSH BC
053F: D5      	        PUSH DE
0540: E5      	        PUSH HL
0541: 3E20    	        LD A,SPACE
0543: CD5C03  	        CALL PRINT_CHAR
0546: CD5C03  	        CALL PRINT_CHAR
0549: 111000  	        LD DE,0010H
054C: ED52    	        SBC HL,DE
054E: 0610    	        LD B,010H
0550:         	DUMP_ASCII2:
0550: 78      	        LD A,B
0551: FE00    	        CP 00H
0553: 280C    	        JR Z,DUMP_ASCII3
0555: 3D      	        DEC A
0556: 47      	        LD B,A
0557: 7E      	        LD A,(HL)
0558: CD6B05  	        CALL DUMP_ASCII_CONVERT
055B: CD5C03  	        CALL PRINT_CHAR
055E: 23      	        INC HL
055F: 18EF    	        JR DUMP_ASCII2
0561:         	DUMP_ASCII3:
0561: 3E7C    	        LD A,'|'
0563: CD5C03  	        CALL PRINT_CHAR
0566: E1      	        POP HL
0567: D1      	        POP DE
0568: C1      	        POP BC
0569: F1      	        POP AF
056A: C9      	        RET
056B:         	DUMP_ASCII_CONVERT:
056B: FE7F    	        CP 07FH
056D: F27D05  	        JP P,DUMP_ASCII_CONVERT2
0570: FEFF    	        CP 0FFH
0572: 2809    	        JR Z,DUMP_ASCII_CONVERT2
0574: E67F    	        AND 07FH
0576: FE20    	        CP 020H
0578: FA7D05  	        JP M,DUMP_ASCII_CONVERT2
057B: 1802    	        JR DUMP_ASCII_CONVERT3
057D:         	DUMP_ASCII_CONVERT2:
057D: 3E2E    	        LD A,'.'
057F:         	DUMP_ASCII_CONVERT3:
057F: C9      	        RET
0580:         	DUMP_ADDR:
0580: 7C      	        LD A,H
0581: CD6603  	        CALL PRINT_HEX
0584: 7D      	        LD A,L
0585: CD6603  	        CALL PRINT_HEX
0588: C9      	        RET
0589:         	DUMP_EXIT:
0589: 21A30A  	        LD HL,DUMP_FOOTER_MSG
058C: CD8F03  	        CALL PRINT_STRING
058F: CDA602  	        CALL BUF_CLR
0592: 3E0D    	        LD A,CR
0594: CD5C03  	        CALL PRINT_CHAR
0597: 3E0A    	        LD A,LF
0599: CD5C03  	        CALL PRINT_CHAR
059C: CDDF03  	        CALL PRINT_PROMPT
059F: C9      	        RET
05A0:         	DUMP_NEXT_BUF:
05A0: 23      	        INC HL
05A1: 7E      	        LD A,(HL)
05A2: CD5C03  	        CALL PRINT_CHAR
05A5: C9      	        RET
              	;--------------------------
              	
05A6:         	HELP:
05A6: 210C0B  	        LD HL,HELP_MSG
05A9: CD8F03  	        CALL PRINT_STRING
05AC: CDDF03  	        CALL PRINT_PROMPT
05AF: C9      	        RET
              	
05B0:         	IN_CMD:
05B0: 21030B  	        LD HL,IN_MSG
05B3: CD8F03  	        CALL PRINT_STRING
05B6: 3ADDFF  	        LD A,(BUF_BOT+3)          ;GET THE BYTES, CONVERT TO BINARY ADDRESS
05B9: 57      	        LD D,A
05BA: 3ADEFF  	        LD A,(BUF_BOT+4)
05BD: 5F      	        LD E,A
05BE: CDF203  	        CALL ASCIIHEX_TO_BYTE
05C1: 4F      	        LD C,A
05C2: ED78    	        IN A,(C)
05C4: CD6603  	        CALL PRINT_HEX
05C7: 3E68    	        LD A,'h'
05C9: CD5C03  	        CALL PRINT_CHAR
05CC: CDA602  	        CALL BUF_CLR
05CF: CDDF03  	        CALL PRINT_PROMPT
05D2: C9      	        RET
              	
05D3:         	MODMEM:
05D3: 21F10A  	        LD HL,MODMEM_MSG
05D6: CD8F03  	        CALL PRINT_STRING
05D9: 3AE1FF  	        LD A,(BUF_BOT+7)          ;GET THE BYTES, CONVERT TO BINARY ADDRESS
05DC: 57      	        LD D,A
05DD: 3AE2FF  	        LD A,(BUF_BOT+8)
05E0: 5F      	        LD E,A
05E1: CDF203  	        CALL ASCIIHEX_TO_BYTE
05E4: 67      	        LD H,A                  ;PLACE UPPER BYTE IN H
05E5: 3AE3FF  	        LD A,(BUF_BOT+9)
05E8: 57      	        LD D,A
05E9: 3AE4FF  	        LD A,(BUF_BOT+10)        ;FOR NICE ROUND-NUMBER DUMP.
05EC: 5F      	        LD E,A
05ED: CDF203  	        CALL ASCIIHEX_TO_BYTE
05F0: 6F      	        LD L,A                  ;PLACE LOWER BYTE IN L
05F1: CD3B06  	        CALL MODMEM_DUMP_ADDR
05F4: 3E3E    	        LD A,'>'
05F6: CD5C03  	        CALL PRINT_CHAR
05F9:         	MODMEM2:
05F9: CD3406  	        CALL MODMEM_GET
05FC: FE58    	        CP 'X'
05FE: 284D    	        JR Z,MODMEM_EXIT
0600: FE78    	        CP 'x'
0602: 2849    	        JR Z,MODMEM_EXIT
0604: 57      	        LD D,A
0605: CD3406  	        CALL MODMEM_GET
0608: FE58    	        CP 'X'
060A: 2841    	        JR Z,MODMEM_EXIT
060C: FE78    	        CP 'x'
060E: 283D    	        JR Z,MODMEM_EXIT
0610: 5F      	        LD E,A
0611:         	MODMEM3:
0611: CDF203  	        CALL ASCIIHEX_TO_BYTE
0614: FEFE    	        CP 0FEH                 ; Added to fix 'Enter Bug'
0616: CC5406  	        CALL Z,MODMEM_ERROR     ;
0619: FEF6    	        CP 0F6H                 ;
061B: CC5406  	        CALL Z,MODMEM_ERROR     ;
061E: 77      	        LD (HL),A
061F: 23      	        INC HL
0620: 3E0D    	        LD A,CR
0622: CD5C03  	        CALL PRINT_CHAR
0625: 3E0A    	        LD A,LF
0627: CD5C03  	        CALL PRINT_CHAR
062A: CD3B06  	        CALL MODMEM_DUMP_ADDR
062D: 3E3E    	        LD A,'>'
062F: CD5C03  	        CALL PRINT_CHAR
0632: 18C5    	        JR MODMEM2
0634:         	MODMEM_GET:
0634: CDD703  	        CALL GET_KEY
0637: CD5C03  	        CALL PRINT_CHAR         ;ECHO
063A: C9      	        RET
063B:         	MODMEM_DUMP_ADDR:
063B: 7C      	        LD A,H
063C: CD6603  	        CALL PRINT_HEX
063F: 7D      	        LD A,L
0640: CD6603  	        CALL PRINT_HEX
0643: 3E20    	        LD A, " "
0645: CD5C03  	        CALL PRINT_CHAR
0648: 7E      	        LD A,(HL)
0649: CD6603  	        CALL PRINT_HEX
064C: C9      	        RET
064D:         	MODMEM_EXIT:
064D: CDA602  	        CALL BUF_CLR
0650: CDDF03  	        CALL PRINT_PROMPT
0653: C9      	        RET
              	
0654:         	MODMEM_ERROR:                   ;Added to fix 'Enter Bug'
0654: 7E      	        LD A,(HL)               ;
0655: C9      	        RET                     ;
              	
0656:         	OUT_CMD:
0656: 3ADEFF  	        LD A,(BUF_BOT+4)
0659: 57      	        LD D,A
065A: 3ADFFF  	        LD A,(BUF_BOT+5)
065D: 5F      	        LD E,A
065E: CDF203  	        CALL ASCIIHEX_TO_BYTE
0661: 4F      	        LD C,A
0662: 3AE1FF  	        LD A,(BUF_BOT+7)
0665: 57      	        LD D,A
0666: 3AE2FF  	        LD A,(BUF_BOT+8)
0669: 5F      	        LD E,A
066A: CDF203  	        CALL ASCIIHEX_TO_BYTE
066D: ED79    	        OUT (C),A
066F: CDA602  	        CALL BUF_CLR
0672: CDDF03  	        CALL PRINT_PROMPT
0675: C9      	        RET
              	
0676:         	RESTART:
0676: C30000  	        JP BOOT
              	
0679:         	HEXLOAD:
0679: CD820E  	        CALL IH_LOAD
067C: CDDF03  	        CALL PRINT_PROMPT
067F: C9      	        RET
              	
              	        INCLUDE "sys_msg.asm"
              	;-------------------------------------------------------------------------------
              	; MESSAGES
              	;-------------------------------------------------------------------------------
0680:         	CS_MSG:
              	        IF (BOARD = 0)
0680: 1B5B324A	        DB      ESC,"[2J",ESC,"[H",00H
0684: 1B5B4800	
              	        ENDIF
              	        IF (BOARD = 1)
              	        DB      CS,00H
              	        ENDIF
0688:         	SIGNON_MSG:
0688: 0A      	        DB      LF
              	        IF (BOARD = 0)
0689: 4738302D	        DB      "G80-S/USB Computer by Doug Gabbard - 2021",CR,LF,LF
068D: 532F5553	
0691: 4220436F	
0695: 6D707574	
0699: 65722062	
069D: 7920446F	
06A1: 75672047	
06A5: 61626261	
06A9: 7264202D	
06AD: 20323032	
06B1: 310D0A0A	
              	        ENDIF
              	        IF (BOARD = 1)
              	        DB      "GG80-UVK Computer by Doug Gabbard - 2017",CR,LF,LF
              	        ENDIF
06B5:         	VERSION:
06B5: 472D444F	        DB      "G-DOS v1.0",CR,LF
06B9: 53207631	
06BD: 2E300D0A	
06C1: 4D6F6E69	        DB      "Monitor, Tiny Basic and Forth adapted from Doug Gabbard's RetroDepot G80 work",CR,LF
06C5: 746F722C	
06C9: 2054696E	
06CD: 79204261	
06D1: 73696320	
06D5: 616E6420	
06D9: 466F7274	
06DD: 68206164	
06E1: 61707465	
06E5: 64206672	
06E9: 6F6D2044	
06ED: 6F756720	
06F1: 47616262	
06F5: 61726427	
06F9: 73205265	
06FD: 74726F44	
0701: 65706F74	
0705: 20473830	
0709: 20776F72	
070D: 6B0D0A  	
0710: 4D534241	        DB      "MSBASIC v4.7 adpated from Grant Searle's work at http://searle.x10hosts.com",CR,LF
0714: 53494320	
0718: 76342E37	
071C: 20616470	
0720: 61746564	
0724: 2066726F	
0728: 6D204772	
072C: 616E7420	
0730: 53656172	
0734: 6C652773	
0738: 20776F72	
073C: 6B206174	
0740: 20687474	
0744: 703A2F2F	
0748: 73656172	
074C: 6C652E78	
0750: 3130686F	
0754: 7374732E	
0758: 636F6D0D	
075C: 0A      	
075D: 43483337	        DB      "CH376S USB interface adapted from John Squires work at http://8bitstack.co.uk",CR,LF
0761: 36532055	
0765: 53422069	
0769: 6E746572	
076D: 66616365	
0771: 20616461	
0775: 70746564	
0779: 2066726F	
077D: 6D204A6F	
0781: 686E2053	
0785: 71756972	
0789: 65732077	
078D: 6F726B20	
0791: 61742068	
0795: 7474703A	
0799: 2F2F3862	
079D: 69747374	
07A1: 61636B2E	
07A5: 636F2E75	
07A9: 6B0D0A  	
07AC: 444F5320	        DB      "DOS DIR, SAVE, LOAD, DEL, and",CR,LF
07B0: 4449522C	
07B4: 20534156	
07B8: 452C204C	
07BC: 4F41442C	
07C0: 2044454C	
07C4: 2C20616E	
07C8: 640D0A  	
07CB: 4D534241	        DB      "MSBASIC COLOR, SCREEN, INVERSE, NORMAL, FLASH commands by Pat Dziuk",CR,LF,CR,LF
07CF: 53494320	
07D3: 434F4C4F	
07D7: 522C2053	
07DB: 43524545	
07DF: 4E2C2049	
07E3: 4E564552	
07E7: 53452C20	
07EB: 4E4F524D	
07EF: 414C2C20	
07F3: 464C4153	
07F7: 4820636F	
07FB: 6D6D616E	
07FF: 64732062	
0803: 79205061	
0807: 7420447A	
080B: 69756B0D	
080F: 0A0D0A  	
0812: 54797065	        DB      "Type 'HELP' for command list.",CR,LF,LF,00H
0816: 20274845	
081A: 4C502720	
081E: 666F7220	
0822: 636F6D6D	
0826: 616E6420	
082A: 6C697374	
082E: 2E0D0A0A	
0832: 00      	
              	
0833:         	MEMORY_CLR_MSG:
0833: 434C4541	        DB      "CLEARING MEMORY...",00H
0837: 52494E47	
083B: 204D454D	
083F: 4F52592E	
0843: 2E2E00  	
              	
0846:         	STORAGE_CHK_MSG:
0846: 43484543	        DB      "CHECKING FOR STORAGE...",00H
084A: 4B494E47	
084E: 20464F52	
0852: 2053544F	
0856: 52414745	
085A: 2E2E2E00	
              	
085E:         	STORE_NO_FOUND_MSG:
085E: 53544F52	        DB      "STORAGE NOT FOUND.",CR,LF,00H
0862: 41474520	
0866: 4E4F5420	
086A: 464F554E	
086E: 442E0D0A	
0872: 00      	
              	
0873:         	STORAGE_FOUND_MSG:
0873: 53544F52	        DB      "STORAGE FOUND.",CR,LF,00H
0877: 41474520	
087B: 464F554E	
087F: 442E0D0A	
0883: 00      	
              	
0884:         	CMD_NOT_IMPLE_MSG:
0884: 20455252	        DB      " ERROR - COMMAND NOT IMPLEMENTED",CR,LF,00H
0888: 4F52202D	
088C: 20434F4D	
0890: 4D414E44	
0894: 204E4F54	
0898: 20494D50	
089C: 4C454D45	
08A0: 4E544544	
08A4: 0D0A00  	
              	
08A7:         	CMD_ERROR_MSG:
08A7: 0D0A2020	        DB      CR,LF,"  ERROR - NOT RECOGNIZED ",CR,LF,LF,00H
08AB: 4552524F	
08AF: 52202D20	
08B3: 4E4F5420	
08B7: 5245434F	
08BB: 474E495A	
08BF: 4544200D	
08C3: 0A0A00  	
              	
08C6:         	OVERFLOW_ERROR_MSG:
08C6: 0D0A2020	        DB      CR,LF,"  ERROR - BUFFER OVERFLOW ",CR,LF,00H
08CA: 4552524F	
08CE: 52202D20	
08D2: 42554646	
08D6: 4552204F	
08DA: 56455246	
08DE: 4C4F5720	
08E2: 0D0A00  	
              	
08E5:         	LOADING_MSG:
08E5: 0D0A    	        DB      CR,LF
08E7: 204C4F41	        DB      " LOADING...",00H
08EB: 44494E47	
08EF: 2E2E2E00	
              	
08F3:         	DONE_MSG:
08F3: 444F4E45	        DB      "DONE.",CR,LF,00H
08F7: 2E0D0A00	
              	
08FB:         	TEST_MSG:
08FB: 0D0A2043	        DB      CR,LF," COMMAND RECOGNITION TEST WORKED!",CR,LF,00H
08FF: 4F4D4D41	
0903: 4E442052	
0907: 45434F47	
090B: 4E495449	
090F: 4F4E2054	
0913: 45535420	
0917: 574F524B	
091B: 4544210D	
091F: 0A00    	
0921:         	DUMP_HEADER_MSG:
0921: 20205F5F	        DB      "  ________________________________________________________________________ ",CR,LF
0925: 5F5F5F5F	
0929: 5F5F5F5F	
092D: 5F5F5F5F	
0931: 5F5F5F5F	
0935: 5F5F5F5F	
0939: 5F5F5F5F	
093D: 5F5F5F5F	
0941: 5F5F5F5F	
0945: 5F5F5F5F	
0949: 5F5F5F5F	
094D: 5F5F5F5F	
0951: 5F5F5F5F	
0955: 5F5F5F5F	
0959: 5F5F5F5F	
095D: 5F5F5F5F	
0961: 5F5F5F5F	
0965: 5F5F5F5F	
0969: 5F5F200D	
096D: 0A      	
096E: 207C2020	        DB      " |                                DUMPER                                  |",CR,LF
0972: 20202020	
0976: 20202020	
097A: 20202020	
097E: 20202020	
0982: 20202020	
0986: 20202020	
098A: 20202020	
098E: 20204455	
0992: 4D504552	
0996: 20202020	
099A: 20202020	
099E: 20202020	
09A2: 20202020	
09A6: 20202020	
09AA: 20202020	
09AE: 20202020	
09B2: 20202020	
09B6: 20207C0D	
09BA: 0A      	
09BB: 207C2D2D	        DB      " |------------------------------------------------------------------------|",CR,LF
09BF: 2D2D2D2D	
09C3: 2D2D2D2D	
09C7: 2D2D2D2D	
09CB: 2D2D2D2D	
09CF: 2D2D2D2D	
09D3: 2D2D2D2D	
09D7: 2D2D2D2D	
09DB: 2D2D2D2D	
09DF: 2D2D2D2D	
09E3: 2D2D2D2D	
09E7: 2D2D2D2D	
09EB: 2D2D2D2D	
09EF: 2D2D2D2D	
09F3: 2D2D2D2D	
09F7: 2D2D2D2D	
09FB: 2D2D2D2D	
09FF: 2D2D2D2D	
0A03: 2D2D7C0D	
0A07: 0A      	
0A08: 207C2020	        DB      " |       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F"
0A0C: 20202020	
0A10: 20302020	
0A14: 31202032	
0A18: 20203320	
0A1C: 20342020	
0A20: 35202036	
0A24: 20203720	
0A28: 20382020	
0A2C: 39202041	
0A30: 20204220	
0A34: 20432020	
0A38: 44202045	
0A3C: 202046  	
0A3F: 20202020	        DB      "         ASCII     |",CR,LF
0A43: 20202020	
0A47: 20415343	
0A4B: 49492020	
0A4F: 2020207C	
0A53: 0D0A    	
0A55: 207C2D2D	        DB      " |------------------------------------------------------------------------|",CR,LF,00H
0A59: 2D2D2D2D	
0A5D: 2D2D2D2D	
0A61: 2D2D2D2D	
0A65: 2D2D2D2D	
0A69: 2D2D2D2D	
0A6D: 2D2D2D2D	
0A71: 2D2D2D2D	
0A75: 2D2D2D2D	
0A79: 2D2D2D2D	
0A7D: 2D2D2D2D	
0A81: 2D2D2D2D	
0A85: 2D2D2D2D	
0A89: 2D2D2D2D	
0A8D: 2D2D2D2D	
0A91: 2D2D2D2D	
0A95: 2D2D2D2D	
0A99: 2D2D2D2D	
0A9D: 2D2D7C0D	
0AA1: 0A00    	
0AA3:         	DUMP_FOOTER_MSG:
0AA3: 0D0A207C	        DB      CR,LF," |________________________________________________________________________|",00H
0AA7: 5F5F5F5F	
0AAB: 5F5F5F5F	
0AAF: 5F5F5F5F	
0AB3: 5F5F5F5F	
0AB7: 5F5F5F5F	
0ABB: 5F5F5F5F	
0ABF: 5F5F5F5F	
0AC3: 5F5F5F5F	
0AC7: 5F5F5F5F	
0ACB: 5F5F5F5F	
0ACF: 5F5F5F5F	
0AD3: 5F5F5F5F	
0AD7: 5F5F5F5F	
0ADB: 5F5F5F5F	
0ADF: 5F5F5F5F	
0AE3: 5F5F5F5F	
0AE7: 5F5F5F5F	
0AEB: 5F5F5F5F	
0AEF: 7C00    	
0AF1:         	MODMEM_MSG:
0AF1: 0D0A2020	        DB      CR,LF,"  'X' TO EXIT",CR,LF,00H
0AF5: 27582720	
0AF9: 544F2045	
0AFD: 5849540D	
0B01: 0A00    	
0B03:         	IN_MSG:
0B03: 0D0A2050	        DB      CR,LF," PORT=",00H
0B07: 4F52543D	
0B0B: 00      	
0B0C:         	HELP_MSG:
0B0C: 0D0A2047	        DB      CR,LF," G80 COMMANDS:",CR,LF,LF
0B10: 38302043	
0B14: 4F4D4D41	
0B18: 4E44533A	
0B1C: 0D0A0A  	
0B1F: 204C414E	        DB      " LANGUAGES:",CR,LF
0B23: 47554147	
0B27: 45533A0D	
0B2B: 0A      	
              	        IF (BASIC = 1)
              	        DB      TAB,"BASIC - TINY BASIC v2.5g",CR,LF
              	        ENDIF
              	
              	        IF (MS_BASIC = 1)
0B2C: 09424153	        DB      TAB,"BASIC - MSBASIC v4.7b",CR,LF
0B30: 4943202D	
0B34: 204D5342	
0B38: 41534943	
0B3C: 2076342E	
0B40: 37620D0A	
              	        ENDIF
              	
              	        IF (CFORTH = 1)
              	        DB      TAB,"FORTH - CamelForth v1.2a",CR,LF,LF
              	        ENDIF
0B44: 204D4F4E	        DB      " MONITOR:",CR,LF
0B48: 49544F52	
0B4C: 3A0D0A  	
0B4F: 0943414C	        DB      TAB,"CALL XXXX - RUN CODE AT LOCATION XXXX",CR,LF
0B53: 4C205858	
0B57: 5858202D	
0B5B: 2052554E	
0B5F: 20434F44	
0B63: 45204154	
0B67: 204C4F43	
0B6B: 4154494F	
0B6F: 4E205858	
0B73: 58580D0A	
0B77: 09434C53	        DB      TAB,"CLS - CLEAR THE TERMINAL SCREEN",CR,LF
0B7B: 202D2043	
0B7F: 4C454152	
0B83: 20544845	
0B87: 20544552	
0B8B: 4D494E41	
0B8F: 4C205343	
0B93: 5245454E	
0B97: 0D0A    	
0B99: 0944454C	        DB      TAB,"DEL - DELETE <FILENAME>",CR,LF
0B9D: 202D2044	
0BA1: 454C4554	
0BA5: 45203C46	
0BA9: 494C454E	
0BAD: 414D453E	
0BB1: 0D0A    	
0BB3: 09444952	        DB      TAB,"DIR - DIRECTORY OF USB MEMORY STICK",CR,LF
0BB7: 202D2044	
0BBB: 49524543	
0BBF: 544F5259	
0BC3: 204F4620	
0BC7: 55534220	
0BCB: 4D454D4F	
0BCF: 52592053	
0BD3: 5449434B	
0BD7: 0D0A    	
0BD9: 0944554D	        DB      TAB,"DUMP XXXX - DUMP 256 BYTES OF MEMORY",CR,LF
0BDD: 50205858	
0BE1: 5858202D	
0BE5: 2044554D	
0BE9: 50203235	
0BED: 36204259	
0BF1: 54455320	
0BF5: 4F46204D	
0BF9: 454D4F52	
0BFD: 590D0A  	
0C00: 0948454C	        DB      TAB,"HELP - THIS SCREEN",CR,LF
0C04: 50202D20	
0C08: 54484953	
0C0C: 20534352	
0C10: 45454E0D	
0C14: 0A      	
0C15: 09484558	        DB      TAB,"HEXLOAD - LOAD INTEL HEX FILES OVER SERIAL",CR,LF
0C19: 4C4F4144	
0C1D: 202D204C	
0C21: 4F414420	
0C25: 494E5445	
0C29: 4C204845	
0C2D: 58204649	
0C31: 4C455320	
0C35: 4F564552	
0C39: 20534552	
0C3D: 49414C0D	
0C41: 0A      	
0C42: 09494E20	        DB      TAB,"IN XX - READ INPUT FROM PORT XX",CR,LF
0C46: 5858202D	
0C4A: 20524541	
0C4E: 4420494E	
0C52: 50555420	
0C56: 46524F4D	
0C5A: 20504F52	
0C5E: 54205858	
0C62: 0D0A    	
0C64: 094C4F41	        DB      TAB,"LOAD - LOAD <FILENAME> STARTING AT $8000",CR,LF
0C68: 44202D20	
0C6C: 4C4F4144	
0C70: 203C4649	
0C74: 4C454E41	
0C78: 4D453E20	
0C7C: 53544152	
0C80: 54494E47	
0C84: 20415420	
0C88: 24383030	
0C8C: 300D0A  	
0C8F: 094D4F44	        DB      TAB,"MODMEM XXXX - MODIFY MEMORY STARTING AT XXXX",CR,LF
0C93: 4D454D20	
0C97: 58585858	
0C9B: 202D204D	
0C9F: 4F444946	
0CA3: 59204D45	
0CA7: 4D4F5259	
0CAB: 20535441	
0CAF: 5254494E	
0CB3: 47204154	
0CB7: 20585858	
0CBB: 580D0A  	
0CBE: 094F5554	        DB      TAB,"OUT XX HH - WRITE HH TO PORT XX",CR,LF
0CC2: 20585820	
0CC6: 4848202D	
0CCA: 20575249	
0CCE: 54452048	
0CD2: 4820544F	
0CD6: 20504F52	
0CDA: 54205858	
0CDE: 0D0A    	
0CE0: 09534156	        DB      TAB,"SAVE - SAVE <FILENAME> SAVES FROM $8000-$FDFF",CR,LF
0CE4: 45202D20	
0CE8: 53415645	
0CEC: 203C4649	
0CF0: 4C454E41	
0CF4: 4D453E20	
0CF8: 53415645	
0CFC: 53204652	
0D00: 4F4D2024	
0D04: 38303030	
0D08: 2D244644	
0D0C: 46460D0A	
0D10: 0952414D	        DB      TAB,"RAMCLR - CLEAR USER AREA OF MEMORY",CR,LF
0D14: 434C5220	
0D18: 2D20434C	
0D1C: 45415220	
0D20: 55534552	
0D24: 20415245	
0D28: 41204F46	
0D2C: 204D454D	
0D30: 4F52590D	
0D34: 0A      	
0D35: 09524553	        DB      TAB,"RESTART - SOFT RESTART",CR,LF,LF
0D39: 54415254	
0D3D: 202D2053	
0D41: 4F465420	
0D45: 52455354	
0D49: 4152540D	
0D4D: 0A0A    	
0D4F:         	HELP_PORTS_MSG:
0D4F: 20504F52	        DB      " PORTS:",CR,LF
0D53: 54533A0D	
0D57: 0A      	
0D58: 0953494F	        DB      TAB,"SIO (00-03H)",CR,LF
0D5C: 20283030	
0D60: 2D303348	
0D64: 290D0A  	
              	        IF (BOARD = 0)
0D67: 0950494F	        DB      TAB,"PIO (80-83H)",CR,LF
0D6B: 20283830	
0D6F: 2D383348	
0D73: 290D0A  	
              	        ENDIF
0D76: 00      	        DB      00H
              	
              	;-------------------------------------------------------------------------------
              	
              	        INCLUDE "cmd_recogn.asm"
              	;-------------------------------------------------------------------------------
              	;COMMAND RECOGNITION
              	;-------------------------------------------------------------------------------
0D77:         	IN_CMD_CHK:
0D77: 21D9FF  	        LD HL,BUF_BOT-1         ;BOTTOM OF BUFFER-1
0D7A: 11210E  	        LD DE,CMD_TABLE-1
0D7D:         	IN_CMD_CHKL:
0D7D: 23      	        INC HL
0D7E: 13      	        INC DE
              	
0D7F: 7E      	        LD A,(HL)               ;GET THE CHAR FROM BUFFER
0D80: EB      	        EX DE,HL                ;EXCHANGE THE REGISTERS
0D81: 47      	        LD B,A                  ;STORE THE VALUE
0D82: 7E      	        LD A,(HL)               ;GET THE CHAR FROM THE TABLE
0D83: EB      	        EX DE,HL                ;RE-EXCHANGE THE REGISTERS
              	
0D84: 0E00    	        LD C,00H                ;CHECK IF END OF WORD
0D86: B9      	        CP C
0D87: 2806    	        JR Z,IN_CMD_TOKEN       ;IF END OF WORD AND PASS, GET TOKEN
              	
0D89: 90      	        SUB B
0D8A: 28F1    	        JR Z,IN_CMD_CHKL        ;IF MATCH, GET NEXT CHAR
0D8C: C30E0E  	        JP IN_CMD_NEXT_WORD     ;IF NOT, TRY NEXT WORD
              	
              	
              	
0D8F:         	IN_CMD_TOKEN:                   ;FIND THE TOKEN VALUE
              	
0D8F: 7E      	        LD A,(HL)               ;FIRST, MAKE SURE THAT IT'S THE END OF
0D90: 0E20    	        LD C,020H               ;WORD IN THE BUFFER, BY CHECKING FOR <SPACE>
0D92: 91      	        SUB C
0D93: C2780E  	        JP NZ,CMD_ERROR         ;IF IT'S NOT, JUMP TO THE ERROR ROUTINE.
              	
0D96: 21D9FF  	        LD HL,BUF_BOT-1         ;LOAD BUFFER ADDRESS AND START VALUE
0D99: 0600    	        LD B,00H
0D9B:         	IN_CMD_TOKENL:                  ;HEX - 0023H
0D9B: 23      	        INC HL
0D9C: 7E      	        LD A,(HL)               ;GET CHARACTER FROM BUFFER
0D9D: 0E20    	        LD C,020H               ;CHECK IF SPACE
0D9F: B9      	        CP C
0DA0: 2804    	        JR Z,IN_CMD_GO          ;GO TO COMMAND IF SO
0DA2: 80      	        ADD A,B
0DA3: 47      	        LD B,A                  ;ADD AND STORE VALUE
0DA4: 18F5    	        JR IN_CMD_TOKENL        ;GET NEXT CHARACTER
              	
              	;----------------
              	;CMD JUMP ROUTINE
              	;----------------
0DA6:         	IN_CMD_GO:                      ;FIND MATCHING TOKEN AND GO  -  002E
0DA6: 78      	        LD A,B                  ;RESTORE THE TOKEN VALUE
0DA7: 0E1C    	        LD C,TOK_CALL
0DA9: B9      	        CP C
0DAA: CA2A04  	        JP Z,CALL_CMD            ;RUN CALL ROUTINE
0DAD: 0EE2    	        LD C,TOK_CLS
0DAF: B9      	        CP C
0DB0: CA4E04  	        JP Z,CLS                ;CLEAR SCREEN ROUTINE
0DB3: 0E40    	        LD C,TOK_TEST           ;NOW CHECK WHICH COMMAND AND GOTO
0DB5: B9      	        CP C
0DB6: CA2004  	        JP Z,TEST               ;TEST ROUTINE
0DB9: 0E36    	        LD C,TOK_DUMP
0DBB: B9      	        CP C
0DBC: CABF04  	        JP Z,DUMP               ;MEMORY DUMP ROUTINE
0DBF: 0E29    	        LD C,TOK_HELP
0DC1: B9      	        CP C
0DC2: CAA605  	        JP Z,HELP               ;HELP ROUTINE
0DC5: 0E05    	        LD C,TOK_HEXLOAD
0DC7: B9      	        CP C
0DC8: CA7906  	        JP Z,HEXLOAD
0DCB: 0E97    	        LD C,TOK_IN
0DCD: B9      	        CP C
0DCE: CAB005  	        JP Z,IN_CMD             ;IN ROUTINE
0DD1: 0EBF    	        LD C,TOK_MODMEM
0DD3: B9      	        CP C
0DD4: CAD305  	        JP Z,MODMEM             ;MEMORY MODIFY ROUTINE
0DD7: 0EF8    	        LD C,TOK_OUT
0DD9: B9      	        CP C
0DDA: CA5606  	        JP Z,OUT_CMD            ;OUT ROUTINE
0DDD: 0EC1    	        LD C,TOK_RAMCLR
0DDF: B9      	        CP C
0DE0: CA6B02  	        JP Z,RAM_CLR            ;RAMCLR ROUTINE
0DE3: 0E25    	        LD C,TOK_RESTART
0DE5: B9      	        CP C
0DE6: CA7606  	        JP Z,RESTART            ;RESTART MONITOR
0DE9: 0EDF    	        LD C,TOK_DIR
0DEB: B9      	        CP C
0DEC: CA5804  	        JP Z,MON_DIR            ;DISK DIRECTORY
0DEF: 0ED5    	        LD C,TOK_DEL
0DF1: B9      	        CP C
0DF2: CA6204  	        JP Z,MON_DEL            ;DISK DELETE FILE
0DF5: 0E20    	        LD C,TOK_LOAD
0DF7: B9      	        CP C
0DF8: CA8104  	        JP Z,MON_LOAD           ;DISK LOAD FILE STARTING AT 8000
0DFB: 0E2F    	        LD C,TOK_SAVE
0DFD: B9      	        CP C
0DFE: CAA004  	        JP Z,MON_SAVE           ;DISK SAVE FROM 8000 TO FDFF
              	
              	        IF (BASIC = 1)
              	        LD C,TOK_BASIC          ;TEST FOR BASIC
              	        CP C
              	        JP Z,START              ;START BASIC  (tiny basic)
              	        ENDIF
              	
              	        IF (MS_BASIC= 1)
0E01: 0E62    	        LD C,TOK_BASIC          ;TEST FOR BASIC
0E03: B9      	        CP C
0E04: CA3C00  	        JP Z, BASSETUP
              	        ENDIF
              	
              	        IF (CFORTH = 1)
              	        LD C,TOK_FORTH          ;TEST FOR FORTH
              	        CP C
              	        JP Z,FORTH              ;START CamelForth
              	        ENDIF
              	
0E07: CDA602  	        CALL BUF_CLR
0E0A: CDDF03  	        CALL PRINT_PROMPT
              	
0E0D: C9      	        RET
              	        ;JP BOOT                 ;RESET IF CRASH
              	;----------------
              	
              	
0E0E:         	IN_CMD_NEXT_WORD:               ;GRAB NEXT WORD
0E0E: 13      	        INC DE
              	
              	        ;NEED SOMETHING TO SEE IF TOP OF COMMAND TABLE HERE.
0E0F: 21770E  	        LD HL,CMD_TABLE_END     ;SHOULD BE TOP OF CMD_TABLE
0E12: 7D      	        LD A,L                  ;THE ADDRESS TO TEST FOR
0E13: BB      	        CP E                    ;COMPARE THE ADDRESS
0E14: 2862    	        JR Z,CMD_ERROR
              	
              	
0E16: 1A      	        LD A,(DE)               ;INCREMENT AND CHECK UNTIL 00H IS FOUND
0E17: 0E00    	        LD C,00H
0E19: 91      	        SUB C
0E1A: 20F2    	        JR NZ,IN_CMD_NEXT_WORD  ;TRY AGAIN IF NOT FOUND
0E1C: 21D9FF  	        LD HL,BUF_BOT-1         ;RESET BUFFER AND CHECK THAT WORD.
0E1F: C37D0D  	        JP IN_CMD_CHKL
              	
0E22:         	CMD_TABLE:                      ;COMMAND WORD LIST
0E22: 43414C4C	        DB      "CALL",00H
0E26: 00      	
0E27: 434C5300	        DB      "CLS",00H
0E2B: 44454C00	        DB      "DEL",00H
0E2F: 44495200	        DB      "DIR",00H
0E33: 44554D50	        DB      "DUMP",00H
0E37: 00      	
0E38: 494E00  	        DB      "IN",00H
0E3B: 48454C50	        DB      "HELP",00H
0E3F: 00      	
0E40: 4845584C	        DB      "HEXLOAD",00H
0E44: 4F414400	
0E48: 4C4F4144	        DB      "LOAD",00H
0E4C: 00      	
0E4D: 4D4F444D	        DB      "MODMEM",00H
0E51: 454D00  	
0E54: 4F555400	        DB      "OUT",00H
0E58: 52414D43	        DB      "RAMCLR",00H
0E5C: 4C5200  	
0E5F: 52455354	        DB      "RESTART",00H
0E63: 41525400	
0E67: 53415645	        DB      "SAVE",00H
0E6B: 00      	
0E6C: 54455354	        DB      "TEST",00H
0E70: 00      	
              	
              	        IF (BASIC = 1)
              	        DB      "BASIC",00H
              	        ENDIF
              	        IF (MS_BASIC = 1)
0E71: 42415349	        DB      "BASIC",00H
0E75: 4300    	
              	        ENDIF
              	        IF (CFORTH = 1)
              	        DB      "FORTH",00H
              	        ENDIF
0E77:         	CMD_TABLE_END:
0E77: 00      	        DB      00H
0E78:         	CMD_ERROR:
0E78: 21A708  	        LD HL,CMD_ERROR_MSG
0E7B: CD8F03  	        CALL PRINT_STRING
0E7E: CDDF03  	        CALL PRINT_PROMPT
0E81: C9      	        RET
              	
              	;COMMAND TOKEN VALUES IS A SUM OF THE CHARACTER ASCII CODES FOR ALL CHARACTERS
              	
001C:         	TOK_CALL        EQU     01CH
00E2:         	TOK_CLS         EQU     0E2H
0036:         	TOK_DUMP        EQU     036H
0097:         	TOK_IN          EQU     097H
0029:         	TOK_HELP        EQU     029H
0005:         	TOK_HEXLOAD     EQU     05H
00BF:         	TOK_MODMEM      EQU     0BFH
00F8:         	TOK_OUT         EQU     0F8H
00C1:         	TOK_RAMCLR      EQU     0C1H
0025:         	TOK_RESTART     EQU     025H
0040:         	TOK_TEST        EQU     040H
00DF:         	TOK_DIR         EQU     0DFH
00D5:         	TOK_DEL         EQU     0D5H
002F:         	TOK_SAVE        EQU     02FH
0020:         	TOK_LOAD        EQU     020H
              	
              	        IF (BASIC = 1)
              	TOK_BASIC       EQU     062H
              	        ENDIF
              	        IF (MS_BASIC = 1)
0062:         	TOK_BASIC       EQU     062H
              	        ENDIF
              	        IF (CFORTH = 1)
              	TOK_FORTH       EQU     083H
              	        ENDIF
              	;-------------------------------------------------------------------------------
              	
              	        INCLUDE "hex_load.asm"
              	;-------------------------------------------------------------------------------
              	;///////////////////////////////////////////////////////////////////////////////
              	;-------------------------------------------------------------------------------
              	; THIS IS A ROUTINE FOR LOADING AN INTEL HEX FILE INTO MEMORY FROM SERIAL.
              	;   THE SOURCE FROM THIS WAS TAKEN FROM: http://www.vaxman.de/projects/tiny_z80/
              	;
              	; According to Bernd Ulmann, the author of the site listed above, he took this
              	; routine from Andrew Lynch's boot loader program.  While aware of who Andrew
              	; is, I have not had any conversations with him concerning this program, and
              	; I have not laid eyes on the code.  Bernd has modified this code to work with
              	; his own computer, a z80 machine with IDE support. I have further modified it
              	; to work with my own system, although those modifications were minor.  I did
              	; include several of Bernd's system calls, as they were different enough in
              	; nature from my own that it would wreak havoc, and cause me to either rewrite
              	; essentially the same code, or to modify the flow of the rest of my monitor
              	; program in order to make it work. However, I also recreated several of his
              	; calls to better suit my needs, but have credit him by placing them within
              	; this block of code.  To see the original source, please visit the site listed
              	; above.
              	;
              	;
              	;   The end of Bernd's and Andrews code will be clearly noted in my source.
              	;-------------------------------------------------------------------------------
              	;
              	
              	
0E82:         	IH_LOAD:
0E82: F5      	        PUSH AF
0E83: D5      	        PUSH DE
0E84: E5      	        PUSH HL
0E85: 21050F  	        LD HL,IH_LOAD_MSG_1
0E88: CD8F03  	        CALL PRINT_STRING
0E8B:         	IH_LOAD_LOOP:
0E8B: CDD703  	        CALL GET_KEY                    ;GET A CHARACTER
0E8E: FE0D    	        CP CR                           ;DONT CARE ABOUT CR
0E90: 28F9    	        JR Z,IH_LOAD_LOOP
0E92: FE0A    	        CP LF                           ;...OR LF
0E94: 28F5    	        JR Z,IH_LOAD_LOOP
0E96: FE20    	        CP SPACE                        ;...OR A SPACE
0E98: 28F1    	        JR Z,IH_LOAD_LOOP
0E9A: CD560F  	        CALL TO_UPPER                   ;CONVERT TO UPPER CASE
0E9D: CD5C03  	        CALL PRINT_CHAR                 ;ECHO CHARACTER
0EA0: FE3A    	        CP ':'                          ; IS IT A COLON?
0EA2: 204E    	        JR NZ,IH_LOAD_ERROR
0EA4: CD5F0F  	        CALL GET_BYTE                   ;GET RECORD LENGTH INTO A
0EA7: 57      	        LD D,A                          ;LENGTH IS NOW IN D
0EA8: 1E00    	        LD E,00H                        ;CLEAR CHECKSUM
0EAA: CDFF0E  	        CALL IH_LOAD_CHK                ;COMPUTE CHECKSUM
0EAD: CDD10F  	        CALL GET_WORD                   ;GET LOAD ADDRESS INTO HL
0EB0: 7C      	        LD A,H                          ;UPDATE CHECKSUM BY THIS ADDRESS
0EB1: CDFF0E  	        CALL IH_LOAD_CHK
0EB4: 7D      	        LD A,L
0EB5: CDFF0E  	        CALL IH_LOAD_CHK
              	
0EB8: CD5F0F  	        CALL GET_BYTE                   ;GET THE RECORD TYPE
0EBB: CDFF0E  	        CALL IH_LOAD_CHK                ;UPDATE CHECKSUM
0EBE: FE01    	        CP 01H                          ;HAVE WE READED EOF MARKER?
0EC0: 2012    	        JR NZ,IH_LOAD_DATA              ;NO - GET SOME DATA
0EC2: CD5F0F  	        CALL GET_BYTE                   ;YES - EOF,READ CHECKSUM DATA
0EC5: CDFF0E  	        CALL IH_LOAD_CHK                ;UPDATE OUR OWN CHECKSUM
0EC8: 7B      	        LD A,E
0EC9: A7      	        AND A                           ;IS OUR CHECKSUM ZERO?
0ECA: 282C    	        JR Z,IH_LOAD_EXIT               ;YES - EXIT THIS ROUTINE
              	
0ECC:         	IH_LOAD_CHK_ERR:
0ECC: 21250F  	        LD HL,IH_LOAD_MSG_3
0ECF: CD8F03  	        CALL PRINT_STRING               ;NO - PRINT AN ERROR MESSAGE
0ED2: 1824    	        JR IH_LOAD_EXIT                 ; AND EXIT
              	
0ED4:         	IH_LOAD_DATA:
0ED4: 7A      	        LD A,D                          ;RECORD LENGTH IS NOW IN A
0ED5: A7      	        AND A                           ;DID WE PROCESS ALL BYTES?
0ED6: 280B    	        JR Z,IH_LOAD_EOL                ;YES - PROCESS END OF LINE
0ED8: CD5F0F  	        CALL GET_BYTE                   ;READ TWO HEX DIGITS INTO A
0EDB: CDFF0E  	        CALL IH_LOAD_CHK                ;UPDATE CHECKSUM
0EDE: 77      	        LD (HL),A                       ;STORE BYTE INTO MEMORY
0EDF: 23      	        INC HL                          ;INCREMENT POINTER
0EE0: 15      	        DEC D                           ;DECREMENT REMAINING RECORD LENGTH
0EE1: 18F1    	        JR IH_LOAD_DATA                 ;GET NEXT BYTE
              	
0EE3:         	IH_LOAD_EOL:
0EE3: CD5F0F  	        CALL GET_BYTE                   ;READ THE LAST BYTE IN THE LINE
0EE6: CDFF0E  	        CALL IH_LOAD_CHK                ;UPDATE CHECKSUM
0EE9: 7B      	        LD A,E
0EEA: A7      	        AND A                           ;IS THE CHECKSUM ZERO?
0EEB: 20DF    	        JR NZ,IH_LOAD_CHK_ERR
0EED: CD4D0F  	        CALL CRLF
0EF0: 1899    	        JR IH_LOAD_LOOP                 ;YES - READ NEXT LINE
              	
0EF2:         	IH_LOAD_ERROR:
0EF2: 21160F  	        LD HL,IH_LOAD_MSG_2
0EF5: CD8F03  	        CALL PRINT_STRING               ;PRINT ERROR MESSAGE
              	
0EF8:         	IH_LOAD_EXIT:
0EF8: CD4D0F  	        CALL CRLF
0EFB: E1      	        POP HL                          ;RESTORE REGISTERS
0EFC: D1      	        POP DE
0EFD: F1      	        POP AF
0EFE: C9      	        RET                             ;RETURN FROM HEX LOADER
              	
0EFF:         	IH_LOAD_CHK:
0EFF: 4F      	        LD C,A                          ;ALL IN ALL COMPUTE E=E-A
0F00: 7B      	        LD A,E
0F01: 91      	        SUB C
0F02: 5F      	        LD E,A
0F03: 79      	        LD A,C
0F04: C9      	        RET
              	
0F05:         	IH_LOAD_MSG_1:
0F05: 494E5445	        DB "INTEL HEX LOAD: ",00H
0F09: 4C204845	
0F0D: 58204C4F	
0F11: 41443A20	
0F15: 00      	
0F16:         	IH_LOAD_MSG_2:
0F16: 2053594E	        DB " SYNTAX ERROR!",00H
0F1A: 54415820	
0F1E: 4552524F	
0F22: 522100  	
0F25:         	IH_LOAD_MSG_3:
0F25: 20434845	        DB " CHECKSUM ERROR!",00H
0F29: 434B5355	
0F2D: 4D204552	
0F31: 524F5221	
0F35: 00      	
0F36:         	IH_LOAD_MSG_CRLF:
0F36: 0D0A00  	        DB CR,LF,00H
0F39:         	IH_LOAD_MSG_OUTSPC:
0F39: 0D0A0A4F	        DB CR,LF,LF,"OUT OF MEMORY.",CR,LF,00H
0F3D: 5554204F	
0F41: 46204D45	
0F45: 4D4F5259	
0F49: 2E0D0A00	
              	
              	;----------------
              	; CRLF
              	; SENDS A CR/LF TO THE SERIAL LINE
              	;-----------------
0F4D:         	CRLF:
0F4D: E5      	        PUSH HL                 ;SAVE THE POINTER
0F4E: 21360F  	        LD HL,IH_LOAD_MSG_CRLF  ;LOAD NEW POINTER
0F51: CD8F03  	        CALL PRINT_STRING       ;PRINT IT
0F54: E1      	        POP HL                  ;RESTORE OLD POINTER
0F55: C9      	        RET
              	;----------------
              	;TO_UPPER
              	;CONVERTS ASCII CODE IN REG-A INTO UPPER CASE, RETURNS IN REG-A
              	;----------------
0F56:         	TO_UPPER:
0F56: FE61    	        CP 61H
0F58: D8      	        RET C
0F59: FE7B    	        CP 7BH
0F5B: D0      	        RET NC
0F5C: E65F    	        AND 5FH
0F5E: C9      	        RET
              	;---------------
              	; GET_BYTE
              	; Get a byte in hexadecimal notation. The result is returned in A. Since
              	; the routine get_nibble is used only valid characters are accepted - the
              	; input routine only accepts characters 0-9a-f.
              	;---------------
0F5F:         	GET_BYTE:
0F5F: C5      	        PUSH BC                         ;SAVE THE REGISTERS
0F60: CD720F  	        CALL GET_NIBBLE                 ;GET UPPER NIBBLE
0F63: CB07    	        RLC A
0F65: CB07    	        RLC A
0F67: CB07    	        RLC A                           ;ROTATE RIGHT
0F69: CB07    	        RLC A
0F6B: 47      	        LD B,A                          ;SAVE UPPER NIBBLE
0F6C: CD720F  	        CALL GET_NIBBLE                 ;GET LOWER NIBBLE
0F6F: B0      	        OR B                            ;COMBINE
0F70: C1      	        POP BC                          ;RESTORE OLD REGISTERS
0F71: C9      	        RET
              	;----------------
              	; GET_NIBBLE
              	; Get a hexadecimal digit from the serial line. This routine blocks until
              	; a valid character (0-9a-f) has been entered. A valid digit will be echoed
              	; to the serial line interface. The lower 4 bits of A contain the value of
              	; that particular digit.
              	;----------------
0F72:         	GET_NIBBLE:
0F72: CDD703  	        CALL GET_KEY                    ;READ A CHARACTER
0F75: CD560F  	        CALL TO_UPPER                   ;CONVERT TO UPPER CASE
0F78: CD840F  	        CALL IS_HEX                     ;WAS IT A HEX DIGIT
0F7B: 30F5    	        JR NC,GET_NIBBLE                ;NO, GET ANOTHER CHARACTER
0F7D: CD980F  	        CALL NIBBLE2VAL                 ;CONVERT NIBBLE TO VALUE
0F80: CDA30F  	        CALL PRINT_NIBBLE
0F83: C9      	        RET
              	;-----------------
              	; IS_HEX
              	; is_hex checks a character stored in A for being a valid hexadecimal digit.
              	; A valid hexadecimal digit is denoted by a set C flag.
              	;-----------------
0F84:         	IS_HEX:
0F84: FE47    	        CP 47H                          ;GREATER THAN 'F' ?
0F86: D0      	        RET NC                          ;YES - RETURN
0F87: FE30    	        CP 30H                          ;LESS THAN '0'
0F89: 3002    	        JR NC,IS_HEX_1                  ;NO - CONTINUE
0F8B: 3F      	        CCF                             ; COMPLIMENT CARRY - I.E. CLEAR IT
0F8C: C9      	        RET
0F8D:         	IS_HEX_1:
0F8D: FE3A    	        CP 3AH                          ;LESS OR EQUAL TO '9'?
0F8F: D8      	        RET C                           ;YES - RETURN
0F90: FE41    	        CP 41H                          ;LESS THAN 'A'?
0F92: 3002    	        JR NC,IS_HEX_2                  ;NO - CONTINUE
0F94: 3F      	        CCF                             ;YES - CLEAR CARRY AND RETURN
0F95: C9      	        RET
0F96:         	IS_HEX_2:
0F96: 37      	        SCF                             ;SET CARRY AND RETURN
0F97: C9      	        RET
              	;------------------
              	; NIBBLE2VAL
              	; nibble2val expects a hexadecimal digit (upper case!) in A and returns the
              	; corresponding value in A.
              	;
0F98:         	NIBBLE2VAL:
0F98: FE3A    	        CP 3Ah                          ;IS IT A DIGIT?
0F9A: 3802    	        JR C,NIBBLE2VAL1                ;YES
0F9C: D607    	        SUB 7                           ;ADJUST FOR A-F
0F9E:         	NIBBLE2VAL1:
0F9E: D630    	        SUB 30H                         ;FOLD BACK TO 0..15
0FA0: E60F    	        AND 0FH
0FA2: C9      	        RET
              	
              	;------------------
              	; PRINT_NIBBLE
              	; print_nibble prints a single hex nibble which is contained in the lower
              	; four bits of A:
              	;------------------
0FA3:         	PRINT_NIBBLE:
0FA3: F5      	        PUSH AF                         ;SAVE REGISTERS
0FA4: E60F    	        AND 0FH                         ;JUST IN CASE...
0FA6: C630    	        ADD A,30h                       ;IF DIGIT, WE ARE DONE
0FA8: FE3A    	        CP 3AH                          ;IS RESULT > 9?
0FAA: 3802    	        JR C,PRINT_NIBBLE1
0FAC: C607    	        ADD A,07H                       ;TAKE CARE OF A-F ('A'-'0'-0AH)
0FAE:         	PRINT_NIBBLE1:
0FAE: CD5C03  	        CALL PRINT_CHAR                 ;PRINT THE NIBBLE
0FB1: F1      	        POP AF                          ;POP AF
0FB2: C9      	        RET
              	;----------------
              	; GETS
              	;  Read a string from STDIN - HL contains the buffer start address,
              	; B contains the buffer length.
              	;----------------
              	; NOT SURE IF THIS WILL WORK OR NOT...
0FB3:         	GETS:
0FB3: F5      	        PUSH AF
0FB4: C5      	        PUSH BC
0FB5: E5      	        PUSH HL
0FB6:         	GETS_LOOP:
0FB6: CDD703  	        CALL GET_KEY                            ;GET A CHARACTER
0FB9: FE0D    	        CP CR                                   ;SKIP CR
0FBB: 28F9    	        JR Z,GETS_LOOP                          ;LF WILL TERMINATE INPUT
0FBD: CD560F  	        CALL TO_UPPER
0FC0: CD5C03  	        CALL PRINT_CHAR                         ;ECHO CHARACTER
0FC3: FE0A    	        CP LF                                   ;TERMINATE STRING AT LF
0FC5: 2804    	        JR Z,GETS_EXIT                          ;  OR COPY TO BUFFER
0FC7: 77      	        LD (HL),A
0FC8: 23      	        INC HL
0FC9: 10EB    	        DJNZ GETS_LOOP
0FCB:         	GETS_EXIT:
0FCB: 3600    	        LD (HL),00H                             ;INSERT TERMINATION BYTE
0FCD: E1      	        POP HL
0FCE: C1      	        POP BC
0FCF: F1      	        POP AF
0FD0: C9      	        RET
              	;------------------
              	; GET_WORD
              	; Get a word (16 bit) in hexadecimal notation. The result is returned in HL.
              	; Since the routines get_byte and therefore get_nibble are called, only valid
              	; characters (0-9a-f) are accepted.
              	;------------------
              	; PROBABLY NEED TO ADJUST FOR RAM ADDRESS TO LOAD INTO..
0FD1:         	GET_WORD:
0FD1: F5      	        PUSH AF                         ;SAVE THE REGISTERS
0FD2: CD5F0F  	        CALL GET_BYTE                   ;GET THE UPPER BYTE
0FD5: 67      	        LD H,A
0FD6: CD5F0F  	        CALL GET_BYTE                   ;GET THE LOWER BYTE
0FD9: 6F      	        LD L,A
0FDA: F1      	        POP AF                          ;RESTORE THE REGISTERS
0FDB: C9      	        RET
              	
              	        ;END OF BERND'S AND ANDREW'S CODE - NOTHING ELSE FOLLOWS
              	
              	
0FDC:         	IH_OUTSPC:
0FDC: 21390F  	        LD HL,IH_LOAD_MSG_OUTSPC
0FDF: CD8F03  	        CALL PRINT_STRING
0FE2: C3F80E  	        JP IH_LOAD_EXIT
0FE5:         	IH_ADDR_TST:
0FE5: F5      	        PUSH AF
0FE6: 3EFB    	        LD A,0FBH
0FE8: 94      	        SUB H
0FE9: 2802    	        JR Z,IH_ADDR_TST2
0FEB: F1      	        POP AF
0FEC: C9      	        RET
0FED:         	IH_ADDR_TST2:
0FED: CD8C02  	        CALL DELAY                      ;BURN TIME TO LET THE TRANSFER
0FF0: CD8C02  	        CALL DELAY                      ; FINISH
0FF3: CD8C02  	        CALL DELAY
0FF6: CD8C02  	        CALL DELAY
0FF9: CDD703  	        CALL GET_KEY                    ;GET RID OF CHARACTER STILL IN BUFFER
0FFC: CDD703  	        CALL GET_KEY
0FFF: F1      	        POP AF                          ;RESTORE REGISTERS
1000: D1      	        POP DE
1001: 18D9    	        JR IH_OUTSPC                    ;PRINT MEMORY MSG AND EXIT
              	
              	;-------------------------------------------------------------------------------
              	;///////////////////////////////////////////////////////////////////////////////
              	;-------------------------------------------------------------------------------
              	
              	        ;INCLUDE "message.asm"
              	        INCLUDE "memorystick_low_level.asm"
              	; memorystick_low_level.asm
              	; Adapted to G80 computer from the Z80 Playground Project
              	; https://github.com/z80playground/cpm-fat/blob/main/README.md
              	
              	;--------------------;
              	; LOW LEVEL ROUTINES ;
              	;--------------------;
              	    
1003:         	configure_memorystick:
1003: 0605    	    ld b, 5                                 ; Have 5 attempts at configuring the module before giving up
1005:         	configure_memorystick1:
1005: C5      	    push bc
1006: CD9C11  	    call connect_to_usb_drive
1009: 2008    	    jr nz, failed_to_setup
100B: CDD710  	    call connect_to_disk
100E: CD0911  	    call mount_disk
1011: C1      	    pop bc
1012: C9      	    ret
1013:         	failed_to_setup:
1013: CD8C02  	    call DELAY
1016: CD8C02  	    call DELAY
1019: CD8C02  	    call DELAY
101C: CD8C02  	    call DELAY
101F: C1      	    pop bc
1020: 10E3    	    djnz configure_memorystick1
1022: 212910  	    LD HL,dosmsg1
1025: CD8F03  	    CALL PRINT_STRING
1028: C9      	    ret
              	
1029:         	dosmsg1:
1029: 43483337	    db 'CH376S error.',13,10,0    
102D: 36532065	
1031: 72726F72	
1035: 2E0D0A00	
              	
              	;----------------------------------------------------------------
              	; Call this once at startup
1039:         	reset_ch376_module:
1039: 3E05    	    ld a, RESET_ALL
103B: CD6A12  	    call send_command_byte
103E: CD8C02  	    call DELAY
1041: CD8C02  	    call DELAY
1044: CD8C02  	    call DELAY
1047: CD8C02  	    call DELAY
104A: C9      	    ret
              	
              	;-----------------------------------------------------------------
104B:         	check_module_exists:
104B: 3E06    	    ld a, CHECK_EXIST
104D: CD6A12  	    Call send_command_byte
              	
1050: 3E7B    	    ld a, 123               ; We send an arbitrary number
1052: CD4E12  	    Call send_data_byte
              	
1055: CD7312  	    call read_data_byte
              	
1058: FE84    	    cp 255-123      ; The result is 255 minus what we sent in
105A: C8      	    ret z
105B: 216210  	    LD HL,dosmsg2
105E: CD8F03  	    CALL PRINT_STRING
1061: C9      	    ret
              	
1062:         	dosmsg2:
1062: 4552524F	    db 'ERROR: CH376S module not found.',13,10,0
1066: 523A2043	
106A: 48333736	
106E: 53206D6F	
1072: 64756C65	
1076: 206E6F74	
107A: 20666F75	
107E: 6E642E0D	
1082: 0A00    	
              	    
              	;-----------------------------------------------------------------
1084:         	get_module_version:
1084: 219B10  	    LD HL,dosmsg3
1087: CD8F03  	    CALL PRINT_STRING
              	    
108A: 3E01    	    ld a, GET_IC_VER
108C: CD6A12  	    call send_command_byte
              	    
108F: CD7312  	    call read_data_byte
1092: E61F    	    and %00011111
              	    
1094: CDC114  	    call show_a_as_hex
1097: CDE414  	    call newline
109A: C9      	    ret
              	
109B:         	dosmsg3:
109B: 466F756E	    db 'Found CH376S v',0
109F: 64204348	
10A3: 33373653	
10A7: 207600  	
              	    
              	;-----------------------------------------------------------------
10AA:         	set_usb_host_mode:
10AA: 3E15    	    ld a, SET_USB_MODE
10AC: CD6A12  	    call send_command_byte
10AF: 3E06    	    ld a, 6
10B1: CD4E12  	    call send_data_byte
10B4: CDB212  	    call read_status_byte
10B7: FE15    	    cp USB_INT_CONNECT
10B9: C8      	    ret z
10BA: 21C110  	    LD HL,dosmsg4
10BD: CD8F03  	    CALL PRINT_STRING
10C0: C9      	    ret
              	
10C1:         	dosmsg4:
10C1: 4552524F	    db 'ERROR: No USB Disk?',13,10,0
10C5: 523A204E	
10C9: 6F205553	
10CD: 42204469	
10D1: 736B3F0D	
10D5: 0A00    	
              	    
              	;-----------------------------------------------------------------
10D7:         	connect_to_disk:
10D7: 3E30    	    ld a, DISK_CONNECT
10D9: CD6A12  	    call send_command_byte
10DC: 3E22    	    ld a, GET_STATUS
10DE: CDB212  	    call read_status_byte
10E1: C8      	    ret z
10E2: 21E910  	    LD HL,dosmsg5
10E5: CD8F03  	    CALL PRINT_STRING
10E8: C9      	    ret
              	
10E9:         	dosmsg5:
10E9: 4552524F	    db 'ERROR connecting to USB Disk.',13,10,0
10ED: 5220636F	
10F1: 6E6E6563	
10F5: 74696E67	
10F9: 20746F20	
10FD: 55534220	
1101: 4469736B	
1105: 2E0D0A00	
              	    
              	;-----------------------------------------------------------------
1109:         	mount_disk:
1109: 3E31    	    ld a, DISK_MOUNT
110B: CD6A12  	    call send_command_byte
110E: 3E22    	    ld a, GET_STATUS
1110: CDB212  	    call read_status_byte
1113: C8      	    ret z
1114: 211B11  	    LD HL,dosmsg6
1117: CD8F03  	    CALL PRINT_STRING
111A: C9      	    ret
              	
111B:         	dosmsg6:
111B: 4552524F	    db 'ERROR mounting USB Disk.',13,10,0
111F: 52206D6F	
1123: 756E7469	
1127: 6E672055	
112B: 53422044	
112F: 69736B2E	
1133: 0D0A00  	
              	
              	;-----------------------------------------------------------------
1136:         	read_disk_signature:
1136: 3E27    	    ld a, RD_USB_DATA0
1138: CD6A12  	    call send_command_byte
113B: CD7312  	    call read_data_byte                 ; A = length of bytes to now read
113E: FE24    	    cp 36
1140: 2039    	    jr nz, could_not_read_disk_sig
              	
              	    ; Ignore the first 8 bytes
1142: 0608    	    ld b, 8
1144:         	read_disk_signature1:
1144: C5      	    push bc
1145: CD7612  	    call read_data_byte_silent
1148: C1      	    pop bc
1149: 10F9    	    djnz read_disk_signature1   
              	
              	    ; Display the next 8 bytes (Manufacturer)
114B: 0608    	    ld b, 8
114D:         	read_disk_signature2:
114D: C5      	    push bc
114E: CD7612  	    call read_data_byte_silent
1151: CD5C03  	    call PRINT_CHAR
1154: C1      	    pop bc
1155: 10F6    	    djnz read_disk_signature2   
1157: CDE414  	    call newline
              	
              	    ; Display the next 16 bytes (Model)
115A: 0610    	    ld b, 16
115C:         	read_disk_signature3:
115C: C5      	    push bc
115D: CD7612  	    call read_data_byte_silent
1160: CD5C03  	    call PRINT_CHAR
1163: C1      	    pop bc
1164: 10F6    	    djnz read_disk_signature3
              	
1166: 3E20    	    ld a, ' '
1168: CD5C03  	    call PRINT_CHAR
              	
              	    ; Display the next 4 bytes (Version)
116B: 0604    	    ld b, 4
116D:         	read_disk_signature4:
116D: C5      	    push bc
116E: CD7612  	    call read_data_byte_silent
1171: CD5C03  	    call PRINT_CHAR
1174: C1      	    pop bc
1175: 10F6    	    djnz read_disk_signature4   
1177: CDE414  	    call newline
117A: C9      	    ret
              	
117B:         	could_not_read_disk_sig:
117B: 218211  	    LD HL,dosmsg7
117E: CD8F03  	    CALL PRINT_STRING
1181: C9      	    ret
              	
1182:         	dosmsg7:
1182: 4552524F	    db 'ERROR reading disk sig.',13,10,0
1186: 52207265	
118A: 6164696E	
118E: 67206469	
1192: 736B2073	
1196: 69672E0D	
119A: 0A00    	
              	
119C:         	connect_to_usb_drive:
              	    ; Connects us up to the USB Drive.
              	    ; Returns Zero flag = true if we can connect ok.
119C: CD3910  	    call reset_ch376_module 
119F: CDAA10  	    call set_usb_host_mode
11A2: FE15    	    cp USB_INT_CONNECT
11A4: C9      	    ret
              	
11A5:         	create_file:
              	    ; pass in DE = pointer to filename
11A5: D5      	    push de
11A6: 3E2F    	    ld a, SET_FILE_NAME
11A8: CD6A12  	    call send_command_byte
11AB: E1      	    pop hl
11AC: CD5412  	    call send_data_string
              	
11AF: 3E34    	    ld a, FILE_CREATE
11B1: CD6A12  	    call send_command_byte
              	
11B4: CDB212  	    call read_status_byte
11B7: FE14    	    cp USB_INT_SUCCESS
11B9: C9      	    ret
              	
11BA:         	open_file:
              	    ; Tells the module to use the filename from the filename_buffer.
              	    ; Returns z=true if ok to proceed.
              	    ; Pass in hl -> directory string, e.g. "/folder"
11BA: 3E2F    	    ld a, SET_FILE_NAME
11BC: CD6A12  	    call send_command_byte
11BF: CD5412  	    call send_data_string
11C2: 3E32    	    ld a, FILE_OPEN
11C4: CD6A12  	    call send_command_byte
11C7: CDB212  	    call read_status_byte
11CA: FE14    	    cp USB_INT_SUCCESS
11CC: C9      	    ret
              	
11CD:         	close_file:
11CD: 3E36    	    ld a, FILE_CLOSE
11CF: CD6A12  	    call send_command_byte
11D2: 3E01    	    ld a, 1                             ; 1 = update file size if necessary
11D4: CD4E12  	    call send_data_byte
11D7: CDB212  	    call read_status_byte
11DA: C9      	    ret
              	
11DB:         	create_directory:
              	    ; Tells the module to use the filename from the filename_buffer to create a directory of that name.
              	    ; Returns z=true if ok to proceed.
11DB: 2120FF  	    ld hl, filename_buffer
              	
11DE:         	create_directory2:
              	
11DE: 3E2F    	    ld a, SET_FILE_NAME
11E0: CD6A12  	    call send_command_byte
11E3: 2120FF  	    ld hl, filename_buffer
11E6: CD5412  	    call send_data_string
11E9: 3E40    	    ld a, DIR_CREATE
11EB: CD6A12  	    call send_command_byte
11EE: CDB212  	    call read_status_byte
11F1: FE14    	    cp USB_INT_SUCCESS
11F3: C9      	    ret
              	
11F4:         	read_from_file:
              	    ; Ask to read 128 bytes from the current file into the dma_address area pointed to by DE.
              	    ; Returns Zero flag set for success, clear for fail.
11F4: D5      	    push de
11F5: 3E3A    	    ld a, BYTE_READ
11F7: CD6A12  	    call send_command_byte
11FA: 3E80    	    ld a, 128                           ; Request 128 bytes
11FC: CD4E12  	    call send_data_byte
11FF: 3E00    	    ld a, 0
1201: CD4E12  	    call send_data_byte
              	
1204: CDB212  	    call read_status_byte
1207:         	read_from_file1:
1207: FE1D    	    cp USB_INT_DISK_READ                    ; This means "go ahead and read"
1209: 2807    	    jr z, read_from_file3
120B: FE14    	    cp USB_INT_SUCCESS                      ; Bizarrely this means we are finished
120D: CA3E12  	    jp z, read_from_file_cannot
1210: 182C    	    jr read_from_file_cannot
              	
1212:         	read_from_file3:
1212: 3E27    	    ld a, RD_USB_DATA0                      ; Find out how many bytes are available to read
1214: CD6A12  	    call send_command_byte
1217: CD7312  	    call read_data_byte                     ; A = number of bytes available to read
              	
              	    ; If there are less than 128 bytes to read, fill the buffer with 0s first
121A: FE80    	    cp 128
121C: 300B    	    jr nc, read_from_file_128
121E: E1      	    pop hl
121F: E5      	    push hl
1220: F5      	    push af
1221: 0680    	    ld b, 128
1223:         	read_from_file_padding:
1223: 3600    	    ld (hl), 0
1225: 23      	    inc hl
1226: 10FB    	    djnz read_from_file_padding
1228: F1      	    pop af
              	
1229:         	read_from_file_128:
1229: E1      	    pop hl
122A: CD7C12  	    call read_data_bytes_into_hl        ; Read this block of data
122D: E5      	    push hl
122E: 3E3B    	    ld a, BYTE_RD_GO
1230: CD6A12  	    call send_command_byte
1233: 3E22    	    ld a, GET_STATUS
1235: CD6A12  	    call send_command_byte
1238: CD7312  	    call read_data_byte
123B: E1      	    pop hl
              	    ; All done, so return ZERO for success
123C: BF      	    cp a                                ; set zero flag for success
123D: C9      	    ret
              	
123E:         	read_from_file_cannot:
123E: D1      	    pop de
123F: F601    	    or 1                                ; clear zero flag
1241: C9      	    ret
              	
1242:         	copy_filename_to_buffer:
              	    ; Enter with hl->zero-terminated-filename-string
              	    ; Copies this to filename_buffer
1242: 1120FF  	    ld de, filename_buffer
1245:         	copy_filename_to_buffer1:
1245: 7E      	    ld a, (hl)
1246: 12      	    ld (de), a
1247: 23      	    inc hl
1248: 13      	    inc de
1249: FE00    	    cp 0
124B: C8      	    ret z
124C: 18F7    	    jr copy_filename_to_buffer1
              	
124E:         	send_data_byte:
124E: D304    	    out (mem_stick_data_port), a
1250: CD8412  	    call wait_til_not_busy
1253: C9      	    ret
              	    
1254:         	send_data_string:
              	    ; The string is pointed to by HL
1254: 7E      	    ld a, (hl)
1255: FE00    	    cp 0
1257: 280B    	    jr z, send_data_string_done
1259: F5      	    push af
125A: E5      	    push hl
125B: CD4E12  	    call send_data_byte
125E: E1      	    pop hl
125F: F1      	    pop af
1260: 23      	    inc hl
1261: C35412  	    jp send_data_string
1264:         	send_data_string_done:
1264: 3E00    	    ld a, 0
1266: CD4E12  	    call send_data_byte
1269: C9      	    ret
              	
126A:         	send_command_byte:
126A: D305    	    out (mem_stick_command_port), a
126C: CD8412  	    call wait_til_not_busy
126F: C9      	    ret
              	    
1270:         	read_command_byte:
1270: DB05    	    in a, (mem_stick_command_port)
1272: C9      	    ret
              	    
1273:         	read_data_byte:
1273: DB04    	    in a, (mem_stick_data_port)
1275: C9      	    ret
              	    
1276:         	read_data_byte_silent:
1276: DB04    	    in a, (mem_stick_data_port)
1278: C9      	    ret
              	
1279:         	read_data_bytes_into_buffer:
              	    ; The number of bytes should be in A.
              	    ; Read that many bytes into the buffer.
              	    ; The value of A is retained.
1279: 2130FF  	    ld hl, disk_buffer
127C:         	read_data_bytes_into_hl:
              	    ; This entry point will read A bytes into the area pointed to by HL.
              	    ; On exit HL will point to the location after where the bytes were added.
127C: F5      	    push af
127D: 47      	    ld b, a
127E: 0E04    	    ld c, mem_stick_data_port
1280:         	read_data_bytes_into_buffer1:
1280: EDB2    	    inir                    ; A rare use of In, Increase & Repeat!!!
1282: F1      	    pop af
1283: C9      	    ret
              	    
1284:         	wait_til_not_busy:
1284: 0160EA  	    ld bc, 60000            ; retry max 60000 times!!!
1287:         	wait_til_not_busy1:
1287: C5      	    push bc
1288: CD7012  	    call read_command_byte
128B: E610    	    and %00010000
128D: C29212  	    jp nz, wait_til_not_busy2
1290: C1      	    pop bc
1291: C9      	    ret
1292:         	wait_til_not_busy2:
1292: CD9902  	    call MILLI_DLY
1295: C1      	    pop bc
1296: 0B      	    dec bc
1297: 78      	    ld a, b
1298: B1      	    or c
1299: 20EC    	    jr nz, wait_til_not_busy1
129B: 21A212  	    LD HL,dosmsg8
129E: CD8F03  	    CALL PRINT_STRING
12A1: C9      	    ret
              	
12A2:         	dosmsg8:
12A2: 5B555342	    db '[USB TIMEOUT]', 13, 10, 0
12A6: 2054494D	
12AA: 454F5554	
12AE: 5D0D0A00	
              	
12B2:         	read_status_byte:
12B2: 3E22    	    ld a, GET_STATUS
12B4: CD6A12  	    call send_command_byte
12B7: CD7312  	    call read_data_byte
12BA: C9      	    ret
              	
12BB:         	directory:                                    ; This does a directory listing.
              	    ; Clear files counter
12BB: 3E00    	    ld a, 0
12BD: 321FFF  	    ld (tb_dir_count), a
              	    
              	    ; Open ROOT folder
12C0: 21F114  	    ld hl, SLASHSTR
12C3: CDBA11  	    call open_file
              	    
              	    ; Then open *
12C6: 21F314  	    ld hl, STAR_DOT_STAR
12C9: CDBA11  	    call open_file
              	    
              	    ; Loop through, printing the file names, one per line
12CC:         	tb_dir_loop:
12CC: FE1D    	    cp USB_INT_DISK_READ
12CE: 2821    	    jr z, tbasic_dir_loop_good
              	    
12D0: 3A1FFF  	    ld a, (tb_dir_count)
12D3: FE00    	    cp 0
12D5: C2DE12  	    jp nz, dir_end
              	    
12D8: 21DF12  	    LD HL,dosmsg9
12DB: CD8F03  	    CALL PRINT_STRING
12DE:         	dir_end:
12DE: C9      	    ret
              	    
12DF:         	dosmsg9:
12DF: 4E6F2066	    db 'No files found.',13,10,0
12E3: 696C6573	
12E7: 20666F75	
12EB: 6E642E0D	
12EF: 0A00    	
              	    
12F1:         	tbasic_dir_loop_good:
12F1: 3E27    	    ld a, RD_USB_DATA0
12F3: CD6A12  	    call send_command_byte
12F6: CD7312  	    call read_data_byte                 ; Find out how many bytes there are to read
              	    
12F9: CD7912  	    call read_data_bytes_into_buffer    ; read them into disk_buffer
12FC: FE20    	    cp 32                               ; Did we read at least 32 bytes?
12FE: 300B    	    jr nc, tb_dir_good_length
1300:         	tb_dir_next:
1300: 3E33    	    ld a, FILE_ENUM_GO                  ; Go to next entry in the directory
1302: CD6A12  	    call send_command_byte
1305: CDB212  	    call read_status_byte
1308: C3CC12  	    jp tb_dir_loop
              	    
130B:         	tb_dir_good_length:
130B: 3A3BFF  	    ld a, (disk_buffer+11)
130E: E616    	    and $16                             ; Check for hidden or system files, or directories
1310: C20013  	    jp nz, tb_dir_next                  ; and skip accordingly.
              	    
1313:         	tb_it_is_not_system:
1313: 211FFF  	    ld hl, tb_dir_count
1316: 34      	    inc (hl)
              	    
              	    ; Show filename from diskbuffer
1317: 0608    	    ld b, 8
1319: 2130FF  	    ld hl, disk_buffer
131C:         	tb_dir_show_name_loop:
131C: 7E      	    ld a, (hl)
131D: CD5C03  	    call PRINT_CHAR
1320: 23      	    inc hl
1321: 10F9    	    djnz tb_dir_show_name_loop
              	    
1323: 3E2E    	    ld a, '.'
1325: CD5C03  	    call PRINT_CHAR
              	    
1328: 0603    	    ld b, 3
132A:         	tb_dir_show_extension_loop:
132A: 7E      	    ld a, (hl)
132B: CD5C03  	    call PRINT_CHAR
132E: 23      	    inc hl
132F: 10F9    	    djnz tb_dir_show_extension_loop
1331: CDE414  	    call newline
1334: C30013  	    jp tb_dir_next
              	
1337:         	save:                    ; This Saves the current program to USB Drive with the given name.
1337: D5      	    push de
1338: CDB313  	    call get_program_size
133B: D1      	    pop de
133C: 7C      	    ld a, h
133D: B5      	    or l
133E: FE00    	    cp 0
1340: 2021    	    jr nz, save_continue
1342: 214913  	    LD HL,dosmsg10
1345: CD8F03  	    CALL PRINT_STRING
1348: C9      	    ret
              	    
1349:         	dosmsg10:
1349: 4E6F2070	    db 'No program yet to save!',13,10,0
134D: 726F6772	
1351: 616D2079	
1355: 65742074	
1359: 6F207361	
135D: 7665210D	
1361: 0A00    	
              	    
1363:         	save_continue:
              	    ;call READ_QUOTED_FILENAME
1363: CD8014  	    call does_file_exist
1366: CC5414  	    call z, tb_erase_file
              	    
1369: CDCD11  	    call close_file
              	    
136C: 218713  	    LD HL,dosmsg11
136F: CD8F03  	    CALL PRINT_STRING
              	    
1372: 21F114  	    ld hl, SLASHSTR
1375: CDBA11  	    call open_file
1378: 1120FF  	    ld de, filename_buffer
137B: CDA511  	    call create_file
137E: 2837    	    jr z, tb_save_continue
1380: 219A13  	    LD HL,dosmsg12
1383: CD8F03  	    CALL PRINT_STRING
1386: C9      	    ret
              	    
1387:         	dosmsg11:
1387: 43726561	    db 'Creating file...',13,10,0
138B: 74696E67	
138F: 2066696C	
1393: 652E2E2E	
1397: 0D0A00  	
139A:         	dosmsg12:
139A: 436F756C	    db 'Could not create file.',13,10,0
139E: 64206E6F	
13A2: 74206372	
13A6: 65617465	
13AA: 2066696C	
13AE: 652E0D0A	
13B2: 00      	
              	    
13B3:         	get_program_size:
              	    ; Gets the total size of the program, in bytes, into hl
13B3: 21FF7D  	    ld hl, 7DFFH
13B6: C9      	    ret
              	    
13B7:         	tb_save_continue:
13B7: CDCD11  	    call close_file
13BA: 21F114  	    ld hl, SLASHSTR
13BD: CDBA11  	    call open_file
13C0: 2120FF  	    ld hl, filename_buffer
13C3: CDBA11  	    call open_file
              	    
13C6: 3E3C    	    ld a, BYTE_WRITE
13C8: CD6A12  	    call send_command_byte
              	    
              	    ; Send number of bytes we are about to write, as 16 bit number, low first
13CB: CDB313  	    call get_program_size
13CE: 7D      	    ld a, l
13CF: CD4E12  	    call send_data_byte
13D2: 7C      	    ld a, h
13D3: CD4E12  	    call send_data_byte
              	    
13D6: 210080  	    ld hl, 8000H
13D9: CD8C14  	    call write_loop
13DC: CDCD11  	    call close_file
13DF: C9      	    ret
              	    
13E0:         	load:                                   ; *** LOAD "filename" *** 
              	    ;call READ_QUOTED_FILENAME
13E0: CD8014  	    call does_file_exist
13E3: 2819    	    jr z, load_can_do
13E5:         	tb_file_not_found
13E5: 21EC13  	    LD HL,dosmsg13
13E8: CD8F03  	    CALL PRINT_STRING
13EB: C9      	    ret
              	    
13EC:         	dosmsg13:
13EC: 46696C65	    db 'File not found.',13,10,0
13F0: 206E6F74	
13F4: 20666F75	
13F8: 6E642E0D	
13FC: 0A00    	
              	    
13FE:         	load_can_do:
13FE: 21F114  	    ld hl, SLASHSTR
1401: CDBA11  	    call open_file
1404: 2120FF  	    ld hl, filename_buffer
1407: CDBA11  	    call open_file
              	    
140A: 3E3A    	    ld a, BYTE_READ
140C: CD6A12  	    call send_command_byte
140F: 3EFF    	    ld a, 255                           ; Request all of the file
1411: CD4E12  	    call send_data_byte
1414: 3EFF    	    ld a, 255                           ; Yes, all!
1416: CD4E12  	    call send_data_byte
              	    
1419: 3E22    	    ld a, GET_STATUS
141B: CD6A12  	    call send_command_byte
141E: CD7312  	    call read_data_byte
1421: 210080  	    ld hl, 8000H                       ; Get back the target address
1424:         	tb_load_loop1:
1424: FE1D    	    cp USB_INT_DISK_READ
1426: 201F    	    jr nz, tb_load_finished
              	    
1428: E5      	    push hl
1429: 3E27    	    ld a, RD_USB_DATA0
142B: CD6A12  	    call send_command_byte
142E: CD7312  	    call read_data_byte
              	    ;push af
              	    ;ld a,"."
              	    ;call PRINT_CHAR
              	    ;pop af
1431: E1      	    pop hl
1432: CD7C12  	    call read_data_bytes_into_hl
1435: E5      	    push hl
1436: 3E3B    	    ld a, BYTE_RD_GO
1438: CD6A12  	    call send_command_byte
143B: 3E22    	    ld a, GET_STATUS
143D: CD6A12  	    call send_command_byte
1440: CD7312  	    call read_data_byte
1443: E1      	    pop hl
1444: C32414  	    jp tb_load_loop1
1447:         	tb_load_finished:
              	    ;ld (TXTUNF), hl
1447: CDCD11  	    call close_file
144A: C9      	    ret
              	
144B:         	ERASE:              ; *** ERASE "filename" *** 
              	    ;call READ_QUOTED_FILENAME
              	    ; need to set filename_buffer
144B: CD8014  	    call does_file_exist
144E: 2095    	    jr nz, tb_file_not_found
1450: CD5414  	    call tb_erase_file
1453: C9      	    ret
              	    
1454:         	tb_erase_file:
1454: 216E14  	    LD HL,dosmsg14
1457: CD8F03  	    CALL PRINT_STRING
145A: 3E2F    	    ld a, SET_FILE_NAME
145C: CD6A12  	    call send_command_byte
145F: 2120FF  	    ld hl, filename_buffer
1462: CD5412  	    call send_data_string
1465: 3E35    	    ld a, FILE_ERASE
1467: CD6A12  	    call send_command_byte
146A: CDB212  	    call read_status_byte
146D: C9      	    ret
              	    
146E:         	dosmsg14:
146E: 45726173	    db 'Erasing file...',13,10,0
1472: 696E6720	
1476: 66696C65	
147A: 2E2E2E0D	
147E: 0A00    	
              	    
1480:         	does_file_exist:
              	    ; Looks on disk for a file. Returns Z if file exists.
1480: 21F114  	    ld hl, SLASHSTR
1483: CDBA11  	    call open_file
1486: 2120FF  	    ld hl, filename_buffer
1489: C3BA11  	    jp open_file
              	    
148C:         	write_loop
              	    ;ld a,"."
              	    ;call PRINT_CHAR
148C: CDB212  	    call read_status_byte
148F: FE1E    	    cp USB_INT_DISK_WRITE
1491: 2024    	    jr nz, write_finished
              	    
1493: E5      	    push hl
              	    ; Ask if we can send some bytes
1494: 3E2D    	    ld a, WR_REQ_DATA
1496: CD6A12  	    call send_command_byte
1499: CD7312  	    call read_data_byte
149C: E1      	    pop hl
149D: FE00    	    cp 0
149F: 2816    	    jr z, write_finished
14A1: 47      	    ld b, a
14A2:         	block_loop:
14A2: 7E      	    ld a, (hl)
14A3: E5      	    push hl
14A4: C5      	    push bc
14A5: CD4E12  	    call send_data_byte
14A8: C1      	    pop bc
14A9: E1      	    pop hl
14AA: 23      	    inc hl
14AB: 10F5    	    djnz block_loop
              	    
14AD: E5      	    push hl
14AE: 3E3D    	    ld a, BYTE_WR_GO
14B0: CD6A12  	    call send_command_byte
14B3: E1      	    pop hl
14B4: C38C14  	    jp write_loop
              	    
14B7:         	write_finished:
14B7: C9      	    ret
              	
14B8:         	show_hl_as_hex:
14B8: 7C      	    ld a, h
14B9: CDC114  	    call show_a_as_hex
14BC: 7D      	    ld a, l
14BD: CDC114  	    call show_a_as_hex
14C0: C9      	    ret
              	    
14C1:         	show_a_as_hex:
14C1: F5      	    push af
14C2: CB3F    	    srl a
14C4: CB3F    	    srl a
14C6: CB3F    	    srl a
14C8: CB3F    	    srl a
14CA: C630    	    add a,'0'
14CC: FE3A    	    cp ':'
14CE: 3802    	    jr c, show_a_as_hex1
14D0: C607    	    add a, 7
14D2:         	show_a_as_hex1:
14D2: CD5C03  	    call PRINT_CHAR
14D5: F1      	    pop af
14D6: E60F    	    and %00001111
14D8: C630    	    add a,'0'
14DA: FE3A    	    cp ':'
14DC: 3802    	    jr c, show_a_as_hex2
14DE: C607    	    add a, 7
14E0:         	show_a_as_hex2:
14E0: CD5C03  	    call PRINT_CHAR
14E3: C9      	    ret
              	
14E4:         	newline:
14E4: 3E0D    	    ld a,13
14E6: CD5C03  	    call PRINT_CHAR
14E9: 3E0A    	    ld a,10
14EB: CD5C03  	    call PRINT_CHAR
14EE: C9      	    ret
              	    
0004:         	mem_stick_data_port equ 04
0005:         	mem_stick_command_port equ 05
              	
0001:         	GET_IC_VER equ $01
0002:         	SET_BAUDRATE equ $02
0005:         	RESET_ALL equ $05
0006:         	CHECK_EXIST equ $06
000C:         	GET_FILE_SIZE equ $0C
0015:         	SET_USB_MODE equ $15
0022:         	GET_STATUS equ $22
0027:         	RD_USB_DATA0 equ $27
002C:         	WR_USB_DATA equ $2C
002D:         	WR_REQ_DATA equ $2D
002E:         	WR_OFS_DATA equ $2E
002F:         	SET_FILE_NAME equ $2F
0030:         	DISK_CONNECT equ $30
0031:         	DISK_MOUNT equ $31
0032:         	FILE_OPEN equ $32
0033:         	FILE_ENUM_GO equ $33
0034:         	FILE_CREATE equ $34
0035:         	FILE_ERASE equ $35
0036:         	FILE_CLOSE equ $36
0037:         	DIR_INFO_READ equ $37
0038:         	DIR_INFO_SAVE equ $38
0039:         	BYTE_LOCATE equ $39
003A:         	BYTE_READ equ $3A
003B:         	BYTE_RD_GO equ $3B
003C:         	BYTE_WRITE equ $3C
003D:         	BYTE_WR_GO equ $3D
003E:         	DISK_CAPACITY equ $3E
003F:         	DISK_QUERY equ $3F
0040:         	DIR_CREATE equ $40
              	
              	; Statuses
0014:         	USB_INT_SUCCESS equ $14
0015:         	USB_INT_CONNECT equ $15
0016:         	USB_INT_DISCONNECT equ $16
0017:         	USB_INT_BUF_OVER equ $17
0018:         	USB_INT_USB_READY equ $18
001D:         	USB_INT_DISK_READ equ $1D
001E:         	USB_INT_DISK_WRITE equ $1E
001F:         	USB_INT_DISK_ERR equ $1F
0041:         	YES_OPEN_DIR equ $41
0042:         	ERR_MISS_FILE equ $42
0043:         	ERR_FOUND_NAME equ $43
0082:         	ERR_DISK_DISCON equ $82
0084:         	ERR_LARGE_SECTOR equ $84
0092:         	ERR_TYPE_ERROR equ $92
00A1:         	ERR_BPB_ERROR equ $A1
00B1:         	ERR_DISK_FULL equ $B1
00B2:         	ERR_FDT_OVER equ $B2
00B4:         	ERR_FILE_CLOSE equ $B4
              	
14EF:         	ROOT_DIRECTORY:
14EF: 2A00    	    db '*',0
              	
14F1:         	SLASHSTR:
14F1: 2F00    	    db '/',0
              	    
14F3:         	STAR_DOT_STAR:
14F3: 2A2E2A00	    db '*.*',0
              	    
              	    
              	
              	        IF (BASIC = 1)
              	        INCLUDE "basic.asm"
              	        ENDIF
              	
              	        IF (MS_BASIC = 1)
              	        INCLUDE "bas32K.asm"
              	;==================================================================================
              	; The updates to the original BASIC within this file are copyright Grant Searle
              	;
              	; You have permission to use this for NON COMMERCIAL USE ONLY
              	; If you wish to use it elsewhere, please include an acknowledgement to myself.
              	;
              	; http://searle.hostei.com/grant/index.html
              	;
              	; eMail: home.micros01@btinternet.com
              	;
              	; If the above don't work, please perform an Internet search to see if I have
              	; updated the web page hosting service.
              	;
              	;==================================================================================
              	
              	; Modified by Pat Dziuk to add DOS commands (DIR, DEL, SAVE, LOAD working with CH376S usb interface
              	; Modified by Pat Dziuk to sit along side Doug Gabbard's G80 Monitor - specifically moved start address to $200
              	
              	; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
              	; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
              	; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
              	; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
              	; the original ROM code (checksum A934H). PA
              	
              	; GENERAL EQUATES
              	
              	;CTRLC   EQU    03H             ; Control "C"
              	;CTRLG   EQU    07H             ; Control "G"
              	;BKSP    EQU    08H             ; Back space
              	;LF      EQU    0AH             ; Line feed
              	;CS      EQU    0CH             ; Clear screen
              	;CR      EQU    0DH             ; Carriage return
              	;CTRLO   EQU    0FH             ; Control "O"
              	;CTRLQ	EQU	11H		; Control "Q"
              	;CTRLR   EQU    12H             ; Control "R"
              	;CTRLS   EQU    13H             ; Control "S"
              	;CTRLU   EQU    15H             ; Control "U"
              	;ESC     EQU    1BH             ; Escape
              	;DEL     EQU    7FH             ; Delete
              	
              	; BASIC WORK SPACE LOCATIONS
              	
8045:         	WRKSPC  EQU    8045H               ; BASIC Work space
8048:         	USR     EQU    WRKSPC+3H           ; "USR (x)" jump
804B:         	OUTSUB  EQU    WRKSPC+6H           ; "OUT p,n"
804C:         	OTPORT  EQU    WRKSPC+7H           ; Port (p)
804E:         	DIVSUP  EQU    WRKSPC+9H           ; Division support routine
804F:         	DIV1    EQU    WRKSPC+0AH           ; <- Values
8053:         	DIV2    EQU    WRKSPC+0EH           ; <-   to
8057:         	DIV3    EQU    WRKSPC+12H           ; <-   be
805A:         	DIV4    EQU    WRKSPC+15H           ; <-inserted
805C:         	SEED    EQU    WRKSPC+17H           ; Random number seed
807F:         	LSTRND  EQU    WRKSPC+3AH           ; Last random number
8083:         	INPSUB  EQU    WRKSPC+3EH           ; #INP (x)" Routine
8084:         	INPORT  EQU    WRKSPC+3FH           ; PORT (x)
8086:         	NULLS   EQU    WRKSPC+41H           ; Number of nulls
8087:         	LWIDTH  EQU    WRKSPC+42H           ; Terminal width
8088:         	COMMAN  EQU    WRKSPC+43H           ; Width for commas
8089:         	NULFLG  EQU    WRKSPC+44H           ; Null after input byte flag
808A:         	CTLOFG  EQU    WRKSPC+45H           ; Control "O" flag
808B:         	LINESC  EQU    WRKSPC+46H           ; Lines counter
808D:         	LINESN  EQU    WRKSPC+48H           ; Lines number
808F:         	CHKSUM  EQU    WRKSPC+4AH           ; Array load/save check sum
8091:         	NMIFLG  EQU    WRKSPC+4CH           ; Flag for NMI break routine
8092:         	BRKFLG  EQU    WRKSPC+4DH           ; Break flag
8093:         	RINPUT  EQU    WRKSPC+4EH           ; Input reflection
8096:         	POINT   EQU    WRKSPC+51H           ; "POINT" reflection (unused)
8099:         	PSET    EQU    WRKSPC+54H           ; "SET"   reflection
809C:         	RESET   EQU    WRKSPC+57H           ; "RESET" reflection
809F:         	STRSPC  EQU    WRKSPC+5AH           ; Bottom of string space
80A1:         	LINEAT  EQU    WRKSPC+5CH           ; Current line number
80A3:         	BASTXT  EQU    WRKSPC+5EH           ; Pointer to start of program
80A6:         	BUFFER  EQU    WRKSPC+61H           ; Input buffer
80AB:         	STACKBAS EQU    WRKSPC+66H          ; Initial stack
80F0:         	CURPOS  EQU    WRKSPC+0ABH          ; Character position on line
80F1:         	LCRFLG  EQU    WRKSPC+0ACH          ; Locate/Create flag
80F2:         	TYPE    EQU    WRKSPC+0ADH          ; Data type flag
80F3:         	DATFLG  EQU    WRKSPC+0AEH          ; Literal statement flag
80F4:         	LSTRAM  EQU    WRKSPC+0AFH          ; Last available RAM
80F6:         	TMSTPT  EQU    WRKSPC+0B1H          ; Temporary string pointer
80F8:         	TMSTPL  EQU    WRKSPC+0B3H          ; Temporary string pool
8104:         	TMPSTR  EQU    WRKSPC+0BFH          ; Temporary string
8108:         	STRBOT  EQU    WRKSPC+0C3H          ; Bottom of string space
810A:         	CUROPR  EQU    WRKSPC+0C5H          ; Current operator in EVAL
810C:         	LOOPST  EQU    WRKSPC+0C7H          ; First statement of loop
810E:         	DATLIN  EQU    WRKSPC+0C9H          ; Line of current DATA item
8110:         	FORFLG  EQU    WRKSPC+0CBH          ; "FOR" loop flag
8111:         	LSTBIN  EQU    WRKSPC+0CCH          ; Last byte entered
8112:         	READFG  EQU    WRKSPC+0CDH          ; Read/Input flag
8113:         	BRKLIN  EQU    WRKSPC+0CEH          ; Line of break
8115:         	NXTOPR  EQU    WRKSPC+0D0H          ; Next operator in EVAL
8117:         	ERRLIN  EQU    WRKSPC+0D2H          ; Line of error
8119:         	CONTAD  EQU    WRKSPC+0D4H          ; Where to CONTinue
811B:         	PROGND  EQU    WRKSPC+0D6H          ; End of program
811D:         	VAREND  EQU    WRKSPC+0D8H          ; End of variables
811F:         	ARREND  EQU    WRKSPC+0DAH          ; End of arrays
8121:         	NXTDAT  EQU    WRKSPC+0DCH          ; Next data item
8123:         	FNRGNM  EQU    WRKSPC+0DEH          ; Name of FN argument
8125:         	FNARG   EQU    WRKSPC+0E0H          ; FN argument value
8129:         	FPREG   EQU    WRKSPC+0E4H          ; Floating point register
812C:         	FPEXP   EQU    FPREG+3         ; Floating point exponent
812D:         	SGNRES  EQU    WRKSPC+0E8H     ; Sign of result
812E:         	PBUFF   EQU    WRKSPC+0E9H     ; Number print buffer
813B:         	MULVAL  EQU    WRKSPC+0F6H     ; Multiplier
813E:         	PROGST  EQU    WRKSPC+0F9H     ; Start of program text area
81A2:         	STLOOK  EQU    WRKSPC+15DH     ; Start of memory test
              	
              	; BASIC ERROR CODE VALUES
              	
0000:         	NF      EQU    00H             ; NEXT without FOR
0002:         	SN      EQU    02H             ; Syntax error
0004:         	RG      EQU    04H             ; RETURN without GOSUB
0006:         	OD      EQU    06H             ; Out of DATA
0008:         	FC      EQU    08H             ; Function call error
000A:         	OV      EQU    0AH             ; Overflow
000C:         	OM      EQU    0CH             ; Out of memory
000E:         	UL      EQU    0EH             ; Undefined line number
0010:         	BS      EQU    10H             ; Bad subscript
0012:         	DD      EQU    12H             ; Re-DIMensioned array
0014:         	DZ      EQU    14H             ; Division by zero (/0)
0016:         	ID      EQU    16H             ; Illegal direct
0018:         	TM      EQU    18H             ; Type miss-match
001A:         	OS      EQU    1AH             ; Out of string space
001C:         	LS      EQU    1CH             ; String too long
001E:         	ST      EQU    1EH             ; String formula too complex
0020:         	CN      EQU    20H             ; Can't CONTinue
0022:         	UF      EQU    22H             ; UnDEFined FN function
0024:         	MO      EQU    24H             ; Missing operand
0026:         	HX      EQU    26H             ; HEX error
0028:         	BN      EQU    28H             ; BIN error
              	
              	;        .ORG    0200H
              	
14F7: C3FD14  	COLD:   JP      STARTB          ; Jump for cold start
14FA: C39B15  	WARM:   JP      WARMST          ; Jump for warm start
14FD:         	STARTB: 
14FD: DD210000	        LD      IX,0            ; Flag cold start
1501: C30815  	        JP      CSTART          ; Jump to initialise
              	
1504: DE1D    	        DW   DEINT           ; Get integer -32768 to 32767
1506: 5425    	        DW   ABPASS          ; Return integer in AB
              	
              	
1508: 214580  	CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
150B: F9      	        LD      SP,HL           ; Set up a temporary stack
150C: C3B533  	        JP      INITST          ; Go to initialise
              	
150F: 110318  	INITMS:   LD      DE,INITAB       ; Initialise workspace
1512: 0663    	        LD      B,INITBE-INITAB+3; Bytes to copy
1514: 214580  	        LD      HL,WRKSPC       ; Into workspace RAM
1517: 1A      	COPY:   LD      A,(DE)          ; Get source
1518: 77      	        LD      (HL),A          ; To destination
1519: 23      	        INC     HL              ; Next destination
151A: 13      	        INC     DE              ; Next source
151B: 05      	        DEC     B               ; Count bytes
151C: C21715  	        JP      NZ,COPY         ; More to move
151F: F9      	        LD      SP,HL           ; Temporary stack
1520: CD041A  	        CALL    CLREG           ; Clear registers and stack
1523: CDD41F  	        CALL    PRNTCRLF        ; Output CRLF
1526: 32EF80  	        LD      (BUFFER+72+1),A ; Mark end of buffer
1529: 323E81  	        LD      (PROGST),A      ; Initialise program area
152C: 21EA15  	MSIZE:  LD      HL,MEMMSG       ; Point to message
152F: CD8226  	        CALL    PRS             ; Output "Memory size"
1532: CD211A  	        CALL    PROMPT          ; Get input with '?'
1535: CD271D  	        CALL    GETCHR          ; Get next character
1538: B7      	        OR      A               ; Set flags
1539: C25115  	        JP      NZ,TSTMEM       ; If number - Test if RAM there
153C: 21A281  	        LD      HL,STLOOK       ; Point to start of RAM
153F: 23      	MLOOP:  INC     HL              ; Next byte
1540: 7C      	        LD      A,H             ; Above address FFFF ?
1541: B5      	        OR      L
1542: CA6315  	        JP      Z,SETTOP        ; Yes - 64K RAM
1545: 7E      	        LD      A,(HL)          ; Get contents
1546: 47      	        LD      B,A             ; Save it
1547: 2F      	        CPL                     ; Flip all bits
1548: 77      	        LD      (HL),A          ; Put it back
1549: BE      	        CP      (HL)            ; RAM there if same
154A: 70      	        LD      (HL),B          ; Restore old contents
154B: CA3F15  	        JP      Z,MLOOP         ; If RAM - test next byte
154E: C36315  	        JP      SETTOP          ; Top of RAM found
              	
1551: CDF81D  	TSTMEM: CALL    ATOH            ; Get high memory into DE
1554: B7      	        OR      A               ; Set flags on last byte
1555: C2D218  	        JP      NZ,SNERR        ; ?SN Error if bad character
1558: EB      	        EX      DE,HL           ; Address into HL
1559: 2B      	        DEC     HL              ; Back one byte
155A: 3ED9    	        LD      A,11011001B     ; Test byte
155C: 46      	        LD      B,(HL)          ; Get old contents
155D: 77      	        LD      (HL),A          ; Load test byte
155E: BE      	        CP      (HL)            ; RAM there if same
155F: 70      	        LD      (HL),B          ; Restore old contents
1560: C22C15  	        JP      NZ,MSIZE        ; Ask again if no RAM
              	
1563: 2B      	SETTOP: DEC     HL              ; Back one byte
1564: 11A181  	        LD      DE,STLOOK-1     ; See if enough RAM
1567: CD9A1B  	        CALL    CPDEHL          ; Compare DE with HL
156A: DA2C15  	        JP      C,MSIZE         ; Ask again if not enough RAM
156D: 11CEFF  	        LD      DE,0-50         ; 50 Bytes string space
1570: 22F480  	        LD      (LSTRAM),HL     ; Save last available RAM
1573: 19      	        ADD     HL,DE           ; Allocate string space
1574: 229F80  	        LD      (STRSPC),HL     ; Save string space
1577: CDDF19  	        CALL    CLRPTR          ; Clear program area
157A: 2A9F80  	        LD      HL,(STRSPC)     ; Get end of memory
157D: 11EFFF  	        LD      DE,0-17         ; Offset for free bytes
1580: 19      	        ADD     HL,DE           ; Adjust HL
1581: 113E81  	        LD      DE,PROGST       ; Start of program text
1584: 7D      	        LD      A,L             ; Get LSB
1585: 93      	        SUB     E               ; Adjust it
1586: 6F      	        LD      L,A             ; Re-save
1587: 7C      	        LD      A,H             ; Get MSB
1588: 9A      	        SBC     A,D             ; Adjust it
1589: 67      	        LD      H,A             ; Re-save
158A: E5      	        PUSH    HL              ; Save bytes free
158B: 21B315  	        LD      HL,SIGNON       ; Sign-on message
158E: CD8226  	        CALL    PRS             ; Output string
1591: E1      	        POP     HL              ; Get bytes free back
1592: CD252D  	        CALL    PRNTHL          ; Output amount of free memory
1595: 21A415  	        LD      HL,BFREE        ; " Bytes free" message
1598: CD8226  	        CALL    PRS             ; Output string
              	
159B: 31AB80  	WARMST: LD      SP,STACKBAS     ; Temporary stack
159E: CD041A  	BRKRET: CALL    CLREG           ; Clear registers and stack
15A1: C31D19  	        JP      PRNTOK          ; Go to get command line
              	
15A4: 20427974	BFREE:  DB   " Bytes free",CR,LF,0,0
15A8: 65732066	
15AC: 7265650D	
15B0: 0A0000  	
              	
15B3: 5A383020	SIGNON: DB   "Z80 BASIC Ver 4.7b",CR,LF
15B7: 42415349	
15BB: 43205665	
15BF: 7220342E	
15C3: 37620D0A	
15C7: 436F7079	        DB   "Copyright ",40,"C",41
15CB: 72696768	
15CF: 74202843	
15D3: 29      	
15D4: 20313937	        DB   " 1978 by Microsoft",CR,LF,0,0
15D8: 38206279	
15DC: 204D6963	
15E0: 726F736F	
15E4: 66740D0A	
15E8: 0000    	
              	
15EA: 4D656D6F	MEMMSG: DB   "Memory top",0
15EE: 72792074	
15F2: 6F7000  	
              	
              	; FUNCTION ADDRESS TABLE
              	
15F5: 9A2B    	FNCTAB: DW   SGN
15F7: 5E2C    	        DW   INT
15F9: B02B    	        DW   ABS
15FB: 4880    	        DW   USR
15FD: 3225    	        DW   FRE
15FF: C728    	        DW   INP
1601: 6025    	        DW   POS
1603: 6825    	        DW   INKEY
1605: 242E    	        DW   SQR
1607: 032F    	        DW   RND
1609: 3F2A    	        DW   LOG
160B: 722E    	        DW   EXP
160D: 782F    	        DW   COS
160F: 7E2F    	        DW   SIN
1611: DF2F    	        DW   TAN
1613: F42F    	        DW   ATN
1615: 1B29    	        DW   PEEK
1617: 1831    	        DW   DEEK
1619: 9680    	        DW   POINT
161B: F427    	        DW   LEN
161D: 0C26    	        DW   STR
161F: 8E28    	        DW   VAL
1621: 0328    	        DW   ASC
1623: 1428    	        DW   CHR
1625: B332    	        DW   HEX
1627: 4633    	        DW   BIN
1629: 2428    	        DW   LEFT
162B: 5428    	        DW   RIGHT
162D: 5E28    	        DW   MID
              	
              	; RESERVED WORD LIST
              	
162F: C54E44  	WORDS:  DB   'E'+80H,"ND"
1632: C64F52  	        DB   'F'+80H,"OR"
1635: CE455854	        DB   'N'+80H,"EXT"
1639: C4415441	        DB   'D'+80H,"ATA"
163D: C94E5055	        DB   'I'+80H,"NPUT"
1641: 54      	
1642: C4494D  	        DB   'D'+80H,"IM"
1645: D2454144	        DB   'R'+80H,"EAD"
1649: CC4554  	        DB   'L'+80H,"ET"
164C: C74F544F	        DB   'G'+80H,"OTO"
1650: D2554E  	        DB   'R'+80H,"UN"
1653: C946    	        DB   'I'+80H,"F"
1655: D2455354	        DB   'R'+80H,"ESTORE"
1659: 4F5245  	
165C: C74F5355	        DB   'G'+80H,"OSUB"
1660: 42      	
1661: D2455455	        DB   'R'+80H,"ETURN"
1665: 524E    	
1667: D2454D  	        DB   'R'+80H,"EM"
166A: D3544F50	        DB   'S'+80H,"TOP"
166E: CF5554  	        DB   'O'+80H,"UT"
1671: CF4E    	        DB   'O'+80H,"N"
1673: CE554C4C	        DB   'N'+80H,"ULL"
1677: D7414954	        DB   'W'+80H,"AIT"
167B: C44546  	        DB   'D'+80H,"EF"
167E: D04F4B45	        DB   'P'+80H,"OKE"
1682: C44F4B45	        DB   'D'+80H,"OKE"
1686: D3435245	        DB   'S'+80H,"CREEN"
168A: 454E    	
168C: CC494E45	        DB   'L'+80H,"INES"
1690: 53      	
1691: C34C53  	        DB   'C'+80H,"LS"
1694: D7494454	        DB   'W'+80H,"IDTH"
1698: 48      	
1699: CD4F4E49	        DB   'M'+80H,"ONITOR"
169D: 544F52  	
16A0: D34554  	        DB   'S'+80H,"ET"
16A3: D2455345	        DB   'R'+80H,"ESET"
16A7: 54      	
16A8: D052494E	        DB   'P'+80H,"RINT"
16AC: 54      	
16AD: C34F4E54	        DB   'C'+80H,"ONT"
16B1: CC495354	        DB   'L'+80H,"IST"
16B5: C34C4541	        DB   'C'+80H,"LEAR"
16B9: 52      	
16BA: C44952  	        DB   'D'+80H,"IR"
16BD: C4454C  	        DB   'D'+80H,"EL"
16C0: CC4F4144	        DB   'L'+80H,"OAD"
16C4: D3415645	        DB   'S'+80H,"AVE"
16C8: C34F4C4F	        DB   'C'+80H,"OLOR"
16CC: 52      	
16CD: C94E5645	        DB   'I'+80H,"NVERSE"
16D1: 525345  	
16D4: C64C4153	        DB   'F'+80H,"LASH"
16D8: 48      	
16D9: CE4F524D	        DB   'N'+80H,"ORMAL"
16DD: 414C    	
16DF: CE4557  	        DB   'N'+80H,"EW"
              	
16E2: D4414228	        DB   'T'+80H,"AB("
16E6: D44F    	        DB   'T'+80H,"O"
16E8: C64E    	        DB   'F'+80H,"N"
16EA: D3504328	        DB   'S'+80H,"PC("
16EE: D448454E	        DB   'T'+80H,"HEN"
16F2: CE4F54  	        DB   'N'+80H,"OT"
16F5: D3544550	        DB   'S'+80H,"TEP"
              	
16F9: AB      	        DB   '+'+80H
16FA: AD      	        DB   '-'+80H
16FB: AA      	        DB   '*'+80H
16FC: AF      	        DB   '/'+80H
16FD: DE      	        DB   '^'+80H
16FE: C14E44  	        DB   'A'+80H,"ND"
1701: CF52    	        DB   'O'+80H,"R"
1703: BE      	        DB   '>'+80H
1704: BD      	        DB   '='+80H
1705: BC      	        DB   '<'+80H
              	
1706: D3474E  	        DB   'S'+80H,"GN"
1709: C94E54  	        DB   'I'+80H,"NT"
170C: C14253  	        DB   'A'+80H,"BS"
170F: D55352  	        DB   'U'+80H,"SR"
1712: C65245  	        DB   'F'+80H,"RE"
1715: C94E50  	        DB   'I'+80H,"NP"
1718: D04F53  	        DB   'P'+80H,"OS"
171B: C94E4B45	        DB   'I'+80H,"NKEY"
171F: 59      	
1720: D35152  	        DB   'S'+80H,"QR"
1723: D24E44  	        DB   'R'+80H,"ND"
1726: CC4F47  	        DB   'L'+80H,"OG"
1729: C55850  	        DB   'E'+80H,"XP"
172C: C34F53  	        DB   'C'+80H,"OS"
172F: D3494E  	        DB   'S'+80H,"IN"
1732: D4414E  	        DB   'T'+80H,"AN"
1735: C1544E  	        DB   'A'+80H,"TN"
1738: D045454B	        DB   'P'+80H,"EEK"
173C: C445454B	        DB   'D'+80H,"EEK"
1740: D04F494E	        DB   'P'+80H,"OINT"
1744: 54      	
1745: CC454E  	        DB   'L'+80H,"EN"
1748: D3545224	        DB   'S'+80H,"TR$"
174C: D6414C  	        DB   'V'+80H,"AL"
174F: C15343  	        DB   'A'+80H,"SC"
1752: C3485224	        DB   'C'+80H,"HR$"
1756: C8455824	        DB   'H'+80H,"EX$"
175A: C2494E24	        DB   'B'+80H,"IN$"
175E: CC454654	        DB   'L'+80H,"EFT$"
1762: 24      	
1763: D2494748	        DB   'R'+80H,"IGHT$"
1767: 5424    	
1769: CD494424	        DB   'M'+80H,"ID$"
176D: 80      	        DB   80H             ; End of list marker
              	
              	; KEYWORD ADDRESS TABLE
              	
176E: 761D    	WORDTB: DW   PEND
1770: 6E1C    	        DW   FOR
1772: 4E21    	        DW   NEXT
1774: C31E    	        DW   DATA
1776: 5520    	        DW   INPUT
1778: 8A23    	        DW   DIM
177A: 8420    	        DW   READ
177C: DA1E    	        DW   LET
177E: 801E    	        DW   GOTO
1780: 631E    	        DW   RUN
1782: 521F    	        DW   IFF
1784: 371D    	        DW   RESTOR
1786: 6F1E    	        DW   GOSUB
1788: 9E1E    	        DW   RETURN
178A: C51E    	        DW   REM
178C: 741D    	        DW   STOP
178E: D328    	        DW   POUT
1790: 341F    	        DW   ON
1792: B51D    	        DW   NULL
1794: D928    	        DW   WAIT
1796: 7825    	        DW   DEF
1798: 2229    	        DW   POKE
179A: 2331    	        DW   DOKE
179C: 7730    	        DW   SCREEN
179E: 0931    	        DW   LINES
17A0: 4330    	        DW   CLSBAS
17A2: 0131    	        DW   WIDTH
17A4: B233    	        DW   MONITR
17A6: 9980    	        DW   PSET
17A8: 9C80    	        DW   RESET
17AA: 761F    	        DW   PRINT
17AC: A21D    	        DW   CONT
17AE: E61B    	        DW   LIST
17B0: 1D1E    	        DW   CLEAR
17B2: 3A31    	        DW   DIR
17B4: 4031    	        DW   DELETE
17B6: 2F32    	        DW   MSBASIC_LOAD
17B8: 5B31    	        DW   MSBASIC_SAVE
17BA: AA30    	        DW   COLOR
17BC: 5030    	        DW   INVERSEBAS
17BE: 5D30    	        DW   FLASHBAS
17C0: 6A30    	        DW   NORMALBAS
17C2: DE19    	        DW   NEW
              	
              	; RESERVED WORD TOKEN VALUES
              	
0080:         	ZEND    EQU    080H            ; END
0081:         	ZFOR    EQU    081H            ; FOR
0083:         	ZDATA   EQU    083H            ; DATA
0088:         	ZGOTO   EQU    088H            ; GOTO
008C:         	ZGOSUB  EQU    08CH            ; GOSUB
008E:         	ZREM    EQU    08EH            ; REM
009E:         	ZPRINT  EQU    09EH            ; PRINT
00AA:         	ZNEW    EQU    0AAH            ; NEW
              	
00AB:         	ZTAB    EQU    0ABH            ; TAB
00AC:         	ZTO     EQU    0ACH            ; TO
00AD:         	ZFN     EQU    0ADH            ; FN
00AE:         	ZSPC    EQU    0AEH            ; SPC
00AF:         	ZTHEN   EQU    0AFH            ; THEN
00B0:         	ZNOT    EQU    0B0H            ; NOT
00B1:         	ZSTEP   EQU    0B1H            ; STEP
              	
00B2:         	ZPLUS   EQU    0B2H            ; +
00B3:         	ZMINUS  EQU    0B3H            ; -
00B4:         	ZTIMES  EQU    0B4H            ; *
00B5:         	ZDIV    EQU    0B5H            ; /
00B8:         	ZOR     EQU    0B8H            ; OR
00B9:         	ZGTR    EQU    0B9H            ; >
00BA:         	ZEQUAL  EQU    0BAH            ; M
00BB:         	ZLTH    EQU    0BBH            ; <
00BC:         	ZSGN    EQU    0BCH            ; SGN
00CE:         	ZPOINT  EQU    0CEH            ; POINT
00D6:         	ZLEFT   EQU    0D4H +2         ; LEFT$
              	
              	; ARITHMETIC PRECEDENCE TABLE
              	
17C4: 79      	PRITAB: DB   79H             ; Precedence value
17C5: 0C2D    	        DW   PADD            ; FPREG = <last> + FPREG
              	
17C7: 79      	        DB   79H             ; Precedence value
17C8: 4029    	        DW   PSUB            ; FPREG = <last> - FPREG
              	
17CA: 7C      	        DB   7CH             ; Precedence value
17CB: 7E2A    	        DW   MULT            ; PPREG = <last> * FPREG
              	
17CD: 7C      	        DB   7CH             ; Precedence value
17CE: DF2A    	        DW   DIV             ; FPREG = <last> / FPREG
              	
17D0: 7F      	        DB   7FH             ; Precedence value
17D1: 2D2E    	        DW   POWER           ; FPREG = <last> ^ FPREG
              	
17D3: 50      	        DB   50H             ; Precedence value
17D4: E322    	        DW   PAND            ; FPREG = <last> AND FPREG
              	
17D6: 46      	        DB   46H             ; Precedence value
17D7: E222    	        DW   POR             ; FPREG = <last> OR FPREG
              	
              	; BASIC ERROR CODE LIST
              	
17D9: 4E46    	ERRORS: DB   "NF"            ; NEXT without FOR
17DB: 534E    	        DB   "SN"            ; Syntax error
17DD: 5247    	        DB   "RG"            ; RETURN without GOSUB
17DF: 4F44    	        DB   "OD"            ; Out of DATA
17E1: 4643    	        DB   "FC"            ; Illegal function call
17E3: 4F56    	        DB   "OV"            ; Overflow error
17E5: 4F4D    	        DB   "OM"            ; Out of memory
17E7: 554C    	        DB   "UL"            ; Undefined line
17E9: 4253    	        DB   "BS"            ; Bad subscript
17EB: 4444    	        DB   "DD"            ; Re-DIMensioned array
17ED: 2F30    	        DB   "/0"            ; Division by zero
17EF: 4944    	        DB   "ID"            ; Illegal direct
17F1: 544D    	        DB   "TM"            ; Type mis-match
17F3: 4F53    	        DB   "OS"            ; Out of string space
17F5: 4C53    	        DB   "LS"            ; String too long
17F7: 5354    	        DB   "ST"            ; String formula too complex
17F9: 434E    	        DB   "CN"            ; Can't CONTinue
17FB: 5546    	        DB   "UF"            ; Undefined FN function
17FD: 4D4F    	        DB   "MO"            ; Missing operand
17FF: 4858    	        DB   "HX"            ; HEX error
1801: 424E    	        DB   "BN"            ; BIN error
              	
              	; INITIALISATION TABLE -------------------------------------------------------
              	
1803: C39B15  	INITAB: JP      WARMST          ; Warm start jump
1806: C3F31D  	        JP      FCERR           ; "USR (X)" jump (Set to Error)
1809: D300    	        OUT     (0),A           ; "OUT p,n" skeleton
180B: C9      	        RET
180C: D600    	        SUB     0               ; Division support routine
180E: 6F      	        LD      L,A
180F: 7C      	        LD      A,H
1810: DE00    	        SBC     A,0
1812: 67      	        LD      H,A
1813: 78      	        LD      A,B
1814: DE00    	        SBC     A,0
1816: 47      	        LD      B,A
1817: 3E00    	        LD      A,0
1819: C9      	        RET
181A: 000000  	        DB   0,0,0                   ; Random number seed table used by RND
181D: 354ACA99	        DB   035H,04AH,0CAH,099H     ;-2.65145E+07
1821: 391C7698	        DB   039H,01CH,076H,098H     ; 1.61291E+07
1825: 2295B398	        DB   022H,095H,0B3H,098H     ;-1.17691E+07
1829: 0ADD4798	        DB   00AH,0DDH,047H,098H     ; 1.30983E+07
182D: 53D19999	        DB   053H,0D1H,099H,099H     ;-2-01612E+07
1831: 0A1A9F98	        DB   00AH,01AH,09FH,098H     ;-1.04269E+07
1835: 65BCCD98	        DB   065H,0BCH,0CDH,098H     ;-1.34831E+07
1839: D6773E98	        DB   0D6H,077H,03EH,098H     ; 1.24825E+07
183D: 52C74F80	        DB   052H,0C7H,04FH,080H     ; Last random number
1841: DB00    	        IN      A,(0)           ; INP (x) skeleton
1843: C9      	        RET
1844: 01      	        DB   1               ; POS (x) number (1)
1845: FF      	        DB   255             ; Terminal width (255 = no auto CRLF)
1846: 38      	        DB   56              ; Width for commas (5 columns)
1847: 00      	        DB   0               ; No nulls after input bytes
1848: 00      	        DB   0               ; Output enabled (^O off)
1849: 1400    	        DW   20              ; Initial lines counter
184B: 1400    	        DW   20              ; Initial lines number
184D: 0000    	        DW   0               ; Array load/save check sum
184F: 00      	        DB   0               ; Break not by NMI
1850: 00      	        DB   0               ; Break flag
1851: C3171B  	        JP      TTYLIN          ; Input reflection (set to TTY)
1854: C30000  	        JP      $0000           ; POINT reflection unused
1857: C30000  	        JP      $0000           ; SET reflection
185A: C30000  	        JP      $0000          	; RESET reflection
185D: A281    	        DW   STLOOK          ; Temp string space
185F: FEFF    	        DW   -2              ; Current line number (cold)
1861: 3F81    	        DW   PROGST+1        ; Start of program text
1863:         	INITBE:                         
              	
              	; END OF INITIALISATION TABLE ---------------------------------------------------
              	
1863: 20457272	ERRMSG: DB   " Error",0
1867: 6F7200  	
186A: 20696E20	INMSG:  DB   " in ",0
186E: 00      	
186E:         	ZERBYT  EQU    $-1             ; A zero byte
186F: 4F6B0D0A	OKMSG:  DB   "Ok",CR,LF,0,0
1873: 0000    	
1875: 42726561	BRKMSG: DB   "Break",0
1879: 6B00    	
              	
187B: 210400  	BAKSTK: LD      HL,4            ; Look for "FOR" block with
187E: 39      	        ADD     HL,SP           ; same index as specified
187F: 7E      	LOKFOR: LD      A,(HL)          ; Get block ID
1880: 23      	        INC     HL              ; Point to index address
1881: FE81    	        CP      ZFOR            ; Is it a "FOR" token
1883: C0      	        RET     NZ              ; No - exit
1884: 4E      	        LD      C,(HL)          ; BC = Address of "FOR" index
1885: 23      	        INC     HL
1886: 46      	        LD      B,(HL)
1887: 23      	        INC     HL              ; Point to sign of STEP
1888: E5      	        PUSH    HL              ; Save pointer to sign
1889: 69      	        LD      L,C             ; HL = address of "FOR" index
188A: 60      	        LD      H,B
188B: 7A      	        LD      A,D             ; See if an index was specified
188C: B3      	        OR      E               ; DE = 0 if no index specified
188D: EB      	        EX      DE,HL           ; Specified index into HL
188E: CA9518  	        JP      Z,INDFND        ; Skip if no index given
1891: EB      	        EX      DE,HL           ; Index back into DE
1892: CD9A1B  	        CALL    CPDEHL          ; Compare index with one given
1895: 010D00  	INDFND: LD      BC,16-3         ; Offset to next block
1898: E1      	        POP     HL              ; Restore pointer to sign
1899: C8      	        RET     Z               ; Return if block found
189A: 09      	        ADD     HL,BC           ; Point to next block
189B: C37F18  	        JP      LOKFOR          ; Keep on looking
              	
189E: CDB818  	MOVUP:  CALL    ENFMEM          ; See if enough memory
18A1: C5      	MOVSTR: PUSH    BC              ; Save end of source
18A2: E3      	        EX      (SP),HL         ; Swap source and dest" end
18A3: C1      	        POP     BC              ; Get end of destination
18A4: CD9A1B  	MOVLP:  CALL    CPDEHL          ; See if list moved
18A7: 7E      	        LD      A,(HL)          ; Get byte
18A8: 02      	        LD      (BC),A          ; Move it
18A9: C8      	        RET     Z               ; Exit if all done
18AA: 0B      	        DEC     BC              ; Next byte to move to
18AB: 2B      	        DEC     HL              ; Next byte to move
18AC: C3A418  	        JP      MOVLP           ; Loop until all bytes moved
              	
18AF: E5      	CHKSTK: PUSH    HL              ; Save code string address
18B0: 2A1F81  	        LD      HL,(ARREND)     ; Lowest free memory
18B3: 0600    	        LD      B,0             ; BC = Number of levels to test
18B5: 09      	        ADD     HL,BC           ; 2 Bytes for each level
18B6: 09      	        ADD     HL,BC
18B7: 3E      	        DB   3EH             ; Skip "PUSH HL"
18B8: E5      	ENFMEM: PUSH    HL              ; Save code string address
18B9: 3ED0    	        LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
18BB: 95      	        SUB     L
18BC: 6F      	        LD      L,A
18BD: 3EFF    	        LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
18BF: 9C      	        SBC     A,H
18C0: DAC718  	        JP      C,OMERR         ; Not enough - ?OM Error
18C3: 67      	        LD      H,A
18C4: 39      	        ADD     HL,SP           ; Test if stack is overflowed
18C5: E1      	        POP     HL              ; Restore code string address
18C6: D8      	        RET     C               ; Return if enough mmory
18C7: 1E0C    	OMERR:  LD      E,OM            ; ?OM Error
18C9: C3E618  	        JP      ERROR
              	
18CC: 2A0E81  	DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
18CF: 22A180  	        LD      (LINEAT),HL     ; Save as current line
18D2: 1E02    	SNERR:  LD      E,SN            ; ?SN Error
18D4: 01      	        DB   01H             ; Skip "LD E,DZ"
18D5: 1E14    	DZERR:  LD      E,DZ            ; ?/0 Error
18D7: 01      	        DB   01H             ; Skip "LD E,NF"
18D8: 1E00    	NFERR:  LD      E,NF            ; ?NF Error
18DA: 01      	        DB   01H             ; Skip "LD E,DD"
18DB: 1E12    	DDERR:  LD      E,DD            ; ?DD Error
18DD: 01      	        DB   01H             ; Skip "LD E,UF"
18DE: 1E22    	UFERR:  LD      E,UF            ; ?UF Error
18E0: 01      	        DB   01H             ; Skip "LD E,OV
18E1: 1E0A    	OVERR:  LD      E,OV            ; ?OV Error
18E3: 01      	        DB   01H             ; Skip "LD E,TM"
18E4: 1E18    	TMERR:  LD      E,TM            ; ?TM Error
              	
18E6: CD041A  	ERROR:  CALL    CLREG           ; Clear registers and stack
18E9: 328A80  	        LD      (CTLOFG),A      ; Enable output (A is 0)
18EC: CDC71F  	        CALL    STTLIN          ; Start new line
18EF: 21D917  	        LD      HL,ERRORS       ; Point to error codes
18F2: 57      	        LD      D,A             ; D = 0 (A is 0)
18F3: 3E3F    	        LD      A,'?'
18F5: CDAB1B  	        CALL    OUTC            ; Output '?'
18F8: 19      	        ADD     HL,DE           ; Offset to correct error code
18F9: 7E      	        LD      A,(HL)          ; First character
18FA: CDAB1B  	        CALL    OUTC            ; Output it
18FD: CD271D  	        CALL    GETCHR          ; Get next character
1900: CDAB1B  	        CALL    OUTC            ; Output it
1903: 216318  	        LD      HL,ERRMSG       ; "Error" message
1906: CD8226  	ERRIN:  CALL    PRS             ; Output message
1909: 2AA180  	        LD      HL,(LINEAT)     ; Get line of error
190C: 11FEFF  	        LD      DE,-2           ; Cold start error if -2
190F: CD9A1B  	        CALL    CPDEHL          ; See if cold start error
1912: CA0815  	        JP      Z,CSTART        ; Cold start error - Restart
1915: 7C      	        LD      A,H             ; Was it a direct error?
1916: A5      	        AND     L               ; Line = -1 if direct error
1917: 3C      	        INC     A
1918: C41D2D  	        CALL    NZ,LINEIN       ; No - output line of error
191B: 3E      	        DB   3EH             ; Skip "POP BC"
191C: C1      	POPNOK: POP     BC              ; Drop address in input buffer
              	
191D: AF      	PRNTOK: XOR     A               ; Output "Ok" and get command
191E: 328A80  	        LD      (CTLOFG),A      ; Enable output
1921: CDC71F  	        CALL    STTLIN          ; Start new line
1924: 216F18  	        LD      HL,OKMSG        ; "Ok" message
1927: CD8226  	        CALL    PRS             ; Output "Ok"
192A: 21FFFF  	GETCMD: LD      HL,-1           ; Flag direct mode
192D: 22A180  	        LD      (LINEAT),HL     ; Save as current line
1930: CD171B  	        CALL    GETLIN          ; Get an input line
1933: DA2A19  	        JP      C,GETCMD        ; Get line again if break
1936: CD271D  	        CALL    GETCHR          ; Get first character
1939: 3C      	        INC     A               ; Test if end of line
193A: 3D      	        DEC     A               ; Without affecting Carry
193B: CA2A19  	        JP      Z,GETCMD        ; Nothing entered - Get another
193E: F5      	        PUSH    AF              ; Save Carry status
193F: CDF81D  	        CALL    ATOH            ; Get line number into DE
1942: D5      	        PUSH    DE              ; Save line number
1943: CD2E1A  	        CALL    CRUNCH          ; Tokenise rest of line
1946: 47      	        LD      B,A             ; Length of tokenised line
1947: D1      	        POP     DE              ; Restore line number
1948: F1      	        POP     AF              ; Restore Carry
1949: D2071D  	        JP      NC,EXCUTE       ; No line number - Direct mode
194C: D5      	        PUSH    DE              ; Save line number
194D: C5      	        PUSH    BC              ; Save length of tokenised line
194E: AF      	        XOR     A
194F: 321181  	        LD      (LSTBIN),A      ; Clear last byte input
1952: CD271D  	        CALL    GETCHR          ; Get next character
1955: B7      	        OR      A               ; Set flags
1956: F5      	        PUSH    AF              ; And save them
1957: CDBE19  	        CALL    SRCHLN          ; Search for line number in DE
195A: DA6319  	        JP      C,LINFND        ; Jump if line found
195D: F1      	        POP     AF              ; Get status
195E: F5      	        PUSH    AF              ; And re-save
195F: CA991E  	        JP      Z,ULERR         ; Nothing after number - Error
1962: B7      	        OR      A               ; Clear Carry
1963: C5      	LINFND: PUSH    BC              ; Save address of line in prog
1964: D27A19  	        JP      NC,INEWLN       ; Line not found - Insert new
1967: EB      	        EX      DE,HL           ; Next line address in DE
1968: 2A1B81  	        LD      HL,(PROGND)     ; End of program
196B: 1A      	SFTPRG: LD      A,(DE)          ; Shift rest of program down
196C: 02      	        LD      (BC),A
196D: 03      	        INC     BC              ; Next destination
196E: 13      	        INC     DE              ; Next source
196F: CD9A1B  	        CALL    CPDEHL          ; All done?
1972: C26B19  	        JP      NZ,SFTPRG       ; More to do
1975: 60      	        LD      H,B             ; HL - New end of program
1976: 69      	        LD      L,C
1977: 221B81  	        LD      (PROGND),HL     ; Update end of program
              	
197A: D1      	INEWLN: POP     DE              ; Get address of line,
197B: F1      	        POP     AF              ; Get status
197C: CAA119  	        JP      Z,SETPTR        ; No text - Set up pointers
197F: 2A1B81  	        LD      HL,(PROGND)     ; Get end of program
1982: E3      	        EX      (SP),HL         ; Get length of input line
1983: C1      	        POP     BC              ; End of program to BC
1984: 09      	        ADD     HL,BC           ; Find new end
1985: E5      	        PUSH    HL              ; Save new end
1986: CD9E18  	        CALL    MOVUP           ; Make space for line
1989: E1      	        POP     HL              ; Restore new end
198A: 221B81  	        LD      (PROGND),HL     ; Update end of program pointer
198D: EB      	        EX      DE,HL           ; Get line to move up in HL
198E: 74      	        LD      (HL),H          ; Save MSB
198F: D1      	        POP     DE              ; Get new line number
1990: 23      	        INC     HL              ; Skip pointer
1991: 23      	        INC     HL
1992: 73      	        LD      (HL),E          ; Save LSB of line number
1993: 23      	        INC     HL
1994: 72      	        LD      (HL),D          ; Save MSB of line number
1995: 23      	        INC     HL              ; To first byte in line
1996: 11A680  	        LD      DE,BUFFER       ; Copy buffer to program
1999: 1A      	MOVBUF: LD      A,(DE)          ; Get source
199A: 77      	        LD      (HL),A          ; Save destinations
199B: 23      	        INC     HL              ; Next source
199C: 13      	        INC     DE              ; Next destination
199D: B7      	        OR      A               ; Done?
199E: C29919  	        JP      NZ,MOVBUF       ; No - Repeat
19A1: CDEA19  	SETPTR: CALL    RUNFST          ; Set line pointers
19A4: 23      	        INC     HL              ; To LSB of pointer
19A5: EB      	        EX      DE,HL           ; Address to DE
19A6: 62      	PTRLP:  LD      H,D             ; Address to HL
19A7: 6B      	        LD      L,E
19A8: 7E      	        LD      A,(HL)          ; Get LSB of pointer
19A9: 23      	        INC     HL              ; To MSB of pointer
19AA: B6      	        OR      (HL)            ; Compare with MSB pointer
19AB: CA2A19  	        JP      Z,GETCMD        ; Get command line if end
19AE: 23      	        INC     HL              ; To LSB of line number
19AF: 23      	        INC     HL              ; Skip line number
19B0: 23      	        INC     HL              ; Point to first byte in line
19B1: AF      	        XOR     A               ; Looking for 00 byte
19B2: BE      	FNDEND: CP      (HL)            ; Found end of line?
19B3: 23      	        INC     HL              ; Move to next byte
19B4: C2B219  	        JP      NZ,FNDEND       ; No - Keep looking
19B7: EB      	        EX      DE,HL           ; Next line address to HL
19B8: 73      	        LD      (HL),E          ; Save LSB of pointer
19B9: 23      	        INC     HL
19BA: 72      	        LD      (HL),D          ; Save MSB of pointer
19BB: C3A619  	        JP      PTRLP           ; Do next line
              	
19BE: 2AA380  	SRCHLN: LD      HL,(BASTXT)     ; Start of program text
19C1: 44      	SRCHLP: LD      B,H             ; BC = Address to look at
19C2: 4D      	        LD      C,L
19C3: 7E      	        LD      A,(HL)          ; Get address of next line
19C4: 23      	        INC     HL
19C5: B6      	        OR      (HL)            ; End of program found?
19C6: 2B      	        DEC     HL
19C7: C8      	        RET     Z               ; Yes - Line not found
19C8: 23      	        INC     HL
19C9: 23      	        INC     HL
19CA: 7E      	        LD      A,(HL)          ; Get LSB of line number
19CB: 23      	        INC     HL
19CC: 66      	        LD      H,(HL)          ; Get MSB of line number
19CD: 6F      	        LD      L,A
19CE: CD9A1B  	        CALL    CPDEHL          ; Compare with line in DE
19D1: 60      	        LD      H,B             ; HL = Start of this line
19D2: 69      	        LD      L,C
19D3: 7E      	        LD      A,(HL)          ; Get LSB of next line address
19D4: 23      	        INC     HL
19D5: 66      	        LD      H,(HL)          ; Get MSB of next line address
19D6: 6F      	        LD      L,A             ; Next line to HL
19D7: 3F      	        CCF
19D8: C8      	        RET     Z               ; Lines found - Exit
19D9: 3F      	        CCF
19DA: D0      	        RET     NC              ; Line not found,at line after
19DB: C3C119  	        JP      SRCHLP          ; Keep looking
              	
19DE: C0      	NEW:    RET     NZ              ; Return if any more on line
19DF: 2AA380  	CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
19E2: AF      	        XOR     A               ; Set program area to empty
19E3: 77      	        LD      (HL),A          ; Save LSB = 00
19E4: 23      	        INC     HL
19E5: 77      	        LD      (HL),A          ; Save MSB = 00
19E6: 23      	        INC     HL
19E7: 221B81  	        LD      (PROGND),HL     ; Set program end
              	
19EA: 2AA380  	RUNFST: LD      HL,(BASTXT)     ; Clear all variables
19ED: 2B      	        DEC     HL
              	
19EE: 221381  	INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
19F1: 2AF480  	        LD      HL,(LSTRAM)     ; Get end of RAM
19F4: 220881  	        LD      (STRBOT),HL     ; Clear string space
19F7: AF      	        XOR     A
19F8: CD371D  	        CALL    RESTOR          ; Reset DATA pointers
19FB: 2A1B81  	        LD      HL,(PROGND)     ; Get end of program
19FE: 221D81  	        LD      (VAREND),HL     ; Clear variables
1A01: 221F81  	        LD      (ARREND),HL     ; Clear arrays
              	
1A04: C1      	CLREG:  POP     BC              ; Save return address
1A05: 2A9F80  	        LD      HL,(STRSPC)     ; Get end of working RAN
1A08: F9      	        LD      SP,HL           ; Set stack
1A09: 21F880  	        LD      HL,TMSTPL       ; Temporary string pool
1A0C: 22F680  	        LD      (TMSTPT),HL     ; Reset temporary string ptr
1A0F: AF      	        XOR     A               ; A = 00
1A10: 6F      	        LD      L,A             ; HL = 0000
1A11: 67      	        LD      H,A
1A12: 221981  	        LD      (CONTAD),HL     ; No CONTinue
1A15: 321081  	        LD      (FORFLG),A      ; Clear FOR flag
1A18: 222381  	        LD      (FNRGNM),HL     ; Clear FN argument
1A1B: E5      	        PUSH    HL              ; HL = 0000
1A1C: C5      	        PUSH    BC              ; Put back return
1A1D: 2A1381  	DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
1A20: C9      	        RET                     ; Return to execution driver
              	
1A21: 3E3F    	PROMPT: LD      A,'?'           ; '?'
1A23: CDAB1B  	        CALL    OUTC            ; Output character
1A26: 3E20    	        LD      A,' '           ; Space
1A28: CDAB1B  	        CALL    OUTC            ; Output character
1A2B: C39380  	        JP      RINPUT          ; Get input line
              	
1A2E: AF      	CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
1A2F: 32F380  	        LD      (DATFLG),A      ; Reset literal flag
1A32: 0E05    	        LD      C,2+3           ; 2 byte number and 3 nulls
1A34: 11A680  	        LD      DE,BUFFER       ; Start of input buffer
1A37: 7E      	CRNCLP: LD      A,(HL)          ; Get byte
1A38: FE20    	        CP      ' '             ; Is it a space?
1A3A: CAB61A  	        JP      Z,MOVDIR        ; Yes - Copy direct
1A3D: 47      	        LD      B,A             ; Save character
1A3E: FE22    	        CP      '"'             ; Is it a quote?
1A40: CAD61A  	        JP      Z,CPYLIT        ; Yes - Copy literal string
1A43: B7      	        OR      A               ; Is it end of buffer?
1A44: CADD1A  	        JP      Z,ENDBUF        ; Yes - End buffer
1A47: 3AF380  	        LD      A,(DATFLG)      ; Get data type
1A4A: B7      	        OR      A               ; Literal?
1A4B: 7E      	        LD      A,(HL)          ; Get byte to copy
1A4C: C2B61A  	        JP      NZ,MOVDIR       ; Literal - Copy direct
1A4F: FE3F    	        CP      '?'             ; Is it '?' short for PRINT
1A51: 3E9E    	        LD      A,ZPRINT        ; "PRINT" token
1A53: CAB61A  	        JP      Z,MOVDIR        ; Yes - replace it
1A56: 7E      	        LD      A,(HL)          ; Get byte again
1A57: FE30    	        CP      '0'             ; Is it less than '0'
1A59: DA611A  	        JP      C,FNDWRD        ; Yes - Look for reserved words
1A5C: FE3C    	        CP      60; ";"+1           ; Is it "0123456789:;" ?
1A5E: DAB61A  	        JP      C,MOVDIR        ; Yes - copy it direct
1A61: D5      	FNDWRD: PUSH    DE              ; Look for reserved words
1A62: 112E16  	        LD      DE,WORDS-1      ; Point to table
1A65: C5      	        PUSH    BC              ; Save count
1A66: 01B21A  	        LD      BC,RETNAD       ; Where to return to
1A69: C5      	        PUSH    BC              ; Save return address
1A6A: 067F    	        LD      B,ZEND-1        ; First token value -1
1A6C: 7E      	        LD      A,(HL)          ; Get byte
1A6D: FE61    	        CP      'a'             ; Less than 'a' ?
1A6F: DA7A1A  	        JP      C,SEARCH        ; Yes - search for words
1A72: FE7B    	        CP      'z'+1           ; Greater than 'z' ?
1A74: D27A1A  	        JP      NC,SEARCH       ; Yes - search for words
1A77: E65F    	        AND     01011111B       ; Force upper case
1A79: 77      	        LD      (HL),A          ; Replace byte
1A7A: 4E      	SEARCH: LD      C,(HL)          ; Search for a word
1A7B: EB      	        EX      DE,HL
1A7C: 23      	GETNXT: INC     HL              ; Get next reserved word
1A7D: B6      	        OR      (HL)            ; Start of word?
1A7E: F27C1A  	        JP      P,GETNXT        ; No - move on
1A81: 04      	        INC     B               ; Increment token value
1A82: 7E      	        LD      A, (HL)         ; Get byte from table
1A83: E67F    	        AND     01111111B       ; Strip bit 7
1A85: C8      	        RET     Z               ; Return if end of list
1A86: B9      	        CP      C               ; Same character as in buffer?
1A87: C27C1A  	        JP      NZ,GETNXT       ; No - get next word
1A8A: EB      	        EX      DE,HL
1A8B: E5      	        PUSH    HL              ; Save start of word
              	
1A8C: 13      	NXTBYT: INC     DE              ; Look through rest of word
1A8D: 1A      	        LD      A,(DE)          ; Get byte from table
1A8E: B7      	        OR      A               ; End of word ?
1A8F: FAAE1A  	        JP      M,MATCH         ; Yes - Match found
1A92: 4F      	        LD      C,A             ; Save it
1A93: 78      	        LD      A,B             ; Get token value
1A94: FE88    	        CP      ZGOTO           ; Is it "GOTO" token ?
1A96: C29D1A  	        JP      NZ,NOSPC        ; No - Don't allow spaces
1A99: CD271D  	        CALL    GETCHR          ; Get next character
1A9C: 2B      	        DEC     HL              ; Cancel increment from GETCHR
1A9D: 23      	NOSPC:  INC     HL              ; Next byte
1A9E: 7E      	        LD      A,(HL)          ; Get byte
1A9F: FE61    	        CP      'a'             ; Less than 'a' ?
1AA1: DAA61A  	        JP      C,NOCHNG        ; Yes - don't change
1AA4: E65F    	        AND     01011111B       ; Make upper case
1AA6: B9      	NOCHNG: CP      C               ; Same as in buffer ?
1AA7: CA8C1A  	        JP      Z,NXTBYT        ; Yes - keep testing
1AAA: E1      	        POP     HL              ; Get back start of word
1AAB: C37A1A  	        JP      SEARCH          ; Look at next word
              	
1AAE: 48      	MATCH:  LD      C,B             ; Word found - Save token value
1AAF: F1      	        POP     AF              ; Throw away return
1AB0: EB      	        EX      DE,HL
1AB1: C9      	        RET                     ; Return to "RETNAD"
1AB2: EB      	RETNAD: EX      DE,HL           ; Get address in string
1AB3: 79      	        LD      A,C             ; Get token value
1AB4: C1      	        POP     BC              ; Restore buffer length
1AB5: D1      	        POP     DE              ; Get destination address
1AB6: 23      	MOVDIR: INC     HL              ; Next source in buffer
1AB7: 12      	        LD      (DE),A          ; Put byte in buffer
1AB8: 13      	        INC     DE              ; Move up buffer
1AB9: 0C      	        INC     C               ; Increment length of buffer
1ABA: D63A    	        SUB     ':'             ; End of statement?
1ABC: CAC41A  	        JP      Z,SETLIT        ; Jump if multi-statement line
1ABF: FE49    	        CP      ZDATA-3AH       ; Is it DATA statement ?
1AC1: C2C71A  	        JP      NZ,TSTREM       ; No - see if REM
1AC4: 32F380  	SETLIT: LD      (DATFLG),A      ; Set literal flag
1AC7: D654    	TSTREM: SUB     ZREM-3AH        ; Is it REM?
1AC9: C2371A  	        JP      NZ,CRNCLP       ; No - Leave flag
1ACC: 47      	        LD      B,A             ; Copy rest of buffer
1ACD: 7E      	NXTCHR: LD      A,(HL)          ; Get byte
1ACE: B7      	        OR      A               ; End of line ?
1ACF: CADD1A  	        JP      Z,ENDBUF        ; Yes - Terminate buffer
1AD2: B8      	        CP      B               ; End of statement ?
1AD3: CAB61A  	        JP      Z,MOVDIR        ; Yes - Get next one
1AD6: 23      	CPYLIT: INC     HL              ; Move up source string
1AD7: 12      	        LD      (DE),A          ; Save in destination
1AD8: 0C      	        INC     C               ; Increment length
1AD9: 13      	        INC     DE              ; Move up destination
1ADA: C3CD1A  	        JP      NXTCHR          ; Repeat
              	
1ADD: 21A580  	ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
1AE0: 12      	        LD      (DE),A          ; Mark end of buffer (A = 00)
1AE1: 13      	        INC     DE
1AE2: 12      	        LD      (DE),A          ; A = 00
1AE3: 13      	        INC     DE
1AE4: 12      	        LD      (DE),A          ; A = 00
1AE5: C9      	        RET
              	
1AE6: 3A8980  	DODEL:  LD      A,(NULFLG)      ; Get null flag status
1AE9: B7      	        OR      A               ; Is it zero?
1AEA: 3E00    	        LD      A,0             ; Zero A - Leave flags
1AEC: 328980  	        LD      (NULFLG),A      ; Zero null flag
1AEF: C2FA1A  	        JP      NZ,ECHDEL       ; Set - Echo it
1AF2: 05      	        DEC     B               ; Decrement length
1AF3: CA171B  	        JP      Z,GETLIN        ; Get line again if empty
1AF6: CDAB1B  	        CALL    OUTC            ; Output null character
1AF9: 3E      	        DB   3EH             ; Skip "DEC B"
1AFA: 05      	ECHDEL: DEC     B               ; Count bytes in buffer
1AFB: 2B      	        DEC     HL              ; Back space buffer
1AFC: CA0E1B  	        JP      Z,OTKLN         ; No buffer - Try again
1AFF: 7E      	        LD      A,(HL)          ; Get deleted byte
1B00: CDAB1B  	        CALL    OUTC            ; Echo it
1B03: C3201B  	        JP      MORINP          ; Get more input
              	
1B06: 05      	DELCHR: DEC     B               ; Count bytes in buffer
1B07: 2B      	        DEC     HL              ; Back space buffer
1B08: CDAB1B  	        CALL    OUTC            ; Output character in A
1B0B: C2201B  	        JP      NZ,MORINP       ; Not end - Get more
1B0E: CDAB1B  	OTKLN:  CALL    OUTC            ; Output character in A
1B11: CDD41F  	KILIN:  CALL    PRNTCRLF        ; Output CRLF
1B14: C3171B  	        JP      TTYLIN          ; Get line again
              	
1B17:         	GETLIN:
1B17: 21A680  	TTYLIN: LD      HL,BUFFER       ; Get a line by character
1B1A: 0601    	        LD      B,1             ; Set buffer as empty
1B1C: AF      	        XOR     A
1B1D: 328980  	        LD      (NULFLG),A      ; Clear null flag
1B20: CDD51B  	MORINP: CALL    CLOTST          ; Get character and test ^O
1B23: 4F      	        LD      C,A             ; Save character in C
1B24: FE7F    	        CP      DEL             ; Delete character?
1B26: CAE61A  	        JP      Z,DODEL         ; Yes - Process it
1B29: 3A8980  	        LD      A,(NULFLG)      ; Get null flag
1B2C: B7      	        OR      A               ; Test null flag status
1B2D: CA391B  	        JP      Z,PROCES        ; Reset - Process character
1B30: 3E00    	        LD      A,0             ; Set a null
1B32: CDAB1B  	        CALL    OUTC            ; Output null
1B35: AF      	        XOR     A               ; Clear A
1B36: 328980  	        LD      (NULFLG),A      ; Reset null flag
1B39: 79      	PROCES: LD      A,C             ; Get character
1B3A: FE07    	        CP      CTRLG           ; Bell?
1B3C: CA7D1B  	        JP      Z,PUTCTL        ; Yes - Save it
1B3F: FE03    	        CP      CTRLC           ; Is it control "C"?
1B41: CCD41F  	        CALL    Z,PRNTCRLF      ; Yes - Output CRLF
1B44: 37      	        SCF                     ; Flag break
1B45: C8      	        RET     Z               ; Return if control "C"
1B46: FE0D    	        CP      CR              ; Is it enter?
1B48: CACF1F  	        JP      Z,ENDINP        ; Yes - Terminate input
1B4B: FE15    	        CP      CTRLU           ; Is it control "U"?
1B4D: CA111B  	        JP      Z,KILIN         ; Yes - Get another line
1B50: FE40    	        CP      '@'             ; Is it "kill line"?
1B52: CA0E1B  	        JP      Z,OTKLN         ; Yes - Kill line
1B55: FE5F    	        CP      '_'             ; Is it delete?
1B57: CA061B  	        JP      Z,DELCHR        ; Yes - Delete character
1B5A: FE08    	        CP      BKSP            ; Is it backspace?
1B5C: CA061B  	        JP      Z,DELCHR        ; Yes - Delete character
1B5F: FE12    	        CP      CTRLR           ; Is it control "R"?
1B61: C2781B  	        JP      NZ,PUTBUF       ; No - Put in buffer
1B64: C5      	        PUSH    BC              ; Save buffer length
1B65: D5      	        PUSH    DE              ; Save DE
1B66: E5      	        PUSH    HL              ; Save buffer address
1B67: 3600    	        LD      (HL),0          ; Mark end of buffer
1B69: CDC633  	        CALL    OUTNCR          ; Output and do CRLF
1B6C: 21A680  	        LD      HL,BUFFER       ; Point to buffer start
1B6F: CD8226  	        CALL    PRS             ; Output buffer
1B72: E1      	        POP     HL              ; Restore buffer address
1B73: D1      	        POP     DE              ; Restore DE
1B74: C1      	        POP     BC              ; Restore buffer length
1B75: C3201B  	        JP      MORINP          ; Get another character
              	
1B78: FE20    	PUTBUF: CP      ' '             ; Is it a control code?
1B7A: DA201B  	        JP      C,MORINP        ; Yes - Ignore
1B7D: 78      	PUTCTL: LD      A,B             ; Get number of bytes in buffer
1B7E: FE49    	        CP      72+1            ; Test for line overflow
1B80: 3E07    	        LD      A,CTRLG         ; Set a bell
1B82: D2921B  	        JP      NC,OUTNBS       ; Ring bell if buffer full
1B85: 79      	        LD      A,C             ; Get character
1B86: 71      	        LD      (HL),C          ; Save in buffer
1B87: 321181  	        LD      (LSTBIN),A      ; Save last input byte
1B8A: 23      	        INC     HL              ; Move up buffer
1B8B: 04      	        INC     B               ; Increment length
1B8C: CDAB1B  	OUTIT:  CALL    OUTC            ; Output the character entered
1B8F: C3201B  	        JP      MORINP          ; Get another character
              	
1B92: CDAB1B  	OUTNBS: CALL    OUTC            ; Output bell and back over it
1B95: 3E08    	        LD      A,BKSP          ; Set back space
1B97: C38C1B  	        JP      OUTIT           ; Output it and get more
              	
1B9A: 7C      	CPDEHL: LD      A,H             ; Get H
1B9B: 92      	        SUB     D               ; Compare with D
1B9C: C0      	        RET     NZ              ; Different - Exit
1B9D: 7D      	        LD      A,L             ; Get L
1B9E: 93      	        SUB     E               ; Compare with E
1B9F: C9      	        RET                     ; Return status
              	
1BA0: 7E      	CHKSYN: LD      A,(HL)          ; Check syntax of character
1BA1: E3      	        EX      (SP),HL         ; Address of test byte
1BA2: BE      	        CP      (HL)            ; Same as in code string?
1BA3: 23      	        INC     HL              ; Return address
1BA4: E3      	        EX      (SP),HL         ; Put it back
1BA5: CA271D  	        JP      Z,GETCHR        ; Yes - Get next character
1BA8: C3D218  	        JP      SNERR           ; Different - ?SN Error
              	
1BAB: F5      	OUTC:   PUSH    AF              ; Save character
1BAC: 3A8A80  	        LD      A,(CTLOFG)      ; Get control "O" flag
1BAF: B7      	        OR      A               ; Is it set?
1BB0: C2B726  	        JP      NZ,POPAF        ; Yes - don't output
1BB3: F1      	        POP     AF              ; Restore character
1BB4: C5      	        PUSH    BC              ; Save buffer length
1BB5: F5      	        PUSH    AF              ; Save character
1BB6: FE20    	        CP      ' '             ; Is it a control code?
1BB8: DACF1B  	        JP      C,DINPOS        ; Yes - Don't INC POS(X)
1BBB: 3A8780  	        LD      A,(LWIDTH)      ; Get line width
1BBE: 47      	        LD      B,A             ; To B
1BBF: 3AF080  	        LD      A,(CURPOS)      ; Get cursor position
1BC2: 04      	        INC     B               ; Width 255?
1BC3: CACB1B  	        JP      Z,INCLEN        ; Yes - No width limit
1BC6: 05      	        DEC     B               ; Restore width
1BC7: B8      	        CP      B               ; At end of line?
1BC8: CCD41F  	        CALL    Z,PRNTCRLF      ; Yes - output CRLF
1BCB: 3C      	INCLEN: INC     A               ; Move on one character
1BCC: 32F080  	        LD      (CURPOS),A      ; Save new position
1BCF: F1      	DINPOS: POP     AF              ; Restore character
1BD0: C1      	        POP     BC              ; Restore buffer length
1BD1: CDAF33  	        CALL    MONOUT          ; Send it
1BD4: C9      	        RET
              	
1BD5: CD4130  	CLOTST: CALL    GETINP          ; Get input character
1BD8: E67F    	        AND     01111111B       ; Strip bit 7
1BDA: FE0F    	        CP      CTRLO           ; Is it control "O"?
1BDC: C0      	        RET     NZ              ; No don't flip flag
1BDD: 3A8A80  	        LD      A,(CTLOFG)      ; Get flag
1BE0: 2F      	        CPL                     ; Flip it
1BE1: 328A80  	        LD      (CTLOFG),A      ; Put it back
1BE4: AF      	        XOR     A               ; Null character
1BE5: C9      	        RET
              	
1BE6: CDF81D  	LIST:   CALL    ATOH            ; ASCII number to DE
1BE9: C0      	        RET     NZ              ; Return if anything extra
1BEA: C1      	        POP     BC              ; Rubbish - Not needed
1BEB: CDBE19  	        CALL    SRCHLN          ; Search for line number in DE
1BEE: C5      	        PUSH    BC              ; Save address of line
1BEF: CD391C  	        CALL    SETLIN          ; Set up lines counter
1BF2: E1      	LISTLP: POP     HL              ; Restore address of line
1BF3: 4E      	        LD      C,(HL)          ; Get LSB of next line
1BF4: 23      	        INC     HL
1BF5: 46      	        LD      B,(HL)          ; Get MSB of next line
1BF6: 23      	        INC     HL
1BF7: 78      	        LD      A,B             ; BC = 0 (End of program)?
1BF8: B1      	        OR      C
1BF9: CA1D19  	        JP      Z,PRNTOK        ; Yes - Go to command mode
              	        ;CALL    COUNT           ; Count lines
1BFC: CD561D  	        CALL    TSTBRK          ; Test for break key
1BFF: C5      	        PUSH    BC              ; Save address of next line
1C00: CDD41F  	        CALL    PRNTCRLF        ; Output CRLF
1C03: 5E      	        LD      E,(HL)          ; Get LSB of line number
1C04: 23      	        INC     HL
1C05: 56      	        LD      D,(HL)          ; Get MSB of line number
1C06: 23      	        INC     HL
1C07: E5      	        PUSH    HL              ; Save address of line start
1C08: EB      	        EX      DE,HL           ; Line number to HL
1C09: CD252D  	        CALL    PRNTHL          ; Output line number in decimal
1C0C: 3E20    	        LD      A,' '           ; Space after line number
1C0E: E1      	        POP     HL              ; Restore start of line address
1C0F: CDAB1B  	LSTLP2: CALL    OUTC            ; Output character in A
1C12: 7E      	LSTLP3: LD      A,(HL)          ; Get next byte in line
1C13: B7      	        OR      A               ; End of line?
1C14: 23      	        INC     HL              ; To next byte in line
1C15: CAF21B  	        JP      Z,LISTLP        ; Yes - get next line
1C18: F20F1C  	        JP      P,LSTLP2        ; No token - output it
1C1B: D67F    	        SUB     ZEND-1          ; Find and output word
1C1D: 4F      	        LD      C,A             ; Token offset+1 to C
1C1E: 112F16  	        LD      DE,WORDS        ; Reserved word list
1C21: 1A      	FNDTOK: LD      A,(DE)          ; Get character in list
1C22: 13      	        INC     DE              ; Move on to next
1C23: B7      	        OR      A               ; Is it start of word?
1C24: F2211C  	        JP      P,FNDTOK        ; No - Keep looking for word
1C27: 0D      	        DEC     C               ; Count words
1C28: C2211C  	        JP      NZ,FNDTOK       ; Not there - keep looking
1C2B: E67F    	OUTWRD: AND     01111111B       ; Strip bit 7
1C2D: CDAB1B  	        CALL    OUTC            ; Output first character
1C30: 1A      	        LD      A,(DE)          ; Get next character
1C31: 13      	        INC     DE              ; Move on to next
1C32: B7      	        OR      A               ; Is it end of word?
1C33: F22B1C  	        JP      P,OUTWRD        ; No - output the rest
1C36: C3121C  	        JP      LSTLP3          ; Next byte in line
              	
1C39: E5      	SETLIN: PUSH    HL              ; Set up LINES counter
1C3A: 2A8D80  	        LD      HL,(LINESN)     ; Get LINES number
1C3D: 228B80  	        LD      (LINESC),HL     ; Save in LINES counter
1C40: E1      	        POP     HL
1C41: C9      	        RET
              	
1C42: E5      	COUNT:  PUSH    HL              ; Save code string address
1C43: D5      	        PUSH    DE
1C44: 2A8B80  	        LD      HL,(LINESC)     ; Get LINES counter
1C47: 11FFFF  	        LD      DE,-1
1C4A: ED5A    	        ADC     HL,DE           ; Decrement
1C4C: 228B80  	        LD      (LINESC),HL     ; Put it back
1C4F: D1      	        POP     DE
1C50: E1      	        POP     HL              ; Restore code string address
1C51: F0      	        RET     P               ; Return if more lines to go
1C52: E5      	        PUSH    HL              ; Save code string address
1C53: 2A8D80  	        LD      HL,(LINESN)     ; Get LINES number
1C56: 228B80  	        LD      (LINESC),HL     ; Reset LINES counter
1C59: CD4130  	        CALL    GETINP          ; Get input character
1C5C: FE03    	        CP      CTRLC           ; Is it control "C"?
1C5E: CA651C  	        JP      Z,RSLNBK        ; Yes - Reset LINES and break
1C61: E1      	        POP     HL              ; Restore code string address
1C62: C3421C  	        JP      COUNT           ; Keep on counting
              	
1C65: 2A8D80  	RSLNBK: LD      HL,(LINESN)     ; Get LINES number
1C68: 228B80  	        LD      (LINESC),HL     ; Reset LINES counter
1C6B: C39E15  	        JP      BRKRET          ; Go and output "Break"
              	
1C6E: 3E64    	FOR:    LD      A,64H           ; Flag "FOR" assignment
1C70: 321081  	        LD      (FORFLG),A      ; Save "FOR" flag
1C73: CDDA1E  	        CALL    LET             ; Set up initial index
1C76: C1      	        POP     BC              ; Drop RETurn address
1C77: E5      	        PUSH    HL              ; Save code string address
1C78: CDC31E  	        CALL    DATA            ; Get next statement address
1C7B: 220C81  	        LD      (LOOPST),HL     ; Save it for start of loop
1C7E: 210200  	        LD      HL,2            ; Offset for "FOR" block
1C81: 39      	        ADD     HL,SP           ; Point to it
1C82: CD7F18  	FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
1C85: D1      	        POP     DE              ; Get code string address
1C86: C29E1C  	        JP      NZ,FORFND       ; No nesting found
1C89: 09      	        ADD     HL,BC           ; Move into "FOR" block
1C8A: D5      	        PUSH    DE              ; Save code string address
1C8B: 2B      	        DEC     HL
1C8C: 56      	        LD      D,(HL)          ; Get MSB of loop statement
1C8D: 2B      	        DEC     HL
1C8E: 5E      	        LD      E,(HL)          ; Get LSB of loop statement
1C8F: 23      	        INC     HL
1C90: 23      	        INC     HL
1C91: E5      	        PUSH    HL              ; Save block address
1C92: 2A0C81  	        LD      HL,(LOOPST)     ; Get address of loop statement
1C95: CD9A1B  	        CALL    CPDEHL          ; Compare the FOR loops
1C98: E1      	        POP     HL              ; Restore block address
1C99: C2821C  	        JP      NZ,FORSLP       ; Different FORs - Find another
1C9C: D1      	        POP     DE              ; Restore code string address
1C9D: F9      	        LD      SP,HL           ; Remove all nested loops
              	
1C9E: EB      	FORFND: EX      DE,HL           ; Code string address to HL
1C9F: 0E08    	        LD      C,8
1CA1: CDAF18  	        CALL    CHKSTK          ; Check for 8 levels of stack
1CA4: E5      	        PUSH    HL              ; Save code string address
1CA5: 2A0C81  	        LD      HL,(LOOPST)     ; Get first statement of loop
1CA8: E3      	        EX      (SP),HL         ; Save and restore code string
1CA9: E5      	        PUSH    HL              ; Re-save code string address
1CAA: 2AA180  	        LD      HL,(LINEAT)     ; Get current line number
1CAD: E3      	        EX      (SP),HL         ; Save and restore code string
1CAE: CD9C21  	        CALL    TSTNUM          ; Make sure it's a number
1CB1: CDA01B  	        CALL    CHKSYN          ; Make sure "TO" is next
1CB4: AC      	        DB   ZTO          ; "TO" token
1CB5: CD9921  	        CALL    GETNUM          ; Get "TO" expression value
1CB8: E5      	        PUSH    HL              ; Save code string address
1CB9: CDD72B  	        CALL    BCDEFP          ; Move "TO" value to BCDE
1CBC: E1      	        POP     HL              ; Restore code string address
1CBD: C5      	        PUSH    BC              ; Save "TO" value in block
1CBE: D5      	        PUSH    DE
1CBF: 010081  	        LD      BC,8100H        ; BCDE - 1 (default STEP)
1CC2: 51      	        LD      D,C             ; C=0
1CC3: 5A      	        LD      E,D             ; D=0
1CC4: 7E      	        LD      A,(HL)          ; Get next byte in code string
1CC5: FEB1    	        CP      ZSTEP           ; See if "STEP" is stated
1CC7: 3E01    	        LD      A,1             ; Sign of step = 1
1CC9: C2DA1C  	        JP      NZ,SAVSTP       ; No STEP given - Default to 1
1CCC: CD271D  	        CALL    GETCHR          ; Jump over "STEP" token
1CCF: CD9921  	        CALL    GETNUM          ; Get step value
1CD2: E5      	        PUSH    HL              ; Save code string address
1CD3: CDD72B  	        CALL    BCDEFP          ; Move STEP to BCDE
1CD6: CD8B2B  	        CALL    TSTSGN          ; Test sign of FPREG
1CD9: E1      	        POP     HL              ; Restore code string address
1CDA: C5      	SAVSTP: PUSH    BC              ; Save the STEP value in block
1CDB: D5      	        PUSH    DE
1CDC: F5      	        PUSH    AF              ; Save sign of STEP
1CDD: 33      	        INC     SP              ; Don't save flags
1CDE: E5      	        PUSH    HL              ; Save code string address
1CDF: 2A1381  	        LD      HL,(BRKLIN)     ; Get address of index variable
1CE2: E3      	        EX      (SP),HL         ; Save and restore code string
1CE3: 0681    	PUTFID: LD      B,ZFOR          ; "FOR" block marker
1CE5: C5      	        PUSH    BC              ; Save it
1CE6: 33      	        INC     SP              ; Don't save C
              	
1CE7: CD561D  	RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
1CEA: 221381  	        LD      (BRKLIN),HL     ; Save code address for break
1CED: 7E      	        LD      A,(HL)          ; Get next byte in code string
1CEE: FE3A    	        CP      ':'             ; Multi statement line?
1CF0: CA071D  	        JP      Z,EXCUTE        ; Yes - Execute it
1CF3: B7      	        OR      A               ; End of line?
1CF4: C2D218  	        JP      NZ,SNERR        ; No - Syntax error
1CF7: 23      	        INC     HL              ; Point to address of next line
1CF8: 7E      	        LD      A,(HL)          ; Get LSB of line pointer
1CF9: 23      	        INC     HL
1CFA: B6      	        OR      (HL)            ; Is it zero (End of prog)?
1CFB: CA7E1D  	        JP      Z,ENDPRG        ; Yes - Terminate execution
1CFE: 23      	        INC     HL              ; Point to line number
1CFF: 5E      	        LD      E,(HL)          ; Get LSB of line number
1D00: 23      	        INC     HL
1D01: 56      	        LD      D,(HL)          ; Get MSB of line number
1D02: EB      	        EX      DE,HL           ; Line number to HL
1D03: 22A180  	        LD      (LINEAT),HL     ; Save as current line number
1D06: EB      	        EX      DE,HL           ; Line number back to DE
1D07: CD271D  	EXCUTE: CALL    GETCHR          ; Get key word
1D0A: 11E71C  	        LD      DE,RUNCNT       ; Where to RETurn to
1D0D: D5      	        PUSH    DE              ; Save for RETurn
1D0E: C8      	IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
1D0F: D680    	ONJMP:  SUB     ZEND            ; Is it a token?
1D11: DADA1E  	        JP      C,LET           ; No - try to assign it
1D14: FE2B    	        CP      ZNEW+1-ZEND     ; END to NEW ?
1D16: D2D218  	        JP      NC,SNERR        ; Not a key word - ?SN Error
1D19: 07      	        RLCA                    ; Double it
1D1A: 4F      	        LD      C,A             ; BC = Offset into table
1D1B: 0600    	        LD      B,0
1D1D: EB      	        EX      DE,HL           ; Save code string address
1D1E: 216E17  	        LD      HL,WORDTB       ; Keyword address table
1D21: 09      	        ADD     HL,BC           ; Point to routine address
1D22: 4E      	        LD      C,(HL)          ; Get LSB of routine address
1D23: 23      	        INC     HL
1D24: 46      	        LD      B,(HL)          ; Get MSB of routine address
1D25: C5      	        PUSH    BC              ; Save routine address
1D26: EB      	        EX      DE,HL           ; Restore code string address
              	
1D27: 23      	GETCHR: INC     HL              ; Point to next character
1D28: 7E      	        LD      A,(HL)          ; Get next code string byte
1D29: FE3A    	        CP      ':'             ; Z if ':'
1D2B: D0      	        RET     NC              ; NC if > "9"
1D2C: FE20    	        CP      ' '
1D2E: CA271D  	        JP      Z,GETCHR        ; Skip over spaces
1D31: FE30    	        CP      '0'
1D33: 3F      	        CCF                     ; NC if < '0'
1D34: 3C      	        INC     A               ; Test for zero - Leave carry
1D35: 3D      	        DEC     A               ; Z if Null
1D36: C9      	        RET
              	
1D37: EB      	RESTOR: EX      DE,HL           ; Save code string address
1D38: 2AA380  	        LD      HL,(BASTXT)     ; Point to start of program
1D3B: CA4C1D  	        JP      Z,RESTNL        ; Just RESTORE - reset pointer
1D3E: EB      	        EX      DE,HL           ; Restore code string address
1D3F: CDF81D  	        CALL    ATOH            ; Get line number to DE
1D42: E5      	        PUSH    HL              ; Save code string address
1D43: CDBE19  	        CALL    SRCHLN          ; Search for line number in DE
1D46: 60      	        LD      H,B             ; HL = Address of line
1D47: 69      	        LD      L,C
1D48: D1      	        POP     DE              ; Restore code string address
1D49: D2991E  	        JP      NC,ULERR        ; ?UL Error if not found
1D4C: 2B      	RESTNL: DEC     HL              ; Byte before DATA statement
1D4D: 222181  	UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
1D50: EB      	        EX      DE,HL           ; Restore code string address
1D51: C9      	        RET
              	
1D52:         	OTHERKEY:
1D52: 321EFF  	        LD(INKEYVALUE), A       ; Store keypress for INKEY Function
1D55: C9      	        RET
              	
1D56: DF      	TSTBRK: RST     18H             ; Check input status
1D57: C8      	        RET     Z               ; No key, go back
1D58: D7      	        RST     10H             ; Get the key into A
1D59: FE1B    	        CP      ESC             ; Escape key?
1D5B: 2812    	        JR      Z,BRK           ; Yes, break
1D5D: FE03    	        CP      CTRLC           ; <Ctrl-C>
1D5F: 280E    	        JR      Z,BRK           ; Yes, break
1D61: FE13    	        CP      CTRLS           ; Stop scrolling?
              	        ;RET     NZ              ; Other key, ignore
1D63: 20ED    	        JR      NZ,OTHERKEY
              	
1D65: D7      	STALL:  RST     10H             ; Wait for key
1D66: FE11    	        CP      CTRLQ           ; Resume scrolling?
1D68: C8      	        RET      Z              ; Release the chokehold
1D69: FE03    	        CP      CTRLC           ; Second break?
1D6B: 2807    	        JR      Z,STOP          ; Break during hold exits prog
1D6D: 18F6    	        JR      STALL           ; Loop until <Ctrl-Q> or <brk>
              	
1D6F: 3EFF    	BRK     LD      A,$FF           ; Set BRKFLG
1D71: 329280  	        LD      (BRKFLG),A      ; Store it
              	
              	
1D74: C0      	STOP:   RET     NZ              ; Exit if anything else
1D75: F6      	        DB   0F6H            ; Flag "STOP"
1D76: C0      	PEND:   RET     NZ              ; Exit if anything else
1D77: 221381  	        LD      (BRKLIN),HL     ; Save point of break
1D7A: 21      	        DB   21H             ; Skip "OR 11111111B"
1D7B: F6FF    	INPBRK: OR      11111111B       ; Flag "Break" wanted
1D7D: C1      	        POP     BC              ; Return not needed and more
1D7E: 2AA180  	ENDPRG: LD      HL,(LINEAT)     ; Get current line number
1D81: F5      	        PUSH    AF              ; Save STOP / END status
1D82: 7D      	        LD      A,L             ; Is it direct break?
1D83: A4      	        AND     H
1D84: 3C      	        INC     A               ; Line is -1 if direct break
1D85: CA911D  	        JP      Z,NOLIN         ; Yes - No line number
1D88: 221781  	        LD      (ERRLIN),HL     ; Save line of break
1D8B: 2A1381  	        LD      HL,(BRKLIN)     ; Get point of break
1D8E: 221981  	        LD      (CONTAD),HL     ; Save point to CONTinue
1D91: AF      	NOLIN:  XOR     A
1D92: 328A80  	        LD      (CTLOFG),A      ; Enable output
1D95: CDC71F  	        CALL    STTLIN          ; Start a new line
1D98: F1      	        POP     AF              ; Restore STOP / END status
1D99: 217518  	        LD      HL,BRKMSG       ; "Break" message
1D9C: C20619  	        JP      NZ,ERRIN        ; "in line" wanted?
1D9F: C31D19  	        JP      PRNTOK          ; Go to command mode
              	
1DA2: 2A1981  	CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
1DA5: 7C      	        LD      A,H             ; Is it zero?
1DA6: B5      	        OR      L
1DA7: 1E20    	        LD      E,CN            ; ?CN Error
1DA9: CAE618  	        JP      Z,ERROR         ; Yes - output "?CN Error"
1DAC: EB      	        EX      DE,HL           ; Save code string address
1DAD: 2A1781  	        LD      HL,(ERRLIN)     ; Get line of last break
1DB0: 22A180  	        LD      (LINEAT),HL     ; Set up current line number
1DB3: EB      	        EX      DE,HL           ; Restore code string address
1DB4: C9      	        RET                     ; CONTinue where left off
              	
1DB5: CD0A29  	NULL:   CALL    GETINT          ; Get integer 0-255
1DB8: C0      	        RET     NZ              ; Return if bad value
1DB9: 328680  	        LD      (NULLS),A       ; Set nulls number
1DBC: C9      	        RET
              	
              	
1DBD: E5      	ACCSUM: PUSH    HL              ; Save address in array
1DBE: 2A8F80  	        LD      HL,(CHKSUM)     ; Get check sum
1DC1: 0600    	        LD      B,0             ; BC - Value of byte
1DC3: 4F      	        LD      C,A
1DC4: 09      	        ADD     HL,BC           ; Add byte to check sum
1DC5: 228F80  	        LD      (CHKSUM),HL     ; Re-save check sum
1DC8: E1      	        POP     HL              ; Restore address in array
1DC9: C9      	        RET
              	
1DCA: 7E      	CHKLTR: LD      A,(HL)          ; Get byte
1DCB: FE41    	        CP      'A'             ; < 'a' ?
1DCD: D8      	        RET     C               ; Carry set if not letter
1DCE: FE5B    	        CP      'Z'+1           ; > 'z' ?
1DD0: 3F      	        CCF
1DD1: C9      	        RET                     ; Carry set if not letter
              	
1DD2: CD271D  	FPSINT: CALL    GETCHR          ; Get next character
1DD5: CD9921  	POSINT: CALL    GETNUM          ; Get integer 0 to 32767
1DD8: CD8B2B  	DEPINT: CALL    TSTSGN          ; Test sign of FPREG
1DDB: FAF31D  	        JP      M,FCERR         ; Negative - ?FC Error
1DDE: 3A2C81  	DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
1DE1: FE90    	        CP      80H+16          ; Exponent in range (16 bits)?
1DE3: DA332C  	        JP      C,FPINT         ; Yes - convert it
1DE6: 018090  	        LD      BC,9080H        ; BCDE = -32768
1DE9: 110000  	        LD      DE,0000
1DEC: E5      	        PUSH    HL              ; Save code string address
1DED: CD062C  	        CALL    CMPNUM          ; Compare FPREG with BCDE
1DF0: E1      	        POP     HL              ; Restore code string address
1DF1: 51      	        LD      D,C             ; MSB to D
1DF2: C8      	        RET     Z               ; Return if in range
1DF3: 1E08    	FCERR:  LD      E,FC            ; ?FC Error
1DF5: C3E618  	        JP      ERROR           ; Output error-
              	
1DF8: 2B      	ATOH:   DEC     HL              ; ASCII number to DE binary
1DF9: 110000  	GETLN:  LD      DE,0            ; Get number to DE
1DFC: CD271D  	GTLNLP: CALL    GETCHR          ; Get next character
1DFF: D0      	        RET     NC              ; Exit if not a digit
1E00: E5      	        PUSH    HL              ; Save code string address
1E01: F5      	        PUSH    AF              ; Save digit
1E02: 219819  	        LD      HL,65529/10     ; Largest number 65529
1E05: CD9A1B  	        CALL    CPDEHL          ; Number in range?
1E08: DAD218  	        JP      C,SNERR         ; No - ?SN Error
1E0B: 62      	        LD      H,D             ; HL = Number
1E0C: 6B      	        LD      L,E
1E0D: 19      	        ADD     HL,DE           ; Times 2
1E0E: 29      	        ADD     HL,HL           ; Times 4
1E0F: 19      	        ADD     HL,DE           ; Times 5
1E10: 29      	        ADD     HL,HL           ; Times 10
1E11: F1      	        POP     AF              ; Restore digit
1E12: D630    	        SUB     '0'             ; Make it 0 to 9
1E14: 5F      	        LD      E,A             ; DE = Value of digit
1E15: 1600    	        LD      D,0
1E17: 19      	        ADD     HL,DE           ; Add to number
1E18: EB      	        EX      DE,HL           ; Number to DE
1E19: E1      	        POP     HL              ; Restore code string address
1E1A: C3FC1D  	        JP      GTLNLP          ; Go to next character
              	
1E1D: CAEE19  	CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
1E20: CDD51D  	        CALL    POSINT          ; Get integer 0 to 32767 to DE
1E23: 2B      	        DEC     HL              ; Cancel increment
1E24: CD271D  	        CALL    GETCHR          ; Get next character
1E27: E5      	        PUSH    HL              ; Save code string address
1E28: 2AF480  	        LD      HL,(LSTRAM)     ; Get end of RAM
1E2B: CA401E  	        JP      Z,STORED        ; No value given - Use stored
1E2E: E1      	        POP     HL              ; Restore code string address
1E2F: CDA01B  	        CALL    CHKSYN          ; Check for comma
1E32: 2C      	        DB      ','
1E33: D5      	        PUSH    DE              ; Save number
1E34: CDD51D  	        CALL    POSINT          ; Get integer 0 to 32767
1E37: 2B      	        DEC     HL              ; Cancel increment
1E38: CD271D  	        CALL    GETCHR          ; Get next character
1E3B: C2D218  	        JP      NZ,SNERR        ; ?SN Error if more on line
1E3E: E3      	        EX      (SP),HL         ; Save code string address
1E3F: EB      	        EX      DE,HL           ; Number to DE
1E40: 7D      	STORED: LD      A,L             ; Get LSB of new RAM top
1E41: 93      	        SUB     E               ; Subtract LSB of string space
1E42: 5F      	        LD      E,A             ; Save LSB
1E43: 7C      	        LD      A,H             ; Get MSB of new RAM top
1E44: 9A      	        SBC     A,D             ; Subtract MSB of string space
1E45: 57      	        LD      D,A             ; Save MSB
1E46: DAC718  	        JP      C,OMERR         ; ?OM Error if not enough mem
1E49: E5      	        PUSH    HL              ; Save RAM top
1E4A: 2A1B81  	        LD      HL,(PROGND)     ; Get program end
1E4D: 012800  	        LD      BC,40           ; 40 Bytes minimum working RAM
1E50: 09      	        ADD     HL,BC           ; Get lowest address
1E51: CD9A1B  	        CALL    CPDEHL          ; Enough memory?
1E54: D2C718  	        JP      NC,OMERR        ; No - ?OM Error
1E57: EB      	        EX      DE,HL           ; RAM top to HL
1E58: 229F80  	        LD      (STRSPC),HL     ; Set new string space
1E5B: E1      	        POP     HL              ; End of memory to use
1E5C: 22F480  	        LD      (LSTRAM),HL     ; Set new top of RAM
1E5F: E1      	        POP     HL              ; Restore code string address
1E60: C3EE19  	        JP      INTVAR          ; Initialise variables
              	
1E63: CAEA19  	RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
1E66: CDEE19  	        CALL    INTVAR          ; Initialise variables
1E69: 01E71C  	        LD      BC,RUNCNT       ; Execution driver loop
1E6C: C37F1E  	        JP      RUNLIN          ; RUN from line number
              	
1E6F: 0E03    	GOSUB:  LD      C,3             ; 3 Levels of stack needed
1E71: CDAF18  	        CALL    CHKSTK          ; Check for 3 levels of stack
1E74: C1      	        POP     BC              ; Get return address
1E75: E5      	        PUSH    HL              ; Save code string for RETURN
1E76: E5      	        PUSH    HL              ; And for GOSUB routine
1E77: 2AA180  	        LD      HL,(LINEAT)     ; Get current line
1E7A: E3      	        EX      (SP),HL         ; Into stack - Code string out
1E7B: 3E8C    	        LD      A,ZGOSUB        ; "GOSUB" token
1E7D: F5      	        PUSH    AF              ; Save token
1E7E: 33      	        INC     SP              ; Don't save flags
              	
1E7F: C5      	RUNLIN: PUSH    BC              ; Save return address
1E80: CDF81D  	GOTO:   CALL    ATOH            ; ASCII number to DE binary
1E83: CDC51E  	        CALL    REM             ; Get end of line
1E86: E5      	        PUSH    HL              ; Save end of line
1E87: 2AA180  	        LD      HL,(LINEAT)     ; Get current line
1E8A: CD9A1B  	        CALL    CPDEHL          ; Line after current?
1E8D: E1      	        POP     HL              ; Restore end of line
1E8E: 23      	        INC     HL              ; Start of next line
1E8F: DCC119  	        CALL    C,SRCHLP        ; Line is after current line
1E92: D4BE19  	        CALL    NC,SRCHLN       ; Line is before current line
1E95: 60      	        LD      H,B             ; Set up code string address
1E96: 69      	        LD      L,C
1E97: 2B      	        DEC     HL              ; Incremented after
1E98: D8      	        RET     C               ; Line found
1E99: 1E0E    	ULERR:  LD      E,UL            ; ?UL Error
1E9B: C3E618  	        JP      ERROR           ; Output error message
              	
1E9E: C0      	RETURN: RET     NZ              ; Return if not just RETURN
1E9F: 16FF    	        LD      D,-1            ; Flag "GOSUB" search
1EA1: CD7B18  	        CALL    BAKSTK          ; Look "GOSUB" block
1EA4: F9      	        LD      SP,HL           ; Kill all FORs in subroutine
1EA5: FE8C    	        CP      ZGOSUB          ; Test for "GOSUB" token
1EA7: 1E04    	        LD      E,RG            ; ?RG Error
1EA9: C2E618  	        JP      NZ,ERROR        ; Error if no "GOSUB" found
1EAC: E1      	        POP     HL              ; Get RETURN line number
1EAD: 22A180  	        LD      (LINEAT),HL     ; Save as current
1EB0: 23      	        INC     HL              ; Was it from direct statement?
1EB1: 7C      	        LD      A,H
1EB2: B5      	        OR      L               ; Return to line
1EB3: C2BD1E  	        JP      NZ,RETLIN       ; No - Return to line
1EB6: 3A1181  	        LD      A,(LSTBIN)      ; Any INPUT in subroutine?
1EB9: B7      	        OR      A               ; If so buffer is corrupted
1EBA: C21C19  	        JP      NZ,POPNOK       ; Yes - Go to command mode
1EBD: 21E71C  	RETLIN: LD      HL,RUNCNT       ; Execution driver loop
1EC0: E3      	        EX      (SP),HL         ; Into stack - Code string out
1EC1: 3E      	        DB      3EH             ; Skip "POP HL"
1EC2: E1      	NXTDTA: POP     HL              ; Restore code string address
              	
1EC3: 013A    	DATA:   DB      01H,3AH         ; ':' End of statement
1EC5: 0E00    	REM:    LD      C,0             ; 00  End of statement
1EC7: 0600    	        LD      B,0
1EC9: 79      	NXTSTL: LD      A,C             ; Statement and byte
1ECA: 48      	        LD      C,B
1ECB: 47      	        LD      B,A             ; Statement end byte
1ECC: 7E      	NXTSTT: LD      A,(HL)          ; Get byte
1ECD: B7      	        OR      A               ; End of line?
1ECE: C8      	        RET     Z               ; Yes - Exit
1ECF: B8      	        CP      B               ; End of statement?
1ED0: C8      	        RET     Z               ; Yes - Exit
1ED1: 23      	        INC     HL              ; Next byte
1ED2: FE22    	        CP      '"'             ; Literal string?
1ED4: CAC91E  	        JP      Z,NXTSTL        ; Yes - Look for another '"'
1ED7: C3CC1E  	        JP      NXTSTT          ; Keep looking
              	
1EDA: CD8F23  	LET:    CALL    GETVAR          ; Get variable name
1EDD: CDA01B  	        CALL    CHKSYN          ; Make sure "=" follows
1EE0: BA      	        DB      ZEQUAL          ; "=" token
1EE1: D5      	        PUSH    DE              ; Save address of variable
1EE2: 3AF280  	        LD      A,(TYPE)        ; Get data type
1EE5: F5      	        PUSH    AF              ; Save type
1EE6: CDAB21  	        CALL    EVAL            ; Evaluate expression
1EE9: F1      	        POP     AF              ; Restore type
1EEA: E3      	        EX      (SP),HL         ; Save code - Get var addr
1EEB: 221381  	        LD      (BRKLIN),HL     ; Save address of variable
1EEE: 1F      	        RRA                     ; Adjust type
1EEF: CD9E21  	        CALL    CHKTYP          ; Check types are the same
1EF2: CA2D1F  	        JP      Z,LETNUM        ; Numeric - Move value
1EF5: E5      	LETSTR: PUSH    HL              ; Save address of string var
1EF6: 2A2981  	        LD      HL,(FPREG)      ; Pointer to string entry
1EF9: E5      	        PUSH    HL              ; Save it on stack
1EFA: 23      	        INC     HL              ; Skip over length
1EFB: 23      	        INC     HL
1EFC: 5E      	        LD      E,(HL)          ; LSB of string address
1EFD: 23      	        INC     HL
1EFE: 56      	        LD      D,(HL)          ; MSB of string address
1EFF: 2AA380  	        LD      HL,(BASTXT)     ; Point to start of program
1F02: CD9A1B  	        CALL    CPDEHL          ; Is string before program?
1F05: D21C1F  	        JP      NC,CRESTR       ; Yes - Create string entry
1F08: 2A9F80  	        LD      HL,(STRSPC)     ; Point to string space
1F0B: CD9A1B  	        CALL    CPDEHL          ; Is string literal in program?
1F0E: D1      	        POP     DE              ; Restore address of string
1F0F: D2241F  	        JP      NC,MVSTPT       ; Yes - Set up pointer
1F12: 210481  	        LD      HL,TMPSTR       ; Temporary string pool
1F15: CD9A1B  	        CALL    CPDEHL          ; Is string in temporary pool?
1F18: D2241F  	        JP      NC,MVSTPT       ; No - Set up pointer
1F1B: 3E      	        DB   3EH             ; Skip "POP DE"
1F1C: D1      	CRESTR: POP     DE              ; Restore address of string
1F1D: CDE327  	        CALL    BAKTMP          ; Back to last tmp-str entry
1F20: EB      	        EX      DE,HL           ; Address of string entry
1F21: CD1C26  	        CALL    SAVSTR          ; Save string in string area
1F24: CDE327  	MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
1F27: E1      	        POP     HL              ; Get string pointer
1F28: CDE62B  	        CALL    DETHL4          ; Move string pointer to var
1F2B: E1      	        POP     HL              ; Restore code string address
1F2C: C9      	        RET
              	
1F2D: E5      	LETNUM: PUSH    HL              ; Save address of variable
1F2E: CDE32B  	        CALL    FPTHL           ; Move value to variable
1F31: D1      	        POP     DE              ; Restore address of variable
1F32: E1      	        POP     HL              ; Restore code string address
1F33: C9      	        RET
              	
1F34: CD0A29  	ON:     CALL    GETINT          ; Get integer 0-255
1F37: 7E      	        LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
1F38: 47      	        LD      B,A             ; Save in B
1F39: FE8C    	        CP      ZGOSUB          ; "GOSUB" token?
1F3B: CA431F  	        JP      Z,ONGO          ; Yes - Find line number
1F3E: CDA01B  	        CALL    CHKSYN          ; Make sure it's "GOTO"
1F41: 88      	        DB   ZGOTO           ; "GOTO" token
1F42: 2B      	        DEC     HL              ; Cancel increment
1F43: 4B      	ONGO:   LD      C,E             ; Integer of branch value
1F44: 0D      	ONGOLP: DEC     C               ; Count branches
1F45: 78      	        LD      A,B             ; Get "GOTO" or "GOSUB" token
1F46: CA0F1D  	        JP      Z,ONJMP         ; Go to that line if right one
1F49: CDF91D  	        CALL    GETLN           ; Get line number to DE
1F4C: FE2C    	        CP      ','             ; Another line number?
1F4E: C0      	        RET     NZ              ; No - Drop through
1F4F: C3441F  	        JP      ONGOLP          ; Yes - loop
              	
1F52: CDAB21  	IFF:     CALL    EVAL            ; Evaluate expression
1F55: 7E      	        LD      A,(HL)          ; Get token
1F56: FE88    	        CP      ZGOTO           ; "GOTO" token?
1F58: CA601F  	        JP      Z,IFGO          ; Yes - Get line
1F5B: CDA01B  	        CALL    CHKSYN          ; Make sure it's "THEN"
1F5E: AF      	        DB      ZTHEN           ; "THEN" token
1F5F: 2B      	        DEC     HL              ; Cancel increment
1F60: CD9C21  	IFGO:   CALL    TSTNUM          ; Make sure it's numeric
1F63: CD8B2B  	        CALL    TSTSGN          ; Test state of expression
1F66: CAC51E  	        JP      Z,REM           ; False - Drop through
1F69: CD271D  	        CALL    GETCHR          ; Get next character
1F6C: DA801E  	        JP      C,GOTO          ; Number - GOTO that line
1F6F: C30E1D  	        JP      IFJMP           ; Otherwise do statement
              	
1F72: 2B      	MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
1F73: CD271D  	        CALL    GETCHR          ; Get next character
1F76: CAD41F  	PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
1F79: C8      	PRNTLP: RET     Z               ; End of list - Exit
1F7A: FEAB    	        CP      ZTAB            ; "TAB(" token?
1F7C: CA0720  	        JP      Z,DOTAB         ; Yes - Do TAB routine
1F7F: FEAE    	        CP      ZSPC            ; "SPC(" token?
1F81: CA0720  	        JP      Z,DOTAB         ; Yes - Do SPC routine
1F84: E5      	        PUSH    HL              ; Save code string address
1F85: FE2C    	        CP      ','             ; Comma?
1F87: CAF01F  	        JP      Z,DOCOM         ; Yes - Move to next zone
1F8A: FE3B    	        CP      59 ;";"         ; Semi-colon?
1F8C: CA2A20  	        JP      Z,NEXITM        ; Do semi-colon routine
1F8F: C1      	        POP     BC              ; Code string address to BC
1F90: CDAB21  	        CALL    EVAL            ; Evaluate expression
1F93: E5      	        PUSH    HL              ; Save code string address
1F94: 3AF280  	        LD      A,(TYPE)        ; Get variable type
1F97: B7      	        OR      A               ; Is it a string variable?
1F98: C2C01F  	        JP      NZ,PRNTST       ; Yes - Output string contents
1F9B: CD302D  	        CALL    NUMASC          ; Convert number to text
1F9E: CD4026  	        CALL    CRTST           ; Create temporary string
1FA1: 3620    	        LD      (HL),' '        ; Followed by a space
1FA3: 2A2981  	        LD      HL,(FPREG)      ; Get length of output
1FA6: 34      	        INC     (HL)            ; Plus 1 for the space
1FA7: 2A2981  	        LD      HL,(FPREG)      ; < Not needed >
1FAA: 3A8780  	        LD      A,(LWIDTH)      ; Get width of line
1FAD: 47      	        LD      B,A             ; To B
1FAE: 04      	        INC     B               ; Width 255 (No limit)?
1FAF: CABC1F  	        JP      Z,PRNTNB        ; Yes - Output number string
1FB2: 04      	        INC     B               ; Adjust it
1FB3: 3AF080  	        LD      A,(CURPOS)      ; Get cursor position
1FB6: 86      	        ADD     A,(HL)          ; Add length of string
1FB7: 3D      	        DEC     A               ; Adjust it
1FB8: B8      	        CP      B               ; Will output fit on this line?
1FB9: D4D41F  	        CALL    NC,PRNTCRLF     ; No - CRLF first
1FBC: CD8526  	PRNTNB: CALL    PRS1            ; Output string at (HL)
1FBF: AF      	        XOR     A               ; Skip CALL by setting 'z' flag
1FC0: C48526  	PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
1FC3: E1      	        POP     HL              ; Restore code string address
1FC4: C3721F  	        JP      MRPRNT          ; See if more to PRINT
              	
1FC7: 3AF080  	STTLIN: LD      A,(CURPOS)      ; Make sure on new line
1FCA: B7      	        OR      A               ; Already at start?
1FCB: C8      	        RET     Z               ; Yes - Do nothing
1FCC: C3D41F  	        JP      PRNTCRLF        ; Start a new line
              	
1FCF: 3600    	ENDINP: LD      (HL),0          ; Mark end of buffer
1FD1: 21A580  	        LD      HL,BUFFER-1     ; Point to buffer
1FD4: 3E0D    	PRNTCRLF: LD    A,CR            ; Load a CR
1FD6: CDAB1B  	        CALL    OUTC            ; Output character
1FD9: 3E0A    	        LD      A,LF            ; Load a LF
1FDB: CDAB1B  	        CALL    OUTC            ; Output character
1FDE: AF      	DONULL: XOR     A               ; Set to position 0
1FDF: 32F080  	        LD      (CURPOS),A      ; Store it
1FE2: 3A8680  	        LD      A,(NULLS)       ; Get number of nulls
1FE5: 3D      	NULLP:  DEC     A               ; Count them
1FE6: C8      	        RET     Z               ; Return if done
1FE7: F5      	        PUSH    AF              ; Save count
1FE8: AF      	        XOR     A               ; Load a null
1FE9: CDAB1B  	        CALL    OUTC            ; Output it
1FEC: F1      	        POP     AF              ; Restore count
1FED: C3E51F  	        JP      NULLP           ; Keep counting
              	
1FF0: 3A8880  	DOCOM:  LD      A,(COMMAN)      ; Get comma width
1FF3: 47      	        LD      B,A             ; Save in B
1FF4: 3AF080  	        LD      A,(CURPOS)      ; Get current position
1FF7: B8      	        CP      B               ; Within the limit?
1FF8: D4D41F  	        CALL    NC,PRNTCRLF     ; No - output CRLF
1FFB: D22A20  	        JP      NC,NEXITM       ; Get next item
1FFE: D60E    	ZONELP: SUB     14              ; Next zone of 14 characters
2000: D2FE1F  	        JP      NC,ZONELP       ; Repeat if more zones
2003: 2F      	        CPL                     ; Number of spaces to output
2004: C31F20  	        JP      ASPCS           ; Output them
              	
2007: F5      	DOTAB:  PUSH    AF              ; Save token
2008: CD0729  	        CALL    FNDNUM          ; Evaluate expression
200B: CDA01B  	        CALL    CHKSYN          ; Make sure ")" follows
200E: 29      	        DB   ")"
200F: 2B      	        DEC     HL              ; Back space on to ")"
2010: F1      	        POP     AF              ; Restore token
2011: D6AE    	        SUB     ZSPC            ; Was it "SPC(" ?
2013: E5      	        PUSH    HL              ; Save code string address
2014: CA1A20  	        JP      Z,DOSPC         ; Yes - Do 'E' spaces
2017: 3AF080  	        LD      A,(CURPOS)      ; Get current position
201A: 2F      	DOSPC:  CPL                     ; Number of spaces to print to
201B: 83      	        ADD     A,E             ; Total number to print
201C: D22A20  	        JP      NC,NEXITM       ; TAB < Current POS(X)
201F: 3C      	ASPCS:  INC     A               ; Output A spaces
2020: 47      	        LD      B,A             ; Save number to print
2021: 3E20    	        LD      A,' '           ; Space
2023: CDAB1B  	SPCLP:  CALL    OUTC            ; Output character in A
2026: 05      	        DEC     B               ; Count them
2027: C22320  	        JP      NZ,SPCLP        ; Repeat if more
202A: E1      	NEXITM: POP     HL              ; Restore code string address
202B: CD271D  	        CALL    GETCHR          ; Get next character
202E: C3791F  	        JP      PRNTLP          ; More to print
              	
2031: 3F526564	REDO:   DB   "?Redo from start",CR,LF,0
2035: 6F206672	
2039: 6F6D2073	
203D: 74617274	
2041: 0D0A00  	
              	
2044: 3A1281  	BADINP: LD      A,(READFG)      ; READ or INPUT?
2047: B7      	        OR      A
2048: C2CC18  	        JP      NZ,DATSNR       ; READ - ?SN Error
204B: C1      	        POP     BC              ; Throw away code string addr
204C: 213120  	        LD      HL,REDO         ; "Redo from start" message
204F: CD8226  	        CALL    PRS             ; Output string
2052: C31D1A  	        JP      DOAGN           ; Do last INPUT again
              	
2055: CDED25  	INPUT:  CALL    IDTEST          ; Test for illegal direct
2058: 7E      	        LD      A,(HL)          ; Get character after "INPUT"
2059: FE22    	        CP      '"'             ; Is there a prompt string?
205B: 3E00    	        LD      A,0             ; Clear A and leave flags
205D: 328A80  	        LD      (CTLOFG),A      ; Enable output
2060: C26F20  	        JP      NZ,NOPMPT       ; No prompt - get input
2063: CD4126  	        CALL    QTSTR           ; Get string terminated by '"'
2066: CDA01B  	        CALL    CHKSYN          ; Check for ';' after prompt
2069: 3B      	        DB   ';'
206A: E5      	        PUSH    HL              ; Save code string address
206B: CD8526  	        CALL    PRS1            ; Output prompt string
206E: 3E      	        DB   3EH             ; Skip "PUSH HL"
206F: E5      	NOPMPT: PUSH    HL              ; Save code string address
2070: CD211A  	        CALL    PROMPT          ; Get input with "? " prompt
2073: C1      	        POP     BC              ; Restore code string address
2074: DA7B1D  	        JP      C,INPBRK        ; Break pressed - Exit
2077: 23      	        INC     HL              ; Next byte
2078: 7E      	        LD      A,(HL)          ; Get it
2079: B7      	        OR      A               ; End of line?
207A: 2B      	        DEC     HL              ; Back again
207B: C5      	        PUSH    BC              ; Re-save code string address
207C: CAC21E  	        JP      Z,NXTDTA        ; Yes - Find next DATA stmt
207F: 362C    	        LD      (HL),','        ; Store comma as separator
2081: C38920  	        JP      NXTITM          ; Get next item
              	
2084: E5      	READ:   PUSH    HL              ; Save code string address
2085: 2A2181  	        LD      HL,(NXTDAT)     ; Next DATA statement
2088: F6      	        DB   0F6H            ; Flag "READ"
2089: AF      	NXTITM: XOR     A               ; Flag "INPUT"
208A: 321281  	        LD      (READFG),A      ; Save "READ"/"INPUT" flag
208D: E3      	        EX      (SP),HL         ; Get code str' , Save pointer
208E: C39520  	        JP      GTVLUS          ; Get values
              	
2091: CDA01B  	NEDMOR: CALL    CHKSYN          ; Check for comma between items
2094: 2C      	        DB      ','
2095: CD8F23  	GTVLUS: CALL    GETVAR          ; Get variable name
2098: E3      	        EX      (SP),HL         ; Save code str" , Get pointer
2099: D5      	        PUSH    DE              ; Save variable address
209A: 7E      	        LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
209B: FE2C    	        CP      ','             ; Comma?
209D: CABD20  	        JP      Z,ANTVLU        ; Yes - Get another value
20A0: 3A1281  	        LD      A,(READFG)      ; Is it READ?
20A3: B7      	        OR      A
20A4: C22A21  	        JP      NZ,FDTLP        ; Yes - Find next DATA stmt
20A7: 3E3F    	        LD      A,'?'           ; More INPUT needed
20A9: CDAB1B  	        CALL    OUTC            ; Output character
20AC: CD211A  	        CALL    PROMPT          ; Get INPUT with prompt
20AF: D1      	        POP     DE              ; Variable address
20B0: C1      	        POP     BC              ; Code string address
20B1: DA7B1D  	        JP      C,INPBRK        ; Break pressed
20B4: 23      	        INC     HL              ; Point to next DATA byte
20B5: 7E      	        LD      A,(HL)          ; Get byte
20B6: B7      	        OR      A               ; Is it zero (No input) ?
20B7: 2B      	        DEC     HL              ; Back space INPUT pointer
20B8: C5      	        PUSH    BC              ; Save code string address
20B9: CAC21E  	        JP      Z,NXTDTA        ; Find end of buffer
20BC: D5      	        PUSH    DE              ; Save variable address
20BD: 3AF280  	ANTVLU: LD      A,(TYPE)        ; Check data type
20C0: B7      	        OR      A               ; Is it numeric?
20C1: CAE720  	        JP      Z,INPBIN        ; Yes - Convert to binary
20C4: CD271D  	        CALL    GETCHR          ; Get next character
20C7: 57      	        LD      D,A             ; Save input character
20C8: 47      	        LD      B,A             ; Again
20C9: FE22    	        CP      '"'             ; Start of literal sting?
20CB: CADB20  	        JP      Z,STRENT        ; Yes - Create string entry
20CE: 3A1281  	        LD      A,(READFG)      ; "READ" or "INPUT" ?
20D1: B7      	        OR      A
20D2: 57      	        LD      D,A             ; Save 00 if "INPUT"
20D3: CAD820  	        JP      Z,ITMSEP        ; "INPUT" - End with 00
20D6: 163A    	        LD      D,':'           ; "DATA" - End with 00 or ':'
20D8: 062C    	ITMSEP: LD      B,','           ; Item separator
20DA: 2B      	        DEC     HL              ; Back space for DTSTR
20DB: CD4426  	STRENT: CALL    DTSTR           ; Get string terminated by D
20DE: EB      	        EX      DE,HL           ; String address to DE
20DF: 21F220  	        LD      HL,LTSTND       ; Where to go after LETSTR
20E2: E3      	        EX      (SP),HL         ; Save HL , get input pointer
20E3: D5      	        PUSH    DE              ; Save address of string
20E4: C3F51E  	        JP      LETSTR          ; Assign string to variable
              	
20E7: CD271D  	INPBIN: CALL    GETCHR          ; Get next character
20EA: CD922C  	        CALL    ASCTFP          ; Convert ASCII to FP number
20ED: E3      	        EX      (SP),HL         ; Save input ptr, Get var addr
20EE: CDE32B  	        CALL    FPTHL           ; Move FPREG to variable
20F1: E1      	        POP     HL              ; Restore input pointer
20F2: 2B      	LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
20F3: CD271D  	        CALL    GETCHR          ; Get next character
20F6: CAFE20  	        JP      Z,MORDT         ; End of line - More needed?
20F9: FE2C    	        CP      ','             ; Another value?
20FB: C24420  	        JP      NZ,BADINP       ; No - Bad input
20FE: E3      	MORDT:  EX      (SP),HL         ; Get code string address
20FF: 2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2100: CD271D  	        CALL    GETCHR          ; Get next character
2103: C29120  	        JP      NZ,NEDMOR       ; More needed - Get it
2106: D1      	        POP     DE              ; Restore DATA pointer
2107: 3A1281  	        LD      A,(READFG)      ; "READ" or "INPUT" ?
210A: B7      	        OR      A
210B: EB      	        EX      DE,HL           ; DATA pointer to HL
210C: C24D1D  	        JP      NZ,UPDATA       ; Update DATA pointer if "READ"
210F: D5      	        PUSH    DE              ; Save code string address
2110: B6      	        OR      (HL)            ; More input given?
2111: 211921  	        LD      HL,EXTIG        ; "?Extra ignored" message
2114: C48226  	        CALL    NZ,PRS          ; Output string if extra given
2117: E1      	        POP     HL              ; Restore code string address
2118: C9      	        RET
              	
2119: 3F457874	EXTIG:  DB   "?Extra ignored",CR,LF,0
211D: 72612069	
2121: 676E6F72	
2125: 65640D0A	
2129: 00      	
              	
212A: CDC31E  	FDTLP:  CALL    DATA            ; Get next statement
212D: B7      	        OR      A               ; End of line?
212E: C24321  	        JP      NZ,FANDT        ; No - See if DATA statement
2131: 23      	        INC     HL
2132: 7E      	        LD      A,(HL)          ; End of program?
2133: 23      	        INC     HL
2134: B6      	        OR      (HL)            ; 00 00 Ends program
2135: 1E06    	        LD      E,OD            ; ?OD Error
2137: CAE618  	        JP      Z,ERROR         ; Yes - Out of DATA
213A: 23      	        INC     HL
213B: 5E      	        LD      E,(HL)          ; LSB of line number
213C: 23      	        INC     HL
213D: 56      	        LD      D,(HL)          ; MSB of line number
213E: EB      	        EX      DE,HL
213F: 220E81  	        LD      (DATLIN),HL     ; Set line of current DATA item
2142: EB      	        EX      DE,HL
2143: CD271D  	FANDT:  CALL    GETCHR          ; Get next character
2146: FE83    	        CP      ZDATA           ; "DATA" token
2148: C22A21  	        JP      NZ,FDTLP        ; No "DATA" - Keep looking
214B: C3BD20  	        JP      ANTVLU          ; Found - Convert input
              	
214E: 110000  	NEXT:   LD      DE,0            ; In case no index given
2151: C48F23  	NEXT1:  CALL    NZ,GETVAR       ; Get index address
2154: 221381  	        LD      (BRKLIN),HL     ; Save code string address
2157: CD7B18  	        CALL    BAKSTK          ; Look for "FOR" block
215A: C2D818  	        JP      NZ,NFERR        ; No "FOR" - ?NF Error
215D: F9      	        LD      SP,HL           ; Clear nested loops
215E: D5      	        PUSH    DE              ; Save index address
215F: 7E      	        LD      A,(HL)          ; Get sign of STEP
2160: 23      	        INC     HL
2161: F5      	        PUSH    AF              ; Save sign of STEP
2162: D5      	        PUSH    DE              ; Save index address
2163: CDC92B  	        CALL    PHLTFP          ; Move index value to FPREG
2166: E3      	        EX      (SP),HL         ; Save address of TO value
2167: E5      	        PUSH    HL              ; Save address of index
2168: CD3629  	        CALL    ADDPHL          ; Add STEP to index value
216B: E1      	        POP     HL              ; Restore address of index
216C: CDE32B  	        CALL    FPTHL           ; Move value to index variable
216F: E1      	        POP     HL              ; Restore address of TO value
2170: CDDA2B  	        CALL    LOADFP          ; Move TO value to BCDE
2173: E5      	        PUSH    HL              ; Save address of line of FOR
2174: CD062C  	        CALL    CMPNUM          ; Compare index with TO value
2177: E1      	        POP     HL              ; Restore address of line num
2178: C1      	        POP     BC              ; Address of sign of STEP
2179: 90      	        SUB     B               ; Compare with expected sign
217A: CDDA2B  	        CALL    LOADFP          ; BC = Loop stmt,DE = Line num
217D: CA8921  	        JP      Z,KILFOR        ; Loop finished - Terminate it
2180: EB      	        EX      DE,HL           ; Loop statement line number
2181: 22A180  	        LD      (LINEAT),HL     ; Set loop line number
2184: 69      	        LD      L,C             ; Set code string to loop
2185: 60      	        LD      H,B
2186: C3E31C  	        JP      PUTFID          ; Put back "FOR" and continue
              	
2189: F9      	KILFOR: LD      SP,HL           ; Remove "FOR" block
218A: 2A1381  	        LD      HL,(BRKLIN)     ; Code string after "NEXT"
218D: 7E      	        LD      A,(HL)          ; Get next byte in code string
218E: FE2C    	        CP      ','             ; More NEXTs ?
2190: C2E71C  	        JP      NZ,RUNCNT       ; No - Do next statement
2193: CD271D  	        CALL    GETCHR          ; Position to index name
2196: CD5121  	        CALL    NEXT1           ; Re-enter NEXT routine
              	; < will not RETurn to here , Exit to RUNCNT or Loop >
              	
2199: CDAB21  	GETNUM: CALL    EVAL            ; Get a numeric expression
219C: F6      	TSTNUM: DB      0F6H            ; Clear carry (numeric)
219D: 37      	TSTSTR: SCF                     ; Set carry (string)
219E: 3AF280  	CHKTYP: LD      A,(TYPE)        ; Check types match
21A1: 8F      	        ADC     A,A             ; Expected + actual
21A2: B7      	        OR      A               ; Clear carry , set parity
21A3: E8      	        RET     PE              ; Even parity - Types match
21A4: C3E418  	        JP      TMERR           ; Different types - Error
              	
21A7: CDA01B  	OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
21AA: 28      	        DB   "("
21AB: 2B      	EVAL:   DEC     HL              ; Evaluate expression & save
21AC: 1600    	        LD      D,0             ; Precedence value
21AE: D5      	EVAL1:  PUSH    DE              ; Save precedence
21AF: 0E01    	        LD      C,1
21B1: CDAF18  	        CALL    CHKSTK          ; Check for 1 level of stack
21B4: CD2222  	        CALL    OPRND           ; Get next expression value
21B7: 221581  	EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
21BA: 2A1581  	EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
21BD: C1      	        POP     BC              ; Precedence value and operator
21BE: 78      	        LD      A,B             ; Get precedence value
21BF: FE78    	        CP      78H             ; "AND" or "OR" ?
21C1: D49C21  	        CALL    NC,TSTNUM       ; No - Make sure it's a number
21C4: 7E      	        LD      A,(HL)          ; Get next operator / function
21C5: 1600    	        LD      D,0             ; Clear Last relation
21C7: D6B9    	RLTLP:  SUB     ZGTR            ; ">" Token
21C9: DAE321  	        JP      C,FOPRND        ; + - * / ^ AND OR - Test it
21CC: FE03    	        CP      ZLTH+1-ZGTR     ; < = >
21CE: D2E321  	        JP      NC,FOPRND       ; Function - Call it
21D1: FE01    	        CP      ZEQUAL-ZGTR     ; "="
21D3: 17      	        RLA                     ; <- Test for legal
21D4: AA      	        XOR     D               ; <- combinations of < = >
21D5: BA      	        CP      D               ; <- by combining last token
21D6: 57      	        LD      D,A             ; <- with current one
21D7: DAD218  	        JP      C,SNERR         ; Error if "<<' '==" or ">>"
21DA: 220A81  	        LD      (CUROPR),HL     ; Save address of current token
21DD: CD271D  	        CALL    GETCHR          ; Get next character
21E0: C3C721  	        JP      RLTLP           ; Treat the two as one
              	
21E3: 7A      	FOPRND: LD      A,D             ; < = > found ?
21E4: B7      	        OR      A
21E5: C20A23  	        JP      NZ,TSTRED       ; Yes - Test for reduction
21E8: 7E      	        LD      A,(HL)          ; Get operator token
21E9: 220A81  	        LD      (CUROPR),HL     ; Save operator address
21EC: D6B2    	        SUB     ZPLUS           ; Operator or function?
21EE: D8      	        RET     C               ; Neither - Exit
21EF: FE07    	        CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
21F1: D0      	        RET     NC              ; No - Exit
21F2: 5F      	        LD      E,A             ; Coded operator
21F3: 3AF280  	        LD      A,(TYPE)        ; Get data type
21F6: 3D      	        DEC     A               ; FF = numeric , 00 = string
21F7: B3      	        OR      E               ; Combine with coded operator
21F8: 7B      	        LD      A,E             ; Get coded operator
21F9: CA7827  	        JP      Z,CONCAT        ; String concatenation
21FC: 07      	        RLCA                    ; Times 2
21FD: 83      	        ADD     A,E             ; Times 3
21FE: 5F      	        LD      E,A             ; To DE (D is 0)
21FF: 21C417  	        LD      HL,PRITAB       ; Precedence table
2202: 19      	        ADD     HL,DE           ; To the operator concerned
2203: 78      	        LD      A,B             ; Last operator precedence
2204: 56      	        LD      D,(HL)          ; Get evaluation precedence
2205: BA      	        CP      D               ; Compare with eval precedence
2206: D0      	        RET     NC              ; Exit if higher precedence
2207: 23      	        INC     HL              ; Point to routine address
2208: CD9C21  	        CALL    TSTNUM          ; Make sure it's a number
              	
220B: C5      	STKTHS: PUSH    BC              ; Save last precedence & token
220C: 01BA21  	        LD      BC,EVAL3        ; Where to go on prec' break
220F: C5      	        PUSH    BC              ; Save on stack for return
2210: 43      	        LD      B,E             ; Save operator
2211: 4A      	        LD      C,D             ; Save precedence
2212: CDBC2B  	        CALL    STAKFP          ; Move value to stack
2215: 58      	        LD      E,B             ; Restore operator
2216: 51      	        LD      D,C             ; Restore precedence
2217: 4E      	        LD      C,(HL)          ; Get LSB of routine address
2218: 23      	        INC     HL
2219: 46      	        LD      B,(HL)          ; Get MSB of routine address
221A: 23      	        INC     HL
221B: C5      	        PUSH    BC              ; Save routine address
221C: 2A0A81  	        LD      HL,(CUROPR)     ; Address of current operator
221F: C3AE21  	        JP      EVAL1           ; Loop until prec' break
              	
2222: AF      	OPRND:  XOR     A               ; Get operand routine
2223: 32F280  	        LD      (TYPE),A        ; Set numeric expected
2226: CD271D  	        CALL    GETCHR          ; Get next character
2229: 1E24    	        LD      E,MO            ; ?MO Error
222B: CAE618  	        JP      Z,ERROR         ; No operand - Error
222E: DA922C  	        JP      C,ASCTFP        ; Number - Get value
2231: CDCA1D  	        CALL    CHKLTR          ; See if a letter
2234: D28922  	        JP      NC,CONVAR       ; Letter - Find variable
2237: FE26    	        CP		'&'				; &H = HEX, &B = BINARY
2239: 2012    	        JR		NZ, NOTAMP
223B: CD271D  	        CALL    GETCHR          ; Get next character
223E: FE48    	        CP      'H'             ; Hex number indicated? [function added]
2240: CA0833  	        JP      Z,HEXTFP        ; Convert Hex to FPREG
2243: FE42    	        CP      'B'             ; Binary number indicated? [function added]
2245: CA7833  	        JP      Z,BINTFP        ; Convert Bin to FPREG
2248: 1E02    	        LD      E,SN            ; If neither then a ?SN Error
224A: CAE618  	        JP      Z,ERROR         ; 
224D: FEB2    	NOTAMP: CP      ZPLUS           ; '+' Token ?
224F: CA2222  	        JP      Z,OPRND         ; Yes - Look for operand
2252: FE2E    	        CP      '.'             ; '.' ?
2254: CA922C  	        JP      Z,ASCTFP        ; Yes - Create FP number
2257: FEB3    	        CP      ZMINUS          ; '-' Token ?
2259: CA7822  	        JP      Z,MINUS         ; Yes - Do minus
225C: FE22    	        CP      '"'             ; Literal string ?
225E: CA4126  	        JP      Z,QTSTR         ; Get string terminated by '"'
2261: FEB0    	        CP      ZNOT            ; "NOT" Token ?
2263: CA6A23  	        JP      Z,EVNOT         ; Yes - Eval NOT expression
2266: FEAD    	        CP      ZFN             ; "FN" Token ?
2268: CAA525  	        JP      Z,DOFN          ; Yes - Do FN routine
226B: D6BC    	        SUB     ZSGN            ; Is it a function?
226D: D29A22  	        JP      NC,FNOFST       ; Yes - Evaluate function
2270: CDA721  	EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
2273: CDA01B  	        CALL    CHKSYN          ; Make sure ")" follows
2276: 29      	        DB   ")"
2277: C9      	        RET
              	
2278: 167D    	MINUS:  LD      D,7DH           ; '-' precedence
227A: CDAE21  	        CALL    EVAL1           ; Evaluate until prec' break
227D: 2A1581  	        LD      HL,(NXTOPR)     ; Get next operator address
2280: E5      	        PUSH    HL              ; Save next operator address
2281: CDB42B  	        CALL    INVSGN          ; Negate value
2284: CD9C21  	RETNUM: CALL    TSTNUM          ; Make sure it's a number
2287: E1      	        POP     HL              ; Restore next operator address
2288: C9      	        RET
              	
2289: CD8F23  	CONVAR: CALL    GETVAR          ; Get variable address to DE
228C: E5      	FRMEVL: PUSH    HL              ; Save code string address
228D: EB      	        EX      DE,HL           ; Variable address to HL
228E: 222981  	        LD      (FPREG),HL      ; Save address of variable
2291: 3AF280  	        LD      A,(TYPE)        ; Get type
2294: B7      	        OR      A               ; Numeric?
2295: CCC92B  	        CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
2298: E1      	        POP     HL              ; Restore code string address
2299: C9      	        RET
              	
229A: 0600    	FNOFST: LD      B,0             ; Get address of function
229C: 07      	        RLCA                    ; Double function offset
229D: 4F      	        LD      C,A             ; BC = Offset in function table
229E: C5      	        PUSH    BC              ; Save adjusted token value
229F: CD271D  	        CALL    GETCHR          ; Get next character
22A2: 79      	        LD      A,C             ; Get adjusted token value
22A3: FE33    	        CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
22A5: DAC122  	        JP      C,FNVAL         ; No - Do function
22A8: CDA721  	        CALL    OPNPAR          ; Evaluate expression  (X,...
22AB: CDA01B  	        CALL    CHKSYN          ; Make sure ',' follows
22AE: 2C      	        DB      ','
22AF: CD9D21  	        CALL    TSTSTR          ; Make sure it's a string
22B2: EB      	        EX      DE,HL           ; Save code string address
22B3: 2A2981  	        LD      HL,(FPREG)      ; Get address of string
22B6: E3      	        EX      (SP),HL         ; Save address of string
22B7: E5      	        PUSH    HL              ; Save adjusted token value
22B8: EB      	        EX      DE,HL           ; Restore code string address
22B9: CD0A29  	        CALL    GETINT          ; Get integer 0-255
22BC: EB      	        EX      DE,HL           ; Save code string address
22BD: E3      	        EX      (SP),HL         ; Save integer,HL = adj' token
22BE: C3C922  	        JP      GOFUNC          ; Jump to string function
              	
22C1: CD7022  	FNVAL:  CALL    EVLPAR          ; Evaluate expression
22C4: E3      	        EX      (SP),HL         ; HL = Adjusted token value
22C5: 118422  	        LD      DE,RETNUM       ; Return number from function
22C8: D5      	        PUSH    DE              ; Save on stack
22C9: 01F515  	GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
22CC: 09      	        ADD     HL,BC           ; Point to right address
22CD: 4E      	        LD      C,(HL)          ; Get LSB of address
22CE: 23      	        INC     HL              ;
22CF: 66      	        LD      H,(HL)          ; Get MSB of address
22D0: 69      	        LD      L,C             ; Address to HL
22D1: E9      	        JP      (HL)            ; Jump to function
              	
22D2: 15      	SGNEXP: DEC     D               ; Dee to flag negative exponent
22D3: FEB3    	        CP      ZMINUS          ; '-' token ?
22D5: C8      	        RET     Z               ; Yes - Return
22D6: FE2D    	        CP      '-'             ; '-' ASCII ?
22D8: C8      	        RET     Z               ; Yes - Return
22D9: 14      	        INC     D               ; Inc to flag positive exponent
22DA: FE2B    	        CP      '+'             ; '+' ASCII ?
22DC: C8      	        RET     Z               ; Yes - Return
22DD: FEB2    	        CP      ZPLUS           ; '+' token ?
22DF: C8      	        RET     Z               ; Yes - Return
22E0: 2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
22E1: C9      	        RET                     ; Return "NZ"
              	
22E2: F6      	POR:    DB      0F6H            ; Flag "OR"
22E3: AF      	PAND:   XOR     A               ; Flag "AND"
22E4: F5      	        PUSH    AF              ; Save "AND" / "OR" flag
22E5: CD9C21  	        CALL    TSTNUM          ; Make sure it's a number
22E8: CDDE1D  	        CALL    DEINT           ; Get integer -32768 to 32767
22EB: F1      	        POP     AF              ; Restore "AND" / "OR" flag
22EC: EB      	        EX      DE,HL           ; <- Get last
22ED: C1      	        POP     BC              ; <-  value
22EE: E3      	        EX      (SP),HL         ; <-  from
22EF: EB      	        EX      DE,HL           ; <-  stack
22F0: CDCC2B  	        CALL    FPBCDE          ; Move last value to FPREG
22F3: F5      	        PUSH    AF              ; Save "AND" / "OR" flag
22F4: CDDE1D  	        CALL    DEINT           ; Get integer -32768 to 32767
22F7: F1      	        POP     AF              ; Restore "AND" / "OR" flag
22F8: C1      	        POP     BC              ; Get value
22F9: 79      	        LD      A,C             ; Get LSB
22FA: 215325  	        LD      HL,ACPASS       ; Address of save AC as current
22FD: C20523  	        JP      NZ,POR1         ; Jump if OR
2300: A3      	        AND     E               ; "AND" LSBs
2301: 4F      	        LD      C,A             ; Save LSB
2302: 78      	        LD      A,B             ; Get MBS
2303: A2      	        AND     D               ; "AND" MSBs
2304: E9      	        JP      (HL)            ; Save AC as current (ACPASS)
              	
2305: B3      	POR1:   OR      E               ; "OR" LSBs
2306: 4F      	        LD      C,A             ; Save LSB
2307: 78      	        LD      A,B             ; Get MSB
2308: B2      	        OR      D               ; "OR" MSBs
2309: E9      	        JP      (HL)            ; Save AC as current (ACPASS)
              	
230A: 211C23  	TSTRED: LD      HL,CMPLOG       ; Logical compare routine
230D: 3AF280  	        LD      A,(TYPE)        ; Get data type
2310: 1F      	        RRA                     ; Carry set = string
2311: 7A      	        LD      A,D             ; Get last precedence value
2312: 17      	        RLA                     ; Times 2 plus carry
2313: 5F      	        LD      E,A             ; To E
2314: 1664    	        LD      D,64H           ; Relational precedence
2316: 78      	        LD      A,B             ; Get current precedence
2317: BA      	        CP      D               ; Compare with last
2318: D0      	        RET     NC              ; Eval if last was rel' or log'
2319: C30B22  	        JP      STKTHS          ; Stack this one and get next
              	
231C: 1E23    	CMPLOG: DW   CMPLG1          ; Compare two values / strings
231E: 79      	CMPLG1: LD      A,C             ; Get data type
231F: B7      	        OR      A
2320: 1F      	        RRA
2321: C1      	        POP     BC              ; Get last expression to BCDE
2322: D1      	        POP     DE
2323: F5      	        PUSH    AF              ; Save status
2324: CD9E21  	        CALL    CHKTYP          ; Check that types match
2327: 216023  	        LD      HL,CMPRES       ; Result to comparison
232A: E5      	        PUSH    HL              ; Save for RETurn
232B: CA062C  	        JP      Z,CMPNUM        ; Compare values if numeric
232E: AF      	        XOR     A               ; Compare two strings
232F: 32F280  	        LD      (TYPE),A        ; Set type to numeric
2332: D5      	        PUSH    DE              ; Save string name
2333: CDC527  	        CALL    GSTRCU          ; Get current string
2336: 7E      	        LD      A,(HL)          ; Get length of string
2337: 23      	        INC     HL
2338: 23      	        INC     HL
2339: 4E      	        LD      C,(HL)          ; Get LSB of address
233A: 23      	        INC     HL
233B: 46      	        LD      B,(HL)          ; Get MSB of address
233C: D1      	        POP     DE              ; Restore string name
233D: C5      	        PUSH    BC              ; Save address of string
233E: F5      	        PUSH    AF              ; Save length of string
233F: CDC927  	        CALL    GSTRDE          ; Get second string
2342: CDDA2B  	        CALL    LOADFP          ; Get address of second string
2345: F1      	        POP     AF              ; Restore length of string 1
2346: 57      	        LD      D,A             ; Length to D
2347: E1      	        POP     HL              ; Restore address of string 1
2348: 7B      	CMPSTR: LD      A,E             ; Bytes of string 2 to do
2349: B2      	        OR      D               ; Bytes of string 1 to do
234A: C8      	        RET     Z               ; Exit if all bytes compared
234B: 7A      	        LD      A,D             ; Get bytes of string 1 to do
234C: D601    	        SUB     1
234E: D8      	        RET     C               ; Exit if end of string 1
234F: AF      	        XOR     A
2350: BB      	        CP      E               ; Bytes of string 2 to do
2351: 3C      	        INC     A
2352: D0      	        RET     NC              ; Exit if end of string 2
2353: 15      	        DEC     D               ; Count bytes in string 1
2354: 1D      	        DEC     E               ; Count bytes in string 2
2355: 0A      	        LD      A,(BC)          ; Byte in string 2
2356: BE      	        CP      (HL)            ; Compare to byte in string 1
2357: 23      	        INC     HL              ; Move up string 1
2358: 03      	        INC     BC              ; Move up string 2
2359: CA4823  	        JP      Z,CMPSTR        ; Same - Try next bytes
235C: 3F      	        CCF                     ; Flag difference (">" or "<")
235D: C3962B  	        JP      FLGDIF          ; "<" gives -1 , ">" gives +1
              	
2360: 3C      	CMPRES: INC     A               ; Increment current value
2361: 8F      	        ADC     A,A             ; Double plus carry
2362: C1      	        POP     BC              ; Get other value
2363: A0      	        AND     B               ; Combine them
2364: C6FF    	        ADD     A,-1            ; Carry set if different
2366: 9F      	        SBC     A,A             ; 00 - Equal , FF - Different
2367: C39D2B  	        JP      FLGREL          ; Set current value & continue
              	
236A: 165A    	EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
236C: CDAE21  	        CALL    EVAL1           ; Eval until precedence break
236F: CD9C21  	        CALL    TSTNUM          ; Make sure it's a number
2372: CDDE1D  	        CALL    DEINT           ; Get integer -32768 - 32767
2375: 7B      	        LD      A,E             ; Get LSB
2376: 2F      	        CPL                     ; Invert LSB
2377: 4F      	        LD      C,A             ; Save "NOT" of LSB
2378: 7A      	        LD      A,D             ; Get MSB
2379: 2F      	        CPL                     ; Invert MSB
237A: CD5325  	        CALL    ACPASS          ; Save AC as current
237D: C1      	        POP     BC              ; Clean up stack
237E: C3BA21  	        JP      EVAL3           ; Continue evaluation
              	
2381: 2B      	DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2382: CD271D  	        CALL    GETCHR          ; Get next character
2385: C8      	        RET     Z               ; End of DIM statement
2386: CDA01B  	        CALL    CHKSYN          ; Make sure ',' follows
2389: 2C      	        DB      ','
238A: 018123  	DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
238D: C5      	        PUSH    BC              ; Save on stack
238E: F6      	        DB      0F6H            ; Flag "Create" variable
238F: AF      	GETVAR: XOR     A               ; Find variable address,to DE
2390: 32F180  	        LD      (LCRFLG),A      ; Set locate / create flag
2393: 46      	        LD      B,(HL)          ; Get First byte of name
2394: CDCA1D  	GTFNAM: CALL    CHKLTR          ; See if a letter
2397: DAD218  	        JP      C,SNERR         ; ?SN Error if not a letter
239A: AF      	        XOR     A
239B: 4F      	        LD      C,A             ; Clear second byte of name
239C: 32F280  	        LD      (TYPE),A        ; Set type to numeric
239F: CD271D  	        CALL    GETCHR          ; Get next character
23A2: DAAB23  	        JP      C,SVNAM2        ; Numeric - Save in name
23A5: CDCA1D  	        CALL    CHKLTR          ; See if a letter
23A8: DAB823  	        JP      C,CHARTY        ; Not a letter - Check type
23AB: 4F      	SVNAM2: LD      C,A             ; Save second byte of name
23AC: CD271D  	ENDNAM: CALL    GETCHR          ; Get next character
23AF: DAAC23  	        JP      C,ENDNAM        ; Numeric - Get another
23B2: CDCA1D  	        CALL    CHKLTR          ; See if a letter
23B5: D2AC23  	        JP      NC,ENDNAM       ; Letter - Get another
23B8: D624    	CHARTY: SUB     '$'             ; String variable?
23BA: C2C723  	        JP      NZ,NOTSTR       ; No - Numeric variable
23BD: 3C      	        INC     A               ; A = 1 (string type)
23BE: 32F280  	        LD      (TYPE),A        ; Set type to string
23C1: 0F      	        RRCA                    ; A = 80H , Flag for string
23C2: 81      	        ADD     A,C             ; 2nd byte of name has bit 7 on
23C3: 4F      	        LD      C,A             ; Resave second byte on name
23C4: CD271D  	        CALL    GETCHR          ; Get next character
23C7: 3A1081  	NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
23CA: 3D      	        DEC     A
23CB: CA7424  	        JP      Z,ARLDSV        ; Yes - Get array name
23CE: F2D723  	        JP      P,NSCFOR        ; No array with "FOR" or "FN"
23D1: 7E      	        LD      A,(HL)          ; Get byte again
23D2: D628    	        SUB     '('             ; Subscripted variable?
23D4: CA4C24  	        JP      Z,SBSCPT        ; Yes - Sort out subscript
              	
23D7: AF      	NSCFOR: XOR     A               ; Simple variable
23D8: 321081  	        LD      (FORFLG),A      ; Clear "FOR" flag
23DB: E5      	        PUSH    HL              ; Save code string address
23DC: 50      	        LD      D,B             ; DE = Variable name to find
23DD: 59      	        LD      E,C
23DE: 2A2381  	        LD      HL,(FNRGNM)     ; FN argument name
23E1: CD9A1B  	        CALL    CPDEHL          ; Is it the FN argument?
23E4: 112581  	        LD      DE,FNARG        ; Point to argument value
23E7: CACC2A  	        JP      Z,POPHRT        ; Yes - Return FN argument value
23EA: 2A1D81  	        LD      HL,(VAREND)     ; End of variables
23ED: EB      	        EX      DE,HL           ; Address of end of search
23EE: 2A1B81  	        LD      HL,(PROGND)     ; Start of variables address
23F1: CD9A1B  	FNDVAR: CALL    CPDEHL          ; End of variable list table?
23F4: CA0A24  	        JP      Z,CFEVAL        ; Yes - Called from EVAL?
23F7: 79      	        LD      A,C             ; Get second byte of name
23F8: 96      	        SUB     (HL)            ; Compare with name in list
23F9: 23      	        INC     HL              ; Move on to first byte
23FA: C2FF23  	        JP      NZ,FNTHR        ; Different - Find another
23FD: 78      	        LD      A,B             ; Get first byte of name
23FE: 96      	        SUB     (HL)            ; Compare with name in list
23FF: 23      	FNTHR:  INC     HL              ; Move on to LSB of value
2400: CA3E24  	        JP      Z,RETADR        ; Found - Return address
2403: 23      	        INC     HL              ; <- Skip
2404: 23      	        INC     HL              ; <- over
2405: 23      	        INC     HL              ; <- F.P.
2406: 23      	        INC     HL              ; <- value
2407: C3F123  	        JP      FNDVAR          ; Keep looking
              	
240A: E1      	CFEVAL: POP     HL              ; Restore code string address
240B: E3      	        EX      (SP),HL         ; Get return address
240C: D5      	        PUSH    DE              ; Save address of variable
240D: 118C22  	        LD      DE,FRMEVL       ; Return address in EVAL
2410: CD9A1B  	        CALL    CPDEHL          ; Called from EVAL ?
2413: D1      	        POP     DE              ; Restore address of variable
2414: CA4124  	        JP      Z,RETNUL        ; Yes - Return null variable
2417: E3      	        EX      (SP),HL         ; Put back return
2418: E5      	        PUSH    HL              ; Save code string address
2419: C5      	        PUSH    BC              ; Save variable name
241A: 010600  	        LD      BC,6            ; 2 byte name plus 4 byte data
241D: 2A1F81  	        LD      HL,(ARREND)     ; End of arrays
2420: E5      	        PUSH    HL              ; Save end of arrays
2421: 09      	        ADD     HL,BC           ; Move up 6 bytes
2422: C1      	        POP     BC              ; Source address in BC
2423: E5      	        PUSH    HL              ; Save new end address
2424: CD9E18  	        CALL    MOVUP           ; Move arrays up
2427: E1      	        POP     HL              ; Restore new end address
2428: 221F81  	        LD      (ARREND),HL     ; Set new end address
242B: 60      	        LD      H,B             ; End of variables to HL
242C: 69      	        LD      L,C
242D: 221D81  	        LD      (VAREND),HL     ; Set new end address
              	
2430: 2B      	ZEROLP: DEC     HL              ; Back through to zero variable
2431: 3600    	        LD      (HL),0          ; Zero byte in variable
2433: CD9A1B  	        CALL    CPDEHL          ; Done them all?
2436: C23024  	        JP      NZ,ZEROLP       ; No - Keep on going
2439: D1      	        POP     DE              ; Get variable name
243A: 73      	        LD      (HL),E          ; Store second character
243B: 23      	        INC     HL
243C: 72      	        LD      (HL),D          ; Store first character
243D: 23      	        INC     HL
243E: EB      	RETADR: EX      DE,HL           ; Address of variable in DE
243F: E1      	        POP     HL              ; Restore code string address
2440: C9      	        RET
              	
2441: 322C81  	RETNUL: LD      (FPEXP),A       ; Set result to zero
2444: 216E18  	        LD      HL,ZERBYT       ; Also set a null string
2447: 222981  	        LD      (FPREG),HL      ; Save for EVAL
244A: E1      	        POP     HL              ; Restore code string address
244B: C9      	        RET
              	
244C: E5      	SBSCPT: PUSH    HL              ; Save code string address
244D: 2AF180  	        LD      HL,(LCRFLG)     ; Locate/Create and Type
2450: E3      	        EX      (SP),HL         ; Save and get code string
2451: 57      	        LD      D,A             ; Zero number of dimensions
2452: D5      	SCPTLP: PUSH    DE              ; Save number of dimensions
2453: C5      	        PUSH    BC              ; Save array name
2454: CDD21D  	        CALL    FPSINT          ; Get subscript (0-32767)
2457: C1      	        POP     BC              ; Restore array name
2458: F1      	        POP     AF              ; Get number of dimensions
2459: EB      	        EX      DE,HL
245A: E3      	        EX      (SP),HL         ; Save subscript value
245B: E5      	        PUSH    HL              ; Save LCRFLG and TYPE
245C: EB      	        EX      DE,HL
245D: 3C      	        INC     A               ; Count dimensions
245E: 57      	        LD      D,A             ; Save in D
245F: 7E      	        LD      A,(HL)          ; Get next byte in code string
2460: FE2C    	        CP      ','             ; Comma (more to come)?
2462: CA5224  	        JP      Z,SCPTLP        ; Yes - More subscripts
2465: CDA01B  	        CALL    CHKSYN          ; Make sure ")" follows
2468: 29      	        DB      ")"
2469: 221581  	        LD      (NXTOPR),HL     ; Save code string address
246C: E1      	        POP     HL              ; Get LCRFLG and TYPE
246D: 22F180  	        LD      (LCRFLG),HL     ; Restore Locate/create & type
2470: 1E00    	        LD      E,0             ; Flag not CSAVE* or CLOAD*
2472: D5      	        PUSH    DE              ; Save number of dimensions (D)
2473: 11      	        DB      11H             ; Skip "PUSH HL" and "PUSH AF'
              	
2474: E5      	ARLDSV: PUSH    HL              ; Save code string address
2475: F5      	        PUSH    AF              ; A = 00 , Flags set = Z,N
2476: 2A1D81  	        LD      HL,(VAREND)     ; Start of arrays
2479: 3E      	        DB      3EH             ; Skip "ADD HL,DE"
247A: 19      	FNDARY: ADD     HL,DE           ; Move to next array start
247B: EB      	        EX      DE,HL
247C: 2A1F81  	        LD      HL,(ARREND)     ; End of arrays
247F: EB      	        EX      DE,HL           ; Current array pointer
2480: CD9A1B  	        CALL    CPDEHL          ; End of arrays found?
2483: CAAC24  	        JP      Z,CREARY        ; Yes - Create array
2486: 7E      	        LD      A,(HL)          ; Get second byte of name
2487: B9      	        CP      C               ; Compare with name given
2488: 23      	        INC     HL              ; Move on
2489: C28E24  	        JP      NZ,NXTARY       ; Different - Find next array
248C: 7E      	        LD      A,(HL)          ; Get first byte of name
248D: B8      	        CP      B               ; Compare with name given
248E: 23      	NXTARY: INC     HL              ; Move on
248F: 5E      	        LD      E,(HL)          ; Get LSB of next array address
2490: 23      	        INC     HL
2491: 56      	        LD      D,(HL)          ; Get MSB of next array address
2492: 23      	        INC     HL
2493: C27A24  	        JP      NZ,FNDARY       ; Not found - Keep looking
2496: 3AF180  	        LD      A,(LCRFLG)      ; Found Locate or Create it?
2499: B7      	        OR      A
249A: C2DB18  	        JP      NZ,DDERR        ; Create - ?DD Error
249D: F1      	        POP     AF              ; Locate - Get number of dim'ns
249E: 44      	        LD      B,H             ; BC Points to array dim'ns
249F: 4D      	        LD      C,L
24A0: CACC2A  	        JP      Z,POPHRT        ; Jump if array load/save
24A3: 96      	        SUB     (HL)            ; Same number of dimensions?
24A4: CA0A25  	        JP      Z,FINDEL        ; Yes - Find element
24A7: 1E10    	BSERR:  LD      E,BS            ; ?BS Error
24A9: C3E618  	        JP      ERROR           ; Output error
              	
24AC: 110400  	CREARY: LD      DE,4            ; 4 Bytes per entry
24AF: F1      	        POP     AF              ; Array to save or 0 dim'ns?
24B0: CAF31D  	        JP      Z,FCERR         ; Yes - ?FC Error
24B3: 71      	        LD      (HL),C          ; Save second byte of name
24B4: 23      	        INC     HL
24B5: 70      	        LD      (HL),B          ; Save first byte of name
24B6: 23      	        INC     HL
24B7: 4F      	        LD      C,A             ; Number of dimensions to C
24B8: CDAF18  	        CALL    CHKSTK          ; Check if enough memory
24BB: 23      	        INC     HL              ; Point to number of dimensions
24BC: 23      	        INC     HL
24BD: 220A81  	        LD      (CUROPR),HL     ; Save address of pointer
24C0: 71      	        LD      (HL),C          ; Set number of dimensions
24C1: 23      	        INC     HL
24C2: 3AF180  	        LD      A,(LCRFLG)      ; Locate of Create?
24C5: 17      	        RLA                     ; Carry set = Create
24C6: 79      	        LD      A,C             ; Get number of dimensions
24C7: 010B00  	CRARLP: LD      BC,10+1         ; Default dimension size 10
24CA: D2CF24  	        JP      NC,DEFSIZ       ; Locate - Set default size
24CD: C1      	        POP     BC              ; Get specified dimension size
24CE: 03      	        INC     BC              ; Include zero element
24CF: 71      	DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
24D0: 23      	        INC     HL
24D1: 70      	        LD      (HL),B          ; Save MSB of dimension size
24D2: 23      	        INC     HL
24D3: F5      	        PUSH    AF              ; Save num' of dim'ns an status
24D4: E5      	        PUSH    HL              ; Save address of dim'n size
24D5: CD772C  	        CALL    MLDEBC          ; Multiply DE by BC to find
24D8: EB      	        EX      DE,HL           ; amount of mem needed (to DE)
24D9: E1      	        POP     HL              ; Restore address of dimension
24DA: F1      	        POP     AF              ; Restore number of dimensions
24DB: 3D      	        DEC     A               ; Count them
24DC: C2C724  	        JP      NZ,CRARLP       ; Do next dimension if more
24DF: F5      	        PUSH    AF              ; Save locate/create flag
24E0: 42      	        LD      B,D             ; MSB of memory needed
24E1: 4B      	        LD      C,E             ; LSB of memory needed
24E2: EB      	        EX      DE,HL
24E3: 19      	        ADD     HL,DE           ; Add bytes to array start
24E4: DAC718  	        JP      C,OMERR         ; Too big - Error
24E7: CDB818  	        CALL    ENFMEM          ; See if enough memory
24EA: 221F81  	        LD      (ARREND),HL     ; Save new end of array
              	
24ED: 2B      	ZERARY: DEC     HL              ; Back through array data
24EE: 3600    	        LD      (HL),0          ; Set array element to zero
24F0: CD9A1B  	        CALL    CPDEHL          ; All elements zeroed?
24F3: C2ED24  	        JP      NZ,ZERARY       ; No - Keep on going
24F6: 03      	        INC     BC              ; Number of bytes + 1
24F7: 57      	        LD      D,A             ; A=0
24F8: 2A0A81  	        LD      HL,(CUROPR)     ; Get address of array
24FB: 5E      	        LD      E,(HL)          ; Number of dimensions
24FC: EB      	        EX      DE,HL           ; To HL
24FD: 29      	        ADD     HL,HL           ; Two bytes per dimension size
24FE: 09      	        ADD     HL,BC           ; Add number of bytes
24FF: EB      	        EX      DE,HL           ; Bytes needed to DE
2500: 2B      	        DEC     HL
2501: 2B      	        DEC     HL
2502: 73      	        LD      (HL),E          ; Save LSB of bytes needed
2503: 23      	        INC     HL
2504: 72      	        LD      (HL),D          ; Save MSB of bytes needed
2505: 23      	        INC     HL
2506: F1      	        POP     AF              ; Locate / Create?
2507: DA2E25  	        JP      C,ENDDIM        ; A is 0 , End if create
250A: 47      	FINDEL: LD      B,A             ; Find array element
250B: 4F      	        LD      C,A
250C: 7E      	        LD      A,(HL)          ; Number of dimensions
250D: 23      	        INC     HL
250E: 16      	        DB      16H             ; Skip "POP HL"
250F: E1      	FNDELP: POP     HL              ; Address of next dim' size
2510: 5E      	        LD      E,(HL)          ; Get LSB of dim'n size
2511: 23      	        INC     HL
2512: 56      	        LD      D,(HL)          ; Get MSB of dim'n size
2513: 23      	        INC     HL
2514: E3      	        EX      (SP),HL         ; Save address - Get index
2515: F5      	        PUSH    AF              ; Save number of dim'ns
2516: CD9A1B  	        CALL    CPDEHL          ; Dimension too large?
2519: D2A724  	        JP      NC,BSERR        ; Yes - ?BS Error
251C: E5      	        PUSH    HL              ; Save index
251D: CD772C  	        CALL    MLDEBC          ; Multiply previous by size
2520: D1      	        POP     DE              ; Index supplied to DE
2521: 19      	        ADD     HL,DE           ; Add index to pointer
2522: F1      	        POP     AF              ; Number of dimensions
2523: 3D      	        DEC     A               ; Count them
2524: 44      	        LD      B,H             ; MSB of pointer
2525: 4D      	        LD      C,L             ; LSB of pointer
2526: C20F25  	        JP      NZ,FNDELP       ; More - Keep going
2529: 29      	        ADD     HL,HL           ; 4 Bytes per element
252A: 29      	        ADD     HL,HL
252B: C1      	        POP     BC              ; Start of array
252C: 09      	        ADD     HL,BC           ; Point to element
252D: EB      	        EX      DE,HL           ; Address of element to DE
252E: 2A1581  	ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
2531: C9      	        RET
              	
2532: 2A1F81  	FRE:    LD      HL,(ARREND)     ; Start of free memory
2535: EB      	        EX      DE,HL           ; To DE
2536: 210000  	        LD      HL,0            ; End of free memory
2539: 39      	        ADD     HL,SP           ; Current stack value
253A: 3AF280  	        LD      A,(TYPE)        ; Dummy argument type
253D: B7      	        OR      A
253E: CA4E25  	        JP      Z,FRENUM        ; Numeric - Free variable space
2541: CDC527  	        CALL    GSTRCU          ; Current string to pool
2544: CDC526  	        CALL    GARBGE          ; Garbage collection
2547: 2A9F80  	        LD      HL,(STRSPC)     ; Bottom of string space in use
254A: EB      	        EX      DE,HL           ; To DE
254B: 2A0881  	        LD      HL,(STRBOT)     ; Bottom of string space
254E: 7D      	FRENUM: LD      A,L             ; Get LSB of end
254F: 93      	        SUB     E               ; Subtract LSB of beginning
2550: 4F      	        LD      C,A             ; Save difference if C
2551: 7C      	        LD      A,H             ; Get MSB of end
2552: 9A      	        SBC     A,D             ; Subtract MSB of beginning
2553: 41      	ACPASS: LD      B,C             ; Return integer AC
2554: 50      	ABPASS: LD      D,B             ; Return integer AB
2555: 1E00    	        LD      E,0
2557: 21F280  	        LD      HL,TYPE         ; Point to type
255A: 73      	        LD      (HL),E          ; Set type to numeric
255B: 0690    	        LD      B,80H+16        ; 16 bit integer
255D: C3A22B  	        JP      RETINT          ; Return the integr
              	
2560: 3AF080  	POS:    LD      A,(CURPOS)      ; Get cursor position
2563: 47      	PASSA:  LD      B,A             ; Put A into AB
2564: AF      	        XOR     A               ; Zero A
2565: C35425  	        JP      ABPASS          ; Return integer AB
              	
2568: 3A1EFF  	INKEY:  LD A,(INKEYVALUE)       ; Get key pressed, null if no key pressed
256B: F5      	        PUSH AF                 ; Save the key
256C: 3E00    	        LD A, 00H               ; Reset to no key pressed for next time
256E: 321EFF  	        LD (INKEYVALUE),A
2571: F1      	        POP AF                  ; Get orig key pressed
2572: 47      	        LD      B,A             ; Put A into AB
2573: 3E00    	        LD      A,00H           ; Zero A
2575: C35425  	        JP      ABPASS          ; Return integer AB
              	
2578: CDFB25  	DEF:    CALL    CHEKFN          ; Get "FN" and name
257B: CDED25  	        CALL    IDTEST          ; Test for illegal direct
257E: 01C31E  	        LD      BC,DATA         ; To get next statement
2581: C5      	        PUSH    BC              ; Save address for RETurn
2582: D5      	        PUSH    DE              ; Save address of function ptr
2583: CDA01B  	        CALL    CHKSYN          ; Make sure "(" follows
2586: 28      	        DB      "("
2587: CD8F23  	        CALL    GETVAR          ; Get argument variable name
258A: E5      	        PUSH    HL              ; Save code string address
258B: EB      	        EX      DE,HL           ; Argument address to HL
258C: 2B      	        DEC     HL
258D: 56      	        LD      D,(HL)          ; Get first byte of arg name
258E: 2B      	        DEC     HL
258F: 5E      	        LD      E,(HL)          ; Get second byte of arg name
2590: E1      	        POP     HL              ; Restore code string address
2591: CD9C21  	        CALL    TSTNUM          ; Make sure numeric argument
2594: CDA01B  	        CALL    CHKSYN          ; Make sure ")" follows
2597: 29      	        DB      ")"
2598: CDA01B  	        CALL    CHKSYN          ; Make sure "=" follows
259B: BA      	        DB      ZEQUAL          ; "=" token
259C: 44      	        LD      B,H             ; Code string address to BC
259D: 4D      	        LD      C,L
259E: E3      	        EX      (SP),HL         ; Save code str , Get FN ptr
259F: 71      	        LD      (HL),C          ; Save LSB of FN code string
25A0: 23      	        INC     HL
25A1: 70      	        LD      (HL),B          ; Save MSB of FN code string
25A2: C33A26  	        JP      SVSTAD          ; Save address and do function
              	
25A5: CDFB25  	DOFN:   CALL    CHEKFN          ; Make sure FN follows
25A8: D5      	        PUSH    DE              ; Save function pointer address
25A9: CD7022  	        CALL    EVLPAR          ; Evaluate expression in "()"
25AC: CD9C21  	        CALL    TSTNUM          ; Make sure numeric result
25AF: E3      	        EX      (SP),HL         ; Save code str , Get FN ptr
25B0: 5E      	        LD      E,(HL)          ; Get LSB of FN code string
25B1: 23      	        INC     HL
25B2: 56      	        LD      D,(HL)          ; Get MSB of FN code string
25B3: 23      	        INC     HL
25B4: 7A      	        LD      A,D             ; And function DEFined?
25B5: B3      	        OR      E
25B6: CADE18  	        JP      Z,UFERR         ; No - ?UF Error
25B9: 7E      	        LD      A,(HL)          ; Get LSB of argument address
25BA: 23      	        INC     HL
25BB: 66      	        LD      H,(HL)          ; Get MSB of argument address
25BC: 6F      	        LD      L,A             ; HL = Arg variable address
25BD: E5      	        PUSH    HL              ; Save it
25BE: 2A2381  	        LD      HL,(FNRGNM)     ; Get old argument name
25C1: E3      	        EX      (SP),HL ;       ; Save old , Get new
25C2: 222381  	        LD      (FNRGNM),HL     ; Set new argument name
25C5: 2A2781  	        LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
25C8: E5      	        PUSH    HL              ; Save it
25C9: 2A2581  	        LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
25CC: E5      	        PUSH    HL              ; Save it
25CD: 212581  	        LD      HL,FNARG        ; HL = Value of argument
25D0: D5      	        PUSH    DE              ; Save FN code string address
25D1: CDE32B  	        CALL    FPTHL           ; Move FPREG to argument
25D4: E1      	        POP     HL              ; Get FN code string address
25D5: CD9921  	        CALL    GETNUM          ; Get value from function
25D8: 2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
25D9: CD271D  	        CALL    GETCHR          ; Get next character
25DC: C2D218  	        JP      NZ,SNERR        ; Bad character in FN - Error
25DF: E1      	        POP     HL              ; Get MSB,EXP of old arg
25E0: 222581  	        LD      (FNARG),HL      ; Restore it
25E3: E1      	        POP     HL              ; Get LSB,NLSB of old arg
25E4: 222781  	        LD      (FNARG+2),HL    ; Restore it
25E7: E1      	        POP     HL              ; Get name of old arg
25E8: 222381  	        LD      (FNRGNM),HL     ; Restore it
25EB: E1      	        POP     HL              ; Restore code string address
25EC: C9      	        RET
              	
25ED: E5      	IDTEST: PUSH    HL              ; Save code string address
25EE: 2AA180  	        LD      HL,(LINEAT)     ; Get current line number
25F1: 23      	        INC     HL              ; -1 means direct statement
25F2: 7C      	        LD      A,H
25F3: B5      	        OR      L
25F4: E1      	        POP     HL              ; Restore code string address
25F5: C0      	        RET     NZ              ; Return if in program
25F6: 1E16    	        LD      E,ID            ; ?ID Error
25F8: C3E618  	        JP      ERROR
              	
25FB: CDA01B  	CHEKFN: CALL    CHKSYN          ; Make sure FN follows
25FE: AD      	        DB      ZFN             ; "FN" token
25FF: 3E80    	        LD      A,80H
2601: 321081  	        LD      (FORFLG),A      ; Flag FN name to find
2604: B6      	        OR      (HL)            ; FN name has bit 7 set
2605: 47      	        LD      B,A             ; in first byte of name
2606: CD9423  	        CALL    GTFNAM          ; Get FN name
2609: C39C21  	        JP      TSTNUM          ; Make sure numeric function
              	
260C: CD9C21  	STR:    CALL    TSTNUM          ; Make sure it's a number
260F: CD302D  	        CALL    NUMASC          ; Turn number into text
2612: CD4026  	STR1:   CALL    CRTST           ; Create string entry for it
2615: CDC527  	        CALL    GSTRCU          ; Current string to pool
2618: 012028  	        LD      BC,TOPOOL       ; Save in string pool
261B: C5      	        PUSH    BC              ; Save address on stack
              	
261C: 7E      	SAVSTR: LD      A,(HL)          ; Get string length
261D: 23      	        INC     HL
261E: 23      	        INC     HL
261F: E5      	        PUSH    HL              ; Save pointer to string
2620: CD9B26  	        CALL    TESTR           ; See if enough string space
2623: E1      	        POP     HL              ; Restore pointer to string
2624: 4E      	        LD      C,(HL)          ; Get LSB of address
2625: 23      	        INC     HL
2626: 46      	        LD      B,(HL)          ; Get MSB of address
2627: CD3426  	        CALL    CRTMST          ; Create string entry
262A: E5      	        PUSH    HL              ; Save pointer to MSB of addr
262B: 6F      	        LD      L,A             ; Length of string
262C: CDB827  	        CALL    TOSTRA          ; Move to string area
262F: D1      	        POP     DE              ; Restore pointer to MSB
2630: C9      	        RET
              	
2631: CD9B26  	MKTMST: CALL    TESTR           ; See if enough string space
2634: 210481  	CRTMST: LD      HL,TMPSTR       ; Temporary string
2637: E5      	        PUSH    HL              ; Save it
2638: 77      	        LD      (HL),A          ; Save length of string
2639: 23      	        INC     HL
263A: 23      	SVSTAD: INC     HL
263B: 73      	        LD      (HL),E          ; Save LSB of address
263C: 23      	        INC     HL
263D: 72      	        LD      (HL),D          ; Save MSB of address
263E: E1      	        POP     HL              ; Restore pointer
263F: C9      	        RET
              	
2640: 2B      	CRTST:  DEC     HL              ; DEC - INCed after
2641: 0622    	QTSTR:  LD      B,'"'           ; Terminating quote
2643: 50      	        LD      D,B             ; Quote to D
2644: E5      	DTSTR:  PUSH    HL              ; Save start
2645: 0EFF    	        LD      C,-1            ; Set counter to -1
2647: 23      	QTSTLP: INC     HL              ; Move on
2648: 7E      	        LD      A,(HL)          ; Get byte
2649: 0C      	        INC     C               ; Count bytes
264A: B7      	        OR      A               ; End of line?
264B: CA5626  	        JP      Z,CRTSTE        ; Yes - Create string entry
264E: BA      	        CP      D               ; Terminator D found?
264F: CA5626  	        JP      Z,CRTSTE        ; Yes - Create string entry
2652: B8      	        CP      B               ; Terminator B found?
2653: C24726  	        JP      NZ,QTSTLP       ; No - Keep looking
2656: FE22    	CRTSTE: CP      '"'             ; End with '"'?
2658: CC271D  	        CALL    Z,GETCHR        ; Yes - Get next character
265B: E3      	        EX      (SP),HL         ; Starting quote
265C: 23      	        INC     HL              ; First byte of string
265D: EB      	        EX      DE,HL           ; To DE
265E: 79      	        LD      A,C             ; Get length
265F: CD3426  	        CALL    CRTMST          ; Create string entry
2662: 110481  	TSTOPL: LD      DE,TMPSTR       ; Temporary string
2665: 2AF680  	        LD      HL,(TMSTPT)     ; Temporary string pool pointer
2668: 222981  	        LD      (FPREG),HL      ; Save address of string ptr
266B: 3E01    	        LD      A,1
266D: 32F280  	        LD      (TYPE),A        ; Set type to string
2670: CDE62B  	        CALL    DETHL4          ; Move string to pool
2673: CD9A1B  	        CALL    CPDEHL          ; Out of string pool?
2676: 22F680  	        LD      (TMSTPT),HL     ; Save new pointer
2679: E1      	        POP     HL              ; Restore code string address
267A: 7E      	        LD      A,(HL)          ; Get next code byte
267B: C0      	        RET     NZ              ; Return if pool OK
267C: 1E1E    	        LD      E,ST            ; ?ST Error
267E: C3E618  	        JP      ERROR           ; String pool overflow
              	
2681: 23      	PRNUMS: INC     HL              ; Skip leading space
2682: CD4026  	PRS:    CALL    CRTST           ; Create string entry for it
2685: CDC527  	PRS1:   CALL    GSTRCU          ; Current string to pool
2688: CDDA2B  	        CALL    LOADFP          ; Move string block to BCDE
268B: 1C      	        INC     E               ; Length + 1
268C: 1D      	PRSLP:  DEC     E               ; Count characters
268D: C8      	        RET     Z               ; End of string
268E: 0A      	        LD      A,(BC)          ; Get byte to output
268F: CDAB1B  	        CALL    OUTC            ; Output character in A
2692: FE0D    	        CP      CR              ; Return?
2694: CCDE1F  	        CALL    Z,DONULL        ; Yes - Do nulls
2697: 03      	        INC     BC              ; Next byte in string
2698: C38C26  	        JP      PRSLP           ; More characters to output
              	
269B: B7      	TESTR:  OR      A               ; Test if enough room
269C: 0E      	        DB      0EH             ; No garbage collection done
269D: F1      	GRBDON: POP     AF              ; Garbage collection done
269E: F5      	        PUSH    AF              ; Save status
269F: 2A9F80  	        LD      HL,(STRSPC)     ; Bottom of string space in use
26A2: EB      	        EX      DE,HL           ; To DE
26A3: 2A0881  	        LD      HL,(STRBOT)     ; Bottom of string area
26A6: 2F      	        CPL                     ; Negate length (Top down)
26A7: 4F      	        LD      C,A             ; -Length to BC
26A8: 06FF    	        LD      B,-1            ; BC = -ve length of string
26AA: 09      	        ADD     HL,BC           ; Add to bottom of space in use
26AB: 23      	        INC     HL              ; Plus one for 2's complement
26AC: CD9A1B  	        CALL    CPDEHL          ; Below string RAM area?
26AF: DAB926  	        JP      C,TESTOS        ; Tidy up if not done else err
26B2: 220881  	        LD      (STRBOT),HL     ; Save new bottom of area
26B5: 23      	        INC     HL              ; Point to first byte of string
26B6: EB      	        EX      DE,HL           ; Address to DE
26B7: F1      	POPAF:  POP     AF              ; Throw away status push
26B8: C9      	        RET
              	
26B9: F1      	TESTOS: POP     AF              ; Garbage collect been done?
26BA: 1E1A    	        LD      E,OS            ; ?OS Error
26BC: CAE618  	        JP      Z,ERROR         ; Yes - Not enough string apace
26BF: BF      	        CP      A               ; Flag garbage collect done
26C0: F5      	        PUSH    AF              ; Save status
26C1: 019D26  	        LD      BC,GRBDON       ; Garbage collection done
26C4: C5      	        PUSH    BC              ; Save for RETurn
26C5: 2AF480  	GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
26C8: 220881  	GARBLP: LD      (STRBOT),HL     ; Reset string pointer
26CB: 210000  	        LD      HL,0
26CE: E5      	        PUSH    HL              ; Flag no string found
26CF: 2A9F80  	        LD      HL,(STRSPC)     ; Get bottom of string space
26D2: E5      	        PUSH    HL              ; Save bottom of string space
26D3: 21F880  	        LD      HL,TMSTPL       ; Temporary string pool
26D6: EB      	GRBLP:  EX      DE,HL
26D7: 2AF680  	        LD      HL,(TMSTPT)     ; Temporary string pool pointer
26DA: EB      	        EX      DE,HL
26DB: CD9A1B  	        CALL    CPDEHL          ; Temporary string pool done?
26DE: 01D626  	        LD      BC,GRBLP        ; Loop until string pool done
26E1: C22A27  	        JP      NZ,STPOOL       ; No - See if in string area
26E4: 2A1B81  	        LD      HL,(PROGND)     ; Start of simple variables
26E7: EB      	SMPVAR: EX      DE,HL
26E8: 2A1D81  	        LD      HL,(VAREND)     ; End of simple variables
26EB: EB      	        EX      DE,HL
26EC: CD9A1B  	        CALL    CPDEHL          ; All simple strings done?
26EF: CAFD26  	        JP      Z,ARRLP         ; Yes - Do string arrays
26F2: 7E      	        LD      A,(HL)          ; Get type of variable
26F3: 23      	        INC     HL
26F4: 23      	        INC     HL
26F5: B7      	        OR      A               ; "S" flag set if string
26F6: CD2D27  	        CALL    STRADD          ; See if string in string area
26F9: C3E726  	        JP      SMPVAR          ; Loop until simple ones done
              	
26FC: C1      	GNXARY: POP     BC              ; Scrap address of this array
26FD: EB      	ARRLP:  EX      DE,HL
26FE: 2A1F81  	        LD      HL,(ARREND)     ; End of string arrays
2701: EB      	        EX      DE,HL
2702: CD9A1B  	        CALL    CPDEHL          ; All string arrays done?
2705: CA5327  	        JP      Z,SCNEND        ; Yes - Move string if found
2708: CDDA2B  	        CALL    LOADFP          ; Get array name to BCDE
270B: 7B      	        LD      A,E             ; Get type of array     
270C: E5      	        PUSH    HL              ; Save address of num of dim'ns
270D: 09      	        ADD     HL,BC           ; Start of next array
270E: B7      	        OR      A               ; Test type of array
270F: F2FC26  	        JP      P,GNXARY        ; Numeric array - Ignore it
2712: 220A81  	        LD      (CUROPR),HL     ; Save address of next array
2715: E1      	        POP     HL              ; Get address of num of dim'ns
2716: 4E      	        LD      C,(HL)          ; BC = Number of dimensions
2717: 0600    	        LD      B,0
2719: 09      	        ADD     HL,BC           ; Two bytes per dimension size
271A: 09      	        ADD     HL,BC
271B: 23      	        INC     HL              ; Plus one for number of dim'ns
271C: EB      	GRBARY: EX      DE,HL
271D: 2A0A81  	        LD      HL,(CUROPR)     ; Get address of next array
2720: EB      	        EX      DE,HL
2721: CD9A1B  	        CALL    CPDEHL          ; Is this array finished?
2724: CAFD26  	        JP      Z,ARRLP         ; Yes - Get next one
2727: 011C27  	        LD      BC,GRBARY       ; Loop until array all done
272A: C5      	STPOOL: PUSH    BC              ; Save return address
272B: F680    	        OR      80H             ; Flag string type
272D: 7E      	STRADD: LD      A,(HL)          ; Get string length
272E: 23      	        INC     HL
272F: 23      	        INC     HL
2730: 5E      	        LD      E,(HL)          ; Get LSB of string address
2731: 23      	        INC     HL
2732: 56      	        LD      D,(HL)          ; Get MSB of string address
2733: 23      	        INC     HL
2734: F0      	        RET     P               ; Not a string - Return
2735: B7      	        OR      A               ; Set flags on string length
2736: C8      	        RET     Z               ; Null string - Return
2737: 44      	        LD      B,H             ; Save variable pointer
2738: 4D      	        LD      C,L
2739: 2A0881  	        LD      HL,(STRBOT)     ; Bottom of new area
273C: CD9A1B  	        CALL    CPDEHL          ; String been done?
273F: 60      	        LD      H,B             ; Restore variable pointer
2740: 69      	        LD      L,C
2741: D8      	        RET     C               ; String done - Ignore
2742: E1      	        POP     HL              ; Return address
2743: E3      	        EX      (SP),HL         ; Lowest available string area
2744: CD9A1B  	        CALL    CPDEHL          ; String within string area?
2747: E3      	        EX      (SP),HL         ; Lowest available string area
2748: E5      	        PUSH    HL              ; Re-save return address
2749: 60      	        LD      H,B             ; Restore variable pointer
274A: 69      	        LD      L,C
274B: D0      	        RET     NC              ; Outside string area - Ignore
274C: C1      	        POP     BC              ; Get return , Throw 2 away
274D: F1      	        POP     AF              ; 
274E: F1      	        POP     AF              ; 
274F: E5      	        PUSH    HL              ; Save variable pointer
2750: D5      	        PUSH    DE              ; Save address of current
2751: C5      	        PUSH    BC              ; Put back return address
2752: C9      	        RET                     ; Go to it
              	
2753: D1      	SCNEND: POP     DE              ; Addresses of strings
2754: E1      	        POP     HL              ; 
2755: 7D      	        LD      A,L             ; HL = 0 if no more to do
2756: B4      	        OR      H
2757: C8      	        RET     Z               ; No more to do - Return
2758: 2B      	        DEC     HL
2759: 46      	        LD      B,(HL)          ; MSB of address of string
275A: 2B      	        DEC     HL
275B: 4E      	        LD      C,(HL)          ; LSB of address of string
275C: E5      	        PUSH    HL              ; Save variable address
275D: 2B      	        DEC     HL
275E: 2B      	        DEC     HL
275F: 6E      	        LD      L,(HL)          ; HL = Length of string
2760: 2600    	        LD      H,0
2762: 09      	        ADD     HL,BC           ; Address of end of string+1
2763: 50      	        LD      D,B             ; String address to DE
2764: 59      	        LD      E,C
2765: 2B      	        DEC     HL              ; Last byte in string
2766: 44      	        LD      B,H             ; Address to BC
2767: 4D      	        LD      C,L
2768: 2A0881  	        LD      HL,(STRBOT)     ; Current bottom of string area
276B: CDA118  	        CALL    MOVSTR          ; Move string to new address
276E: E1      	        POP     HL              ; Restore variable address
276F: 71      	        LD      (HL),C          ; Save new LSB of address
2770: 23      	        INC     HL
2771: 70      	        LD      (HL),B          ; Save new MSB of address
2772: 69      	        LD      L,C             ; Next string area+1 to HL
2773: 60      	        LD      H,B
2774: 2B      	        DEC     HL              ; Next string area address
2775: C3C826  	        JP      GARBLP          ; Look for more strings
              	
2778: C5      	CONCAT: PUSH    BC              ; Save prec' opr & code string
2779: E5      	        PUSH    HL              ; 
277A: 2A2981  	        LD      HL,(FPREG)      ; Get first string
277D: E3      	        EX      (SP),HL         ; Save first string
277E: CD2222  	        CALL    OPRND           ; Get second string
2781: E3      	        EX      (SP),HL         ; Restore first string
2782: CD9D21  	        CALL    TSTSTR          ; Make sure it's a string
2785: 7E      	        LD      A,(HL)          ; Get length of second string
2786: E5      	        PUSH    HL              ; Save first string
2787: 2A2981  	        LD      HL,(FPREG)      ; Get second string
278A: E5      	        PUSH    HL              ; Save second string
278B: 86      	        ADD     A,(HL)          ; Add length of second string
278C: 1E1C    	        LD      E,LS            ; ?LS Error
278E: DAE618  	        JP      C,ERROR         ; String too long - Error
2791: CD3126  	        CALL    MKTMST          ; Make temporary string
2794: D1      	        POP     DE              ; Get second string to DE
2795: CDC927  	        CALL    GSTRDE          ; Move to string pool if needed
2798: E3      	        EX      (SP),HL         ; Get first string
2799: CDC827  	        CALL    GSTRHL          ; Move to string pool if needed
279C: E5      	        PUSH    HL              ; Save first string
279D: 2A0681  	        LD      HL,(TMPSTR+2)   ; Temporary string address
27A0: EB      	        EX      DE,HL           ; To DE
27A1: CDAF27  	        CALL    SSTSA           ; First string to string area
27A4: CDAF27  	        CALL    SSTSA           ; Second string to string area
27A7: 21B721  	        LD      HL,EVAL2        ; Return to evaluation loop
27AA: E3      	        EX      (SP),HL         ; Save return,get code string
27AB: E5      	        PUSH    HL              ; Save code string address
27AC: C36226  	        JP      TSTOPL          ; To temporary string to pool
              	
27AF: E1      	SSTSA:  POP     HL              ; Return address
27B0: E3      	        EX      (SP),HL         ; Get string block,save return
27B1: 7E      	        LD      A,(HL)          ; Get length of string
27B2: 23      	        INC     HL
27B3: 23      	        INC     HL
27B4: 4E      	        LD      C,(HL)          ; Get LSB of string address
27B5: 23      	        INC     HL
27B6: 46      	        LD      B,(HL)          ; Get MSB of string address
27B7: 6F      	        LD      L,A             ; Length to L
27B8: 2C      	TOSTRA: INC     L               ; INC - DECed after
27B9: 2D      	TSALP:  DEC     L               ; Count bytes moved
27BA: C8      	        RET     Z               ; End of string - Return
27BB: 0A      	        LD      A,(BC)          ; Get source
27BC: 12      	        LD      (DE),A          ; Save destination
27BD: 03      	        INC     BC              ; Next source
27BE: 13      	        INC     DE              ; Next destination
27BF: C3B927  	        JP      TSALP           ; Loop until string moved
              	
27C2: CD9D21  	GETSTR: CALL    TSTSTR          ; Make sure it's a string
27C5: 2A2981  	GSTRCU: LD      HL,(FPREG)      ; Get current string
27C8: EB      	GSTRHL: EX      DE,HL           ; Save DE
27C9: CDE327  	GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
27CC: EB      	        EX      DE,HL           ; Restore DE
27CD: C0      	        RET     NZ              ; No - Return
27CE: D5      	        PUSH    DE              ; Save string
27CF: 50      	        LD      D,B             ; String block address to DE
27D0: 59      	        LD      E,C
27D1: 1B      	        DEC     DE              ; Point to length
27D2: 4E      	        LD      C,(HL)          ; Get string length
27D3: 2A0881  	        LD      HL,(STRBOT)     ; Current bottom of string area
27D6: CD9A1B  	        CALL    CPDEHL          ; Last one in string area?
27D9: C2E127  	        JP      NZ,POPHL        ; No - Return
27DC: 47      	        LD      B,A             ; Clear B (A=0)
27DD: 09      	        ADD     HL,BC           ; Remove string from str' area
27DE: 220881  	        LD      (STRBOT),HL     ; Save new bottom of str' area
27E1: E1      	POPHL:  POP     HL              ; Restore string
27E2: C9      	        RET
              	
27E3: 2AF680  	BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
27E6: 2B      	        DEC     HL              ; Back
27E7: 46      	        LD      B,(HL)          ; Get MSB of address
27E8: 2B      	        DEC     HL              ; Back
27E9: 4E      	        LD      C,(HL)          ; Get LSB of address
27EA: 2B      	        DEC     HL              ; Back
27EB: 2B      	        DEC     HL              ; Back
27EC: CD9A1B  	        CALL    CPDEHL          ; String last in string pool?
27EF: C0      	        RET     NZ              ; Yes - Leave it
27F0: 22F680  	        LD      (TMSTPT),HL     ; Save new string pool top
27F3: C9      	        RET
              	
27F4: 016325  	LEN:    LD      BC,PASSA        ; To return integer A
27F7: C5      	        PUSH    BC              ; Save address
27F8: CDC227  	GETLEN: CALL    GETSTR          ; Get string and its length
27FB: AF      	        XOR     A
27FC: 57      	        LD      D,A             ; Clear D
27FD: 32F280  	        LD      (TYPE),A        ; Set type to numeric
2800: 7E      	        LD      A,(HL)          ; Get length of string
2801: B7      	        OR      A               ; Set status flags
2802: C9      	        RET
              	
2803: 016325  	ASC:    LD      BC,PASSA        ; To return integer A
2806: C5      	        PUSH    BC              ; Save address
2807: CDF827  	GTFLNM: CALL    GETLEN          ; Get length of string
280A: CAF31D  	        JP      Z,FCERR         ; Null string - Error
280D: 23      	        INC     HL
280E: 23      	        INC     HL
280F: 5E      	        LD      E,(HL)          ; Get LSB of address
2810: 23      	        INC     HL
2811: 56      	        LD      D,(HL)          ; Get MSB of address
2812: 1A      	        LD      A,(DE)          ; Get first byte of string
2813: C9      	        RET
              	
2814: 3E01    	CHR:    LD      A,1             ; One character string
2816: CD3126  	        CALL    MKTMST          ; Make a temporary string
2819: CD0D29  	        CALL    MAKINT          ; Make it integer A
281C: 2A0681  	        LD      HL,(TMPSTR+2)   ; Get address of string
281F: 73      	        LD      (HL),E          ; Save character
2820: C1      	TOPOOL: POP     BC              ; Clean up stack
2821: C36226  	        JP      TSTOPL          ; Temporary string to pool
              	
2824: CDBD28  	LEFT:   CALL    LFRGNM          ; Get number and ending ")"
2827: AF      	        XOR     A               ; Start at first byte in string
2828: E3      	RIGHT1: EX      (SP),HL         ; Save code string,Get string
2829: 4F      	        LD      C,A             ; Starting position in string
282A: E5      	MID1:   PUSH    HL              ; Save string block address
282B: 7E      	        LD      A,(HL)          ; Get length of string
282C: B8      	        CP      B               ; Compare with number given
282D: DA3228  	        JP      C,ALLFOL        ; All following bytes required
2830: 78      	        LD      A,B             ; Get new length
2831: 11      	        DB      11H             ; Skip "LD C,0"
2832: 0E00    	ALLFOL: LD      C,0             ; First byte of string
2834: C5      	        PUSH    BC              ; Save position in string
2835: CD9B26  	        CALL    TESTR           ; See if enough string space
2838: C1      	        POP     BC              ; Get position in string
2839: E1      	        POP     HL              ; Restore string block address
283A: E5      	        PUSH    HL              ; And re-save it
283B: 23      	        INC     HL
283C: 23      	        INC     HL
283D: 46      	        LD      B,(HL)          ; Get LSB of address
283E: 23      	        INC     HL
283F: 66      	        LD      H,(HL)          ; Get MSB of address
2840: 68      	        LD      L,B             ; HL = address of string
2841: 0600    	        LD      B,0             ; BC = starting address
2843: 09      	        ADD     HL,BC           ; Point to that byte
2844: 44      	        LD      B,H             ; BC = source string
2845: 4D      	        LD      C,L
2846: CD3426  	        CALL    CRTMST          ; Create a string entry
2849: 6F      	        LD      L,A             ; Length of new string
284A: CDB827  	        CALL    TOSTRA          ; Move string to string area
284D: D1      	        POP     DE              ; Clear stack
284E: CDC927  	        CALL    GSTRDE          ; Move to string pool if needed
2851: C36226  	        JP      TSTOPL          ; Temporary string to pool
              	
2854: CDBD28  	RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
2857: D1      	        POP     DE              ; Get string length
2858: D5      	        PUSH    DE              ; And re-save
2859: 1A      	        LD      A,(DE)          ; Get length
285A: 90      	        SUB     B               ; Move back N bytes
285B: C32828  	        JP      RIGHT1          ; Go and get sub-string
              	
285E: EB      	MID:    EX      DE,HL           ; Get code string address
285F: 7E      	        LD      A,(HL)          ; Get next byte ',' or ")"
2860: CDC228  	        CALL    MIDNUM          ; Get number supplied
2863: 04      	        INC     B               ; Is it character zero?
2864: 05      	        DEC     B
2865: CAF31D  	        JP      Z,FCERR         ; Yes - Error
2868: C5      	        PUSH    BC              ; Save starting position
2869: 1EFF    	        LD      E,255           ; All of string
286B: FE29    	        CP      ')'             ; Any length given?
286D: CA7728  	        JP      Z,RSTSTR        ; No - Rest of string
2870: CDA01B  	        CALL    CHKSYN          ; Make sure ',' follows
2873: 2C      	        DB      ','
2874: CD0A29  	        CALL    GETINT          ; Get integer 0-255
2877: CDA01B  	RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
287A: 29      	        DB      ")"
287B: F1      	        POP     AF              ; Restore starting position
287C: E3      	        EX      (SP),HL         ; Get string,8ave code string
287D: 012A28  	        LD      BC,MID1         ; Continuation of MID$ routine
2880: C5      	        PUSH    BC              ; Save for return
2881: 3D      	        DEC     A               ; Starting position-1
2882: BE      	        CP      (HL)            ; Compare with length
2883: 0600    	        LD      B,0             ; Zero bytes length
2885: D0      	        RET     NC              ; Null string if start past end
2886: 4F      	        LD      C,A             ; Save starting position-1
2887: 7E      	        LD      A,(HL)          ; Get length of string
2888: 91      	        SUB     C               ; Subtract start
2889: BB      	        CP      E               ; Enough string for it?
288A: 47      	        LD      B,A             ; Save maximum length available
288B: D8      	        RET     C               ; Truncate string if needed
288C: 43      	        LD      B,E             ; Set specified length
288D: C9      	        RET                     ; Go and create string
              	
288E: CDF827  	VAL:    CALL    GETLEN          ; Get length of string
2891: CAAB29  	        JP      Z,RESZER        ; Result zero
2894: 5F      	        LD      E,A             ; Save length
2895: 23      	        INC     HL
2896: 23      	        INC     HL
2897: 7E      	        LD      A,(HL)          ; Get LSB of address
2898: 23      	        INC     HL
2899: 66      	        LD      H,(HL)          ; Get MSB of address
289A: 6F      	        LD      L,A             ; HL = String address
289B: E5      	        PUSH    HL              ; Save string address
289C: 19      	        ADD     HL,DE
289D: 46      	        LD      B,(HL)          ; Get end of string+1 byte
289E: 72      	        LD      (HL),D          ; Zero it to terminate
289F: E3      	        EX      (SP),HL         ; Save string end,get start
28A0: C5      	        PUSH    BC              ; Save end+1 byte
28A1: 7E      	        LD      A,(HL)          ; Get starting byte
28A2: FE24    	    CP	'$'		; Hex number indicated? [function added]
28A4: C2AC28  	    JP	NZ,VAL1
28A7: CD0833  	    CALL	HEXTFP		; Convert Hex to FPREG
28AA: 180D    	    JR	VAL3
28AC: FE25    	VAL1:	CP	'%'		; Binary number indicated? [function added]
28AE: C2B628  	    JP	NZ,VAL2
28B1: CD7833  	    CALL	BINTFP		; Convert Bin to FPREG
28B4: 1803    	    JR	VAL3
28B6: CD922C  	VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
28B9: C1      	VAL3:   POP     BC              ; Restore end+1 byte
28BA: E1      	        POP     HL              ; Restore end+1 address
28BB: 70      	        LD      (HL),B          ; Put back original byte
28BC: C9      	        RET
              	
28BD: EB      	LFRGNM: EX      DE,HL           ; Code string address to HL
28BE: CDA01B  	        CALL    CHKSYN          ; Make sure ")" follows
28C1: 29      	        DB      ")"
28C2: C1      	MIDNUM: POP     BC              ; Get return address
28C3: D1      	        POP     DE              ; Get number supplied
28C4: C5      	        PUSH    BC              ; Re-save return address
28C5: 43      	        LD      B,E             ; Number to B
28C6: C9      	        RET
              	
28C7: CD0D29  	INP:    CALL    MAKINT          ; Make it integer A
28CA: 328480  	        LD      (INPORT),A      ; Set input port
28CD: CD8380  	        CALL    INPSUB          ; Get input from port
28D0: C36325  	        JP      PASSA           ; Return integer A
              	
28D3: CDF728  	POUT:   CALL    SETIO           ; Set up port number
28D6: C34B80  	        JP      OUTSUB          ; Output data and return
              	
28D9: CDF728  	WAIT:   CALL    SETIO           ; Set up port number
28DC: F5      	        PUSH    AF              ; Save AND mask
28DD: 1E00    	        LD      E,0             ; Assume zero if none given
28DF: 2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
28E0: CD271D  	        CALL    GETCHR          ; Get next character
28E3: CAED28  	        JP      Z,NOXOR         ; No XOR byte given
28E6: CDA01B  	        CALL    CHKSYN          ; Make sure ',' follows
28E9: 2C      	        DB      ','
28EA: CD0A29  	        CALL    GETINT          ; Get integer 0-255 to XOR with
28ED: C1      	NOXOR:  POP     BC              ; Restore AND mask
28EE: CD8380  	WAITLP: CALL    INPSUB          ; Get input
28F1: AB      	        XOR     E               ; Flip selected bits
28F2: A0      	        AND     B               ; Result non-zero?
28F3: CAEE28  	        JP      Z,WAITLP        ; No = keep waiting
28F6: C9      	        RET
              	
28F7: CD0A29  	SETIO:  CALL    GETINT          ; Get integer 0-255
28FA: 328480  	        LD      (INPORT),A      ; Set input port
28FD: 324C80  	        LD      (OTPORT),A      ; Set output port
2900: CDA01B  	        CALL    CHKSYN          ; Make sure ',' follows
2903: 2C      	        DB      ','
2904: C30A29  	        JP      GETINT          ; Get integer 0-255 and return
              	
2907: CD271D  	FNDNUM: CALL    GETCHR          ; Get next character
290A: CD9921  	GETINT: CALL    GETNUM          ; Get a number from 0 to 255
290D: CDD81D  	MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
2910: 7A      	        LD      A,D             ; Get MSB of number
2911: B7      	        OR      A               ; Zero?
2912: C2F31D  	        JP      NZ,FCERR        ; No - Error
2915: 2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2916: CD271D  	        CALL    GETCHR          ; Get next character
2919: 7B      	        LD      A,E             ; Get number to A
291A: C9      	        RET
              	
291B: CDDE1D  	PEEK:   CALL    DEINT           ; Get memory address
291E: 1A      	        LD      A,(DE)          ; Get byte in memory
291F: C36325  	        JP      PASSA           ; Return integer A
              	
2922: CD9921  	POKE:   CALL    GETNUM          ; Get memory address
2925: CDDE1D  	        CALL    DEINT           ; Get integer -32768 to 3276
2928: D5      	        PUSH    DE              ; Save memory address
2929: CDA01B  	        CALL    CHKSYN          ; Make sure ',' follows
292C: 2C      	        DB      ','
292D: CD0A29  	        CALL    GETINT          ; Get integer 0-255
2930: D1      	        POP     DE              ; Restore memory address
2931: 12      	        LD      (DE),A          ; Load it into memory
2932: C9      	        RET
              	
2933: 21092E  	ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
2936: CDDA2B  	ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
2939: C34529  	        JP      FPADD           ; Add BCDE to FPREG
              	
293C: CDDA2B  	SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
293F: 21      	        DB      21H             ; Skip "POP BC" and "POP DE"
2940: C1      	PSUB:   POP     BC              ; Get FP number from stack
2941: D1      	        POP     DE
2942: CDB42B  	SUBCDE: CALL    INVSGN          ; Negate FPREG
2945: 78      	FPADD:  LD      A,B             ; Get FP exponent
2946: B7      	        OR      A               ; Is number zero?
2947: C8      	        RET     Z               ; Yes - Nothing to add
2948: 3A2C81  	        LD      A,(FPEXP)       ; Get FPREG exponent
294B: B7      	        OR      A               ; Is this number zero?
294C: CACC2B  	        JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
294F: 90      	        SUB     B               ; BCDE number larger?
2950: D25F29  	        JP      NC,NOSWAP       ; No - Don't swap them
2953: 2F      	        CPL                     ; Two's complement
2954: 3C      	        INC     A               ;  FP exponent
2955: EB      	        EX      DE,HL
2956: CDBC2B  	        CALL    STAKFP          ; Put FPREG on stack
2959: EB      	        EX      DE,HL
295A: CDCC2B  	        CALL    FPBCDE          ; Move BCDE to FPREG
295D: C1      	        POP     BC              ; Restore number from stack
295E: D1      	        POP     DE
295F: FE19    	NOSWAP: CP      24+1            ; Second number insignificant?
2961: D0      	        RET     NC              ; Yes - First number is result
2962: F5      	        PUSH    AF              ; Save number of bits to scale
2963: CDF12B  	        CALL    SIGNS           ; Set MSBs & sign of result
2966: 67      	        LD      H,A             ; Save sign of result
2967: F1      	        POP     AF              ; Restore scaling factor
2968: CD0A2A  	        CALL    SCALE           ; Scale BCDE to same exponent
296B: B4      	        OR      H               ; Result to be positive?
296C: 212981  	        LD      HL,FPREG        ; Point to FPREG
296F: F28529  	        JP      P,MINCDE        ; No - Subtract FPREG from CDE
2972: CDEA29  	        CALL    PLUCDE          ; Add FPREG to CDE
2975: D2CB29  	        JP      NC,RONDUP       ; No overflow - Round it up
2978: 23      	        INC     HL              ; Point to exponent
2979: 34      	        INC     (HL)            ; Increment it
297A: CAE118  	        JP      Z,OVERR         ; Number overflowed - Error
297D: 2E01    	        LD      L,1             ; 1 bit to shift right
297F: CD202A  	        CALL    SHRT1           ; Shift result right
2982: C3CB29  	        JP      RONDUP          ; Round it up
              	
2985: AF      	MINCDE: XOR     A               ; Clear A and carry
2986: 90      	        SUB     B               ; Negate exponent
2987: 47      	        LD      B,A             ; Re-save exponent
2988: 7E      	        LD      A,(HL)          ; Get LSB of FPREG
2989: 9B      	        SBC     A, E            ; Subtract LSB of BCDE
298A: 5F      	        LD      E,A             ; Save LSB of BCDE
298B: 23      	        INC     HL
298C: 7E      	        LD      A,(HL)          ; Get NMSB of FPREG
298D: 9A      	        SBC     A,D             ; Subtract NMSB of BCDE
298E: 57      	        LD      D,A             ; Save NMSB of BCDE
298F: 23      	        INC     HL
2990: 7E      	        LD      A,(HL)          ; Get MSB of FPREG
2991: 99      	        SBC     A,C             ; Subtract MSB of BCDE
2992: 4F      	        LD      C,A             ; Save MSB of BCDE
2993: DCF629  	CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
              	
2996: 68      	BNORM:  LD      L,B             ; L = Exponent
2997: 63      	        LD      H,E             ; H = LSB
2998: AF      	        XOR     A
2999: 47      	BNRMLP: LD      B,A             ; Save bit count
299A: 79      	        LD      A,C             ; Get MSB
299B: B7      	        OR      A               ; Is it zero?
299C: C2B829  	        JP      NZ,PNORM        ; No - Do it bit at a time
299F: 4A      	        LD      C,D             ; MSB = NMSB
29A0: 54      	        LD      D,H             ; NMSB= LSB
29A1: 65      	        LD      H,L             ; LSB = VLSB
29A2: 6F      	        LD      L,A             ; VLSB= 0
29A3: 78      	        LD      A,B             ; Get exponent
29A4: D608    	        SUB     8               ; Count 8 bits
29A6: FEE0    	        CP      $E0           ; Was number zero?  CP -24-8 gives wrong F0 should be E0
29A8: C29929  	        JP      NZ,BNRMLP       ; No - Keep normalising
29AB: AF      	RESZER: XOR     A               ; Result is zero
29AC: 322C81  	SAVEXP: LD      (FPEXP),A       ; Save result as zero
29AF: C9      	        RET
              	
29B0: 05      	NORMAL: DEC     B               ; Count bits
29B1: 29      	        ADD     HL,HL           ; Shift HL left
29B2: 7A      	        LD      A,D             ; Get NMSB
29B3: 17      	        RLA                     ; Shift left with last bit
29B4: 57      	        LD      D,A             ; Save NMSB
29B5: 79      	        LD      A,C             ; Get MSB
29B6: 8F      	        ADC     A,A             ; Shift left with last bit
29B7: 4F      	        LD      C,A             ; Save MSB
29B8: F2B029  	PNORM:  JP      P,NORMAL        ; Not done - Keep going
29BB: 78      	        LD      A,B             ; Number of bits shifted
29BC: 5C      	        LD      E,H             ; Save HL in EB
29BD: 45      	        LD      B,L
29BE: B7      	        OR      A               ; Any shifting done?
29BF: CACB29  	        JP      Z,RONDUP        ; No - Round it up
29C2: 212C81  	        LD      HL,FPEXP        ; Point to exponent
29C5: 86      	        ADD     A,(HL)          ; Add shifted bits
29C6: 77      	        LD      (HL),A          ; Re-save exponent
29C7: D2AB29  	        JP      NC,RESZER       ; Underflow - Result is zero
29CA: C8      	        RET     Z               ; Result is zero
29CB: 78      	RONDUP: LD      A,B             ; Get VLSB of number
29CC: 212C81  	RONDB:  LD      HL,FPEXP        ; Point to exponent
29CF: B7      	        OR      A               ; Any rounding?
29D0: FCDD29  	        CALL    M,FPROND        ; Yes - Round number up
29D3: 46      	        LD      B,(HL)          ; B = Exponent
29D4: 23      	        INC     HL
29D5: 7E      	        LD      A,(HL)          ; Get sign of result
29D6: E680    	        AND     10000000B       ; Only bit 7 needed
29D8: A9      	        XOR     C               ; Set correct sign
29D9: 4F      	        LD      C,A             ; Save correct sign in number
29DA: C3CC2B  	        JP      FPBCDE          ; Move BCDE to FPREG
              	
29DD: 1C      	FPROND: INC     E               ; Round LSB
29DE: C0      	        RET     NZ              ; Return if ok
29DF: 14      	        INC     D               ; Round NMSB
29E0: C0      	        RET     NZ              ; Return if ok
29E1: 0C      	        INC     C               ; Round MSB
29E2: C0      	        RET     NZ              ; Return if ok
29E3: 0E80    	        LD      C,80H           ; Set normal value
29E5: 34      	        INC     (HL)            ; Increment exponent
29E6: C0      	        RET     NZ              ; Return if ok
29E7: C3E118  	        JP      OVERR           ; Overflow error
              	
29EA: 7E      	PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
29EB: 83      	        ADD     A,E             ; Add LSB of BCDE
29EC: 5F      	        LD      E,A             ; Save LSB of BCDE
29ED: 23      	        INC     HL
29EE: 7E      	        LD      A,(HL)          ; Get NMSB of FPREG
29EF: 8A      	        ADC     A,D             ; Add NMSB of BCDE
29F0: 57      	        LD      D,A             ; Save NMSB of BCDE
29F1: 23      	        INC     HL
29F2: 7E      	        LD      A,(HL)          ; Get MSB of FPREG
29F3: 89      	        ADC     A,C             ; Add MSB of BCDE
29F4: 4F      	        LD      C,A             ; Save MSB of BCDE
29F5: C9      	        RET
              	
29F6: 212D81  	COMPL:  LD      HL,SGNRES       ; Sign of result
29F9: 7E      	        LD      A,(HL)          ; Get sign of result
29FA: 2F      	        CPL                     ; Negate it
29FB: 77      	        LD      (HL),A          ; Put it back
29FC: AF      	        XOR     A
29FD: 6F      	        LD      L,A             ; Set L to zero
29FE: 90      	        SUB     B               ; Negate exponent,set carry
29FF: 47      	        LD      B,A             ; Re-save exponent
2A00: 7D      	        LD      A,L             ; Load zero
2A01: 9B      	        SBC     A,E             ; Negate LSB
2A02: 5F      	        LD      E,A             ; Re-save LSB
2A03: 7D      	        LD      A,L             ; Load zero
2A04: 9A      	        SBC     A,D             ; Negate NMSB
2A05: 57      	        LD      D,A             ; Re-save NMSB
2A06: 7D      	        LD      A,L             ; Load zero
2A07: 99      	        SBC     A,C             ; Negate MSB
2A08: 4F      	        LD      C,A             ; Re-save MSB
2A09: C9      	        RET
              	
2A0A: 0600    	SCALE:  LD      B,0             ; Clear underflow
2A0C: D608    	SCALLP: SUB     8               ; 8 bits (a whole byte)?
2A0E: DA192A  	        JP      C,SHRITE        ; No - Shift right A bits
2A11: 43      	        LD      B,E             ; <- Shift
2A12: 5A      	        LD      E,D             ; <- right
2A13: 51      	        LD      D,C             ; <- eight
2A14: 0E00    	        LD      C,0             ; <- bits
2A16: C30C2A  	        JP      SCALLP          ; More bits to shift
              	
2A19: C609    	SHRITE: ADD     A,8+1           ; Adjust count
2A1B: 6F      	        LD      L,A             ; Save bits to shift
2A1C: AF      	SHRLP:  XOR     A               ; Flag for all done
2A1D: 2D      	        DEC     L               ; All shifting done?
2A1E: C8      	        RET     Z               ; Yes - Return
2A1F: 79      	        LD      A,C             ; Get MSB
2A20: 1F      	SHRT1:  RRA                     ; Shift it right
2A21: 4F      	        LD      C,A             ; Re-save
2A22: 7A      	        LD      A,D             ; Get NMSB
2A23: 1F      	        RRA                     ; Shift right with last bit
2A24: 57      	        LD      D,A             ; Re-save it
2A25: 7B      	        LD      A,E             ; Get LSB
2A26: 1F      	        RRA                     ; Shift right with last bit
2A27: 5F      	        LD      E,A             ; Re-save it
2A28: 78      	        LD      A,B             ; Get underflow
2A29: 1F      	        RRA                     ; Shift right with last bit
2A2A: 47      	        LD      B,A             ; Re-save underflow
2A2B: C31C2A  	        JP      SHRLP           ; More bits to do
              	
2A2E: 00000081	UNITY:  DB       000H,000H,000H,081H    ; 1.00000
              	
2A32: 03      	LOGTAB: DB      3                       ; Table used by LOG
2A33: AA561980	        DB      0AAH,056H,019H,080H     ; 0.59898
2A37: F1227680	        DB      0F1H,022H,076H,080H     ; 0.96147
2A3B: 45AA3882	        DB      045H,0AAH,038H,082H     ; 2.88539
              	
2A3F: CD8B2B  	LOG:    CALL    TSTSGN          ; Test sign of value
2A42: B7      	        OR      A
2A43: EAF31D  	        JP      PE,FCERR        ; ?FC Error if <= zero
2A46: 212C81  	        LD      HL,FPEXP        ; Point to exponent
2A49: 7E      	        LD      A,(HL)          ; Get exponent
2A4A: 013580  	        LD      BC,8035H        ; BCDE = SQR(1/2)
2A4D: 11F304  	        LD      DE,04F3H
2A50: 90      	        SUB     B               ; Scale value to be < 1
2A51: F5      	        PUSH    AF              ; Save scale factor
2A52: 70      	        LD      (HL),B          ; Save new exponent
2A53: D5      	        PUSH    DE              ; Save SQR(1/2)
2A54: C5      	        PUSH    BC
2A55: CD4529  	        CALL    FPADD           ; Add SQR(1/2) to value
2A58: C1      	        POP     BC              ; Restore SQR(1/2)
2A59: D1      	        POP     DE
2A5A: 04      	        INC     B               ; Make it SQR(2)
2A5B: CDE12A  	        CALL    DVBCDE          ; Divide by SQR(2)
2A5E: 212E2A  	        LD      HL,UNITY        ; Point to 1.
2A61: CD3C29  	        CALL    SUBPHL          ; Subtract FPREG from 1
2A64: 21322A  	        LD      HL,LOGTAB       ; Coefficient table
2A67: CDD32E  	        CALL    SUMSER          ; Evaluate sum of series
2A6A: 018080  	        LD      BC,8080H        ; BCDE = -0.5
2A6D: 110000  	        LD      DE,0000H
2A70: CD4529  	        CALL    FPADD           ; Subtract 0.5 from FPREG
2A73: F1      	        POP     AF              ; Restore scale factor
2A74: CD062D  	        CALL    RSCALE          ; Re-scale number
2A77: 013180  	MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
2A7A: 111872  	        LD      DE,7218H
2A7D: 21      	        DB      21H             ; Skip "POP BC" and "POP DE"
              	
2A7E: C1      	MULT:   POP     BC              ; Get number from stack
2A7F: D1      	        POP     DE
2A80: CD8B2B  	FPMULT: CALL    TSTSGN          ; Test sign of FPREG
2A83: C8      	        RET     Z               ; Return zero if zero
2A84: 2E00    	        LD      L,0             ; Flag add exponents
2A86: CD492B  	        CALL    ADDEXP          ; Add exponents
2A89: 79      	        LD      A,C             ; Get MSB of multiplier
2A8A: 323B81  	        LD      (MULVAL),A      ; Save MSB of multiplier
2A8D: EB      	        EX      DE,HL
2A8E: 223C81  	        LD      (MULVAL+1),HL   ; Save rest of multiplier
2A91: 010000  	        LD      BC,0            ; Partial product (BCDE) = zero
2A94: 50      	        LD      D,B
2A95: 58      	        LD      E,B
2A96: 219629  	        LD      HL,BNORM        ; Address of normalise
2A99: E5      	        PUSH    HL              ; Save for return
2A9A: 21A22A  	        LD      HL,MULT8        ; Address of 8 bit multiply
2A9D: E5      	        PUSH    HL              ; Save for NMSB,MSB
2A9E: E5      	        PUSH    HL              ; 
2A9F: 212981  	        LD      HL,FPREG        ; Point to number
2AA2: 7E      	MULT8:  LD      A,(HL)          ; Get LSB of number
2AA3: 23      	        INC     HL              ; Point to NMSB
2AA4: B7      	        OR      A               ; Test LSB
2AA5: CACE2A  	        JP      Z,BYTSFT        ; Zero - shift to next byte
2AA8: E5      	        PUSH    HL              ; Save address of number
2AA9: 2E08    	        LD      L,8             ; 8 bits to multiply by
2AAB: 1F      	MUL8LP: RRA                     ; Shift LSB right
2AAC: 67      	        LD      H,A             ; Save LSB
2AAD: 79      	        LD      A,C             ; Get MSB
2AAE: D2BC2A  	        JP      NC,NOMADD       ; Bit was zero - Don't add
2AB1: E5      	        PUSH    HL              ; Save LSB and count
2AB2: 2A3C81  	        LD      HL,(MULVAL+1)   ; Get LSB and NMSB
2AB5: 19      	        ADD     HL,DE           ; Add NMSB and LSB
2AB6: EB      	        EX      DE,HL           ; Leave sum in DE
2AB7: E1      	        POP     HL              ; Restore MSB and count
2AB8: 3A3B81  	        LD      A,(MULVAL)      ; Get MSB of multiplier
2ABB: 89      	        ADC     A,C             ; Add MSB
2ABC: 1F      	NOMADD: RRA                     ; Shift MSB right
2ABD: 4F      	        LD      C,A             ; Re-save MSB
2ABE: 7A      	        LD      A,D             ; Get NMSB
2ABF: 1F      	        RRA                     ; Shift NMSB right
2AC0: 57      	        LD      D,A             ; Re-save NMSB
2AC1: 7B      	        LD      A,E             ; Get LSB
2AC2: 1F      	        RRA                     ; Shift LSB right
2AC3: 5F      	        LD      E,A             ; Re-save LSB
2AC4: 78      	        LD      A,B             ; Get VLSB
2AC5: 1F      	        RRA                     ; Shift VLSB right
2AC6: 47      	        LD      B,A             ; Re-save VLSB
2AC7: 2D      	        DEC     L               ; Count bits multiplied
2AC8: 7C      	        LD      A,H             ; Get LSB of multiplier
2AC9: C2AB2A  	        JP      NZ,MUL8LP       ; More - Do it
2ACC: E1      	POPHRT: POP     HL              ; Restore address of number
2ACD: C9      	        RET
              	
2ACE: 43      	BYTSFT: LD      B,E             ; Shift partial product left
2ACF: 5A      	        LD      E,D
2AD0: 51      	        LD      D,C
2AD1: 4F      	        LD      C,A
2AD2: C9      	        RET
              	
2AD3: CDBC2B  	DIV10:  CALL    STAKFP          ; Save FPREG on stack
2AD6: 012084  	        LD      BC,8420H        ; BCDE = 10.
2AD9: 110000  	        LD      DE,0000H
2ADC: CDCC2B  	        CALL    FPBCDE          ; Move 10 to FPREG
              	
2ADF: C1      	DIV:    POP     BC              ; Get number from stack
2AE0: D1      	        POP     DE
2AE1: CD8B2B  	DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
2AE4: CAD518  	        JP      Z,DZERR         ; Error if division by zero
2AE7: 2EFF    	        LD      L,-1            ; Flag subtract exponents
2AE9: CD492B  	        CALL    ADDEXP          ; Subtract exponents
2AEC: 34      	        INC     (HL)            ; Add 2 to exponent to adjust
2AED: 34      	        INC     (HL)
2AEE: 2B      	        DEC     HL              ; Point to MSB
2AEF: 7E      	        LD      A,(HL)          ; Get MSB of dividend
2AF0: 325780  	        LD      (DIV3),A        ; Save for subtraction
2AF3: 2B      	        DEC     HL
2AF4: 7E      	        LD      A,(HL)          ; Get NMSB of dividend
2AF5: 325380  	        LD      (DIV2),A        ; Save for subtraction
2AF8: 2B      	        DEC     HL
2AF9: 7E      	        LD      A,(HL)          ; Get MSB of dividend
2AFA: 324F80  	        LD      (DIV1),A        ; Save for subtraction
2AFD: 41      	        LD      B,C             ; Get MSB
2AFE: EB      	        EX      DE,HL           ; NMSB,LSB to HL
2AFF: AF      	        XOR     A
2B00: 4F      	        LD      C,A             ; Clear MSB of quotient
2B01: 57      	        LD      D,A             ; Clear NMSB of quotient
2B02: 5F      	        LD      E,A             ; Clear LSB of quotient
2B03: 325A80  	        LD      (DIV4),A        ; Clear overflow count
2B06: E5      	DIVLP:  PUSH    HL              ; Save divisor
2B07: C5      	        PUSH    BC
2B08: 7D      	        LD      A,L             ; Get LSB of number
2B09: CD4E80  	        CALL    DIVSUP          ; Subt' divisor from dividend
2B0C: DE00    	        SBC     A,0             ; Count for overflows
2B0E: 3F      	        CCF
2B0F: D2192B  	        JP      NC,RESDIV       ; Restore divisor if borrow
2B12: 325A80  	        LD      (DIV4),A        ; Re-save overflow count
2B15: F1      	        POP     AF              ; Scrap divisor
2B16: F1      	        POP     AF
2B17: 37      	        SCF                     ; Set carry to
2B18: D2      	        DB      0D2H            ; Skip "POP BC" and "POP HL"
              	
2B19: C1      	RESDIV: POP     BC              ; Restore divisor
2B1A: E1      	        POP     HL
2B1B: 79      	        LD      A,C             ; Get MSB of quotient
2B1C: 3C      	        INC     A
2B1D: 3D      	        DEC     A
2B1E: 1F      	        RRA                     ; Bit 0 to bit 7
2B1F: FACC29  	        JP      M,RONDB         ; Done - Normalise result
2B22: 17      	        RLA                     ; Restore carry
2B23: 7B      	        LD      A,E             ; Get LSB of quotient
2B24: 17      	        RLA                     ; Double it
2B25: 5F      	        LD      E,A             ; Put it back
2B26: 7A      	        LD      A,D             ; Get NMSB of quotient
2B27: 17      	        RLA                     ; Double it
2B28: 57      	        LD      D,A             ; Put it back
2B29: 79      	        LD      A,C             ; Get MSB of quotient
2B2A: 17      	        RLA                     ; Double it
2B2B: 4F      	        LD      C,A             ; Put it back
2B2C: 29      	        ADD     HL,HL           ; Double NMSB,LSB of divisor
2B2D: 78      	        LD      A,B             ; Get MSB of divisor
2B2E: 17      	        RLA                     ; Double it
2B2F: 47      	        LD      B,A             ; Put it back
2B30: 3A5A80  	        LD      A,(DIV4)        ; Get VLSB of quotient
2B33: 17      	        RLA                     ; Double it
2B34: 325A80  	        LD      (DIV4),A        ; Put it back
2B37: 79      	        LD      A,C             ; Get MSB of quotient
2B38: B2      	        OR      D               ; Merge NMSB
2B39: B3      	        OR      E               ; Merge LSB
2B3A: C2062B  	        JP      NZ,DIVLP        ; Not done - Keep dividing
2B3D: E5      	        PUSH    HL              ; Save divisor
2B3E: 212C81  	        LD      HL,FPEXP        ; Point to exponent
2B41: 35      	        DEC     (HL)            ; Divide by 2
2B42: E1      	        POP     HL              ; Restore divisor
2B43: C2062B  	        JP      NZ,DIVLP        ; Ok - Keep going
2B46: C3E118  	        JP      OVERR           ; Overflow error
              	
2B49: 78      	ADDEXP: LD      A,B             ; Get exponent of dividend
2B4A: B7      	        OR      A               ; Test it
2B4B: CA6D2B  	        JP      Z,OVTST3        ; Zero - Result zero
2B4E: 7D      	        LD      A,L             ; Get add/subtract flag
2B4F: 212C81  	        LD      HL,FPEXP        ; Point to exponent
2B52: AE      	        XOR     (HL)            ; Add or subtract it
2B53: 80      	        ADD     A,B             ; Add the other exponent
2B54: 47      	        LD      B,A             ; Save new exponent
2B55: 1F      	        RRA                     ; Test exponent for overflow
2B56: A8      	        XOR     B
2B57: 78      	        LD      A,B             ; Get exponent
2B58: F26C2B  	        JP      P,OVTST2        ; Positive - Test for overflow
2B5B: C680    	        ADD     A,80H           ; Add excess 128
2B5D: 77      	        LD      (HL),A          ; Save new exponent
2B5E: CACC2A  	        JP      Z,POPHRT        ; Zero - Result zero
2B61: CDF12B  	        CALL    SIGNS           ; Set MSBs and sign of result
2B64: 77      	        LD      (HL),A          ; Save new exponent
2B65: 2B      	        DEC     HL              ; Point to MSB
2B66: C9      	        RET
              	
2B67: CD8B2B  	OVTST1: CALL    TSTSGN          ; Test sign of FPREG
2B6A: 2F      	        CPL                     ; Invert sign
2B6B: E1      	        POP     HL              ; Clean up stack
2B6C: B7      	OVTST2: OR      A               ; Test if new exponent zero
2B6D: E1      	OVTST3: POP     HL              ; Clear off return address
2B6E: F2AB29  	        JP      P,RESZER        ; Result zero
2B71: C3E118  	        JP      OVERR           ; Overflow error
              	
2B74: CDD72B  	MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
2B77: 78      	        LD      A,B             ; Get exponent
2B78: B7      	        OR      A               ; Is it zero?
2B79: C8      	        RET     Z               ; Yes - Result is zero
2B7A: C602    	        ADD     A,2             ; Multiply by 4
2B7C: DAE118  	        JP      C,OVERR         ; Overflow - ?OV Error
2B7F: 47      	        LD      B,A             ; Re-save exponent
2B80: CD4529  	        CALL    FPADD           ; Add BCDE to FPREG (Times 5)
2B83: 212C81  	        LD      HL,FPEXP        ; Point to exponent
2B86: 34      	        INC     (HL)            ; Double number (Times 10)
2B87: C0      	        RET     NZ              ; Ok - Return
2B88: C3E118  	        JP      OVERR           ; Overflow error
              	
2B8B: 3A2C81  	TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
2B8E: B7      	        OR      A
2B8F: C8      	        RET     Z               ; RETurn if number is zero
2B90: 3A2B81  	        LD      A,(FPREG+2)     ; Get MSB of FPREG
2B93: FE      	        DB      0FEH            ; Test sign
2B94: 2F      	RETREL: CPL                     ; Invert sign
2B95: 17      	        RLA                     ; Sign bit to carry
2B96: 9F      	FLGDIF: SBC     A,A             ; Carry to all bits of A
2B97: C0      	        RET     NZ              ; Return -1 if negative
2B98: 3C      	        INC     A               ; Bump to +1
2B99: C9      	        RET                     ; Positive - Return +1
              	
2B9A: CD8B2B  	SGN:    CALL    TSTSGN          ; Test sign of FPREG
2B9D: 0688    	FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
2B9F: 110000  	        LD      DE,0            ; Zero NMSB and LSB
2BA2: 212C81  	RETINT: LD      HL,FPEXP        ; Point to exponent
2BA5: 4F      	        LD      C,A             ; CDE = MSB,NMSB and LSB
2BA6: 70      	        LD      (HL),B          ; Save exponent
2BA7: 0600    	        LD      B,0             ; CDE = integer to normalise
2BA9: 23      	        INC     HL              ; Point to sign of result
2BAA: 3680    	        LD      (HL),80H        ; Set sign of result
2BAC: 17      	        RLA                     ; Carry = sign of integer
2BAD: C39329  	        JP      CONPOS          ; Set sign of result
              	
2BB0: CD8B2B  	ABS:    CALL    TSTSGN          ; Test sign of FPREG
2BB3: F0      	        RET     P               ; Return if positive
2BB4: 212B81  	INVSGN: LD      HL,FPREG+2      ; Point to MSB
2BB7: 7E      	        LD      A,(HL)          ; Get sign of mantissa
2BB8: EE80    	        XOR     80H             ; Invert sign of mantissa
2BBA: 77      	        LD      (HL),A          ; Re-save sign of mantissa
2BBB: C9      	        RET
              	
2BBC: EB      	STAKFP: EX      DE,HL           ; Save code string address
2BBD: 2A2981  	        LD      HL,(FPREG)      ; LSB,NLSB of FPREG
2BC0: E3      	        EX      (SP),HL         ; Stack them,get return
2BC1: E5      	        PUSH    HL              ; Re-save return
2BC2: 2A2B81  	        LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
2BC5: E3      	        EX      (SP),HL         ; Stack them,get return
2BC6: E5      	        PUSH    HL              ; Re-save return
2BC7: EB      	        EX      DE,HL           ; Restore code string address
2BC8: C9      	        RET
              	
2BC9: CDDA2B  	PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
2BCC: EB      	FPBCDE: EX      DE,HL           ; Save code string address
2BCD: 222981  	        LD      (FPREG),HL      ; Save LSB,NLSB of number
2BD0: 60      	        LD      H,B             ; Exponent of number
2BD1: 69      	        LD      L,C             ; MSB of number
2BD2: 222B81  	        LD      (FPREG+2),HL    ; Save MSB and exponent
2BD5: EB      	        EX      DE,HL           ; Restore code string address
2BD6: C9      	        RET
              	
2BD7: 212981  	BCDEFP: LD      HL,FPREG        ; Point to FPREG
2BDA: 5E      	LOADFP: LD      E,(HL)          ; Get LSB of number
2BDB: 23      	        INC     HL
2BDC: 56      	        LD      D,(HL)          ; Get NMSB of number
2BDD: 23      	        INC     HL
2BDE: 4E      	        LD      C,(HL)          ; Get MSB of number
2BDF: 23      	        INC     HL
2BE0: 46      	        LD      B,(HL)          ; Get exponent of number
2BE1: 23      	INCHL:  INC     HL              ; Used for conditional "INC HL"
2BE2: C9      	        RET
              	
2BE3: 112981  	FPTHL:  LD      DE,FPREG        ; Point to FPREG
2BE6: 0604    	DETHL4: LD      B,4             ; 4 bytes to move
2BE8: 1A      	DETHLB: LD      A,(DE)          ; Get source
2BE9: 77      	        LD      (HL),A          ; Save destination
2BEA: 13      	        INC     DE              ; Next source
2BEB: 23      	        INC     HL              ; Next destination
2BEC: 05      	        DEC     B               ; Count bytes
2BED: C2E82B  	        JP      NZ,DETHLB       ; Loop if more
2BF0: C9      	        RET
              	
2BF1: 212B81  	SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
2BF4: 7E      	        LD      A,(HL)          ; Get MSB
2BF5: 07      	        RLCA                    ; Old sign to carry
2BF6: 37      	        SCF                     ; Set MSBit
2BF7: 1F      	        RRA                     ; Set MSBit of MSB
2BF8: 77      	        LD      (HL),A          ; Save new MSB
2BF9: 3F      	        CCF                     ; Complement sign
2BFA: 1F      	        RRA                     ; Old sign to carry
2BFB: 23      	        INC     HL
2BFC: 23      	        INC     HL
2BFD: 77      	        LD      (HL),A          ; Set sign of result
2BFE: 79      	        LD      A,C             ; Get MSB
2BFF: 07      	        RLCA                    ; Old sign to carry
2C00: 37      	        SCF                     ; Set MSBit
2C01: 1F      	        RRA                     ; Set MSBit of MSB
2C02: 4F      	        LD      C,A             ; Save MSB
2C03: 1F      	        RRA
2C04: AE      	        XOR     (HL)            ; New sign of result
2C05: C9      	        RET
              	
2C06: 78      	CMPNUM: LD      A,B             ; Get exponent of number
2C07: B7      	        OR      A
2C08: CA8B2B  	        JP      Z,TSTSGN        ; Zero - Test sign of FPREG
2C0B: 21942B  	        LD      HL,RETREL       ; Return relation routine
2C0E: E5      	        PUSH    HL              ; Save for return
2C0F: CD8B2B  	        CALL    TSTSGN          ; Test sign of FPREG
2C12: 79      	        LD      A,C             ; Get MSB of number
2C13: C8      	        RET     Z               ; FPREG zero - Number's MSB
2C14: 212B81  	        LD      HL,FPREG+2      ; MSB of FPREG
2C17: AE      	        XOR     (HL)            ; Combine signs
2C18: 79      	        LD      A,C             ; Get MSB of number
2C19: F8      	        RET     M               ; Exit if signs different
2C1A: CD202C  	        CALL    CMPFP           ; Compare FP numbers
2C1D: 1F      	        RRA                     ; Get carry to sign
2C1E: A9      	        XOR     C               ; Combine with MSB of number
2C1F: C9      	        RET
              	
2C20: 23      	CMPFP:  INC     HL              ; Point to exponent
2C21: 78      	        LD      A,B             ; Get exponent
2C22: BE      	        CP      (HL)            ; Compare exponents
2C23: C0      	        RET     NZ              ; Different
2C24: 2B      	        DEC     HL              ; Point to MBS
2C25: 79      	        LD      A,C             ; Get MSB
2C26: BE      	        CP      (HL)            ; Compare MSBs
2C27: C0      	        RET     NZ              ; Different
2C28: 2B      	        DEC     HL              ; Point to NMSB
2C29: 7A      	        LD      A,D             ; Get NMSB
2C2A: BE      	        CP      (HL)            ; Compare NMSBs
2C2B: C0      	        RET     NZ              ; Different
2C2C: 2B      	        DEC     HL              ; Point to LSB
2C2D: 7B      	        LD      A,E             ; Get LSB
2C2E: 96      	        SUB     (HL)            ; Compare LSBs
2C2F: C0      	        RET     NZ              ; Different
2C30: E1      	        POP     HL              ; Drop RETurn
2C31: E1      	        POP     HL              ; Drop another RETurn
2C32: C9      	        RET
              	
2C33: 47      	FPINT:  LD      B,A             ; <- Move
2C34: 4F      	        LD      C,A             ; <- exponent
2C35: 57      	        LD      D,A             ; <- to all
2C36: 5F      	        LD      E,A             ; <- bits
2C37: B7      	        OR      A               ; Test exponent
2C38: C8      	        RET     Z               ; Zero - Return zero
2C39: E5      	        PUSH    HL              ; Save pointer to number
2C3A: CDD72B  	        CALL    BCDEFP          ; Move FPREG to BCDE
2C3D: CDF12B  	        CALL    SIGNS           ; Set MSBs & sign of result
2C40: AE      	        XOR     (HL)            ; Combine with sign of FPREG
2C41: 67      	        LD      H,A             ; Save combined signs
2C42: FC572C  	        CALL    M,DCBCDE        ; Negative - Decrement BCDE
2C45: 3E98    	        LD      A,80H+24        ; 24 bits
2C47: 90      	        SUB     B               ; Bits to shift
2C48: CD0A2A  	        CALL    SCALE           ; Shift BCDE
2C4B: 7C      	        LD      A,H             ; Get combined sign
2C4C: 17      	        RLA                     ; Sign to carry
2C4D: DCDD29  	        CALL    C,FPROND        ; Negative - Round number up
2C50: 0600    	        LD      B,0             ; Zero exponent
2C52: DCF629  	        CALL    C,COMPL         ; If negative make positive
2C55: E1      	        POP     HL              ; Restore pointer to number
2C56: C9      	        RET
              	
2C57: 1B      	DCBCDE: DEC     DE              ; Decrement BCDE
2C58: 7A      	        LD      A,D             ; Test LSBs
2C59: A3      	        AND     E
2C5A: 3C      	        INC     A
2C5B: C0      	        RET     NZ              ; Exit if LSBs not FFFF
2C5C: 0B      	        DEC     BC              ; Decrement MSBs
2C5D: C9      	        RET
              	
2C5E: 212C81  	INT:    LD      HL,FPEXP        ; Point to exponent
2C61: 7E      	        LD      A,(HL)          ; Get exponent
2C62: FE98    	        CP      80H+24          ; Integer accuracy only?
2C64: 3A2981  	        LD      A,(FPREG)       ; Get LSB
2C67: D0      	        RET     NC              ; Yes - Already integer
2C68: 7E      	        LD      A,(HL)          ; Get exponent
2C69: CD332C  	        CALL    FPINT           ; F.P to integer
2C6C: 3698    	        LD      (HL),80H+24     ; Save 24 bit integer
2C6E: 7B      	        LD      A,E             ; Get LSB of number
2C6F: F5      	        PUSH    AF              ; Save LSB
2C70: 79      	        LD      A,C             ; Get MSB of number
2C71: 17      	        RLA                     ; Sign to carry
2C72: CD9329  	        CALL    CONPOS          ; Set sign of result
2C75: F1      	        POP     AF              ; Restore LSB of number
2C76: C9      	        RET
              	
2C77: 210000  	MLDEBC: LD      HL,0            ; Clear partial product
2C7A: 78      	        LD      A,B             ; Test multiplier
2C7B: B1      	        OR      C
2C7C: C8      	        RET     Z               ; Return zero if zero
2C7D: 3E10    	        LD      A,16            ; 16 bits
2C7F: 29      	MLDBLP: ADD     HL,HL           ; Shift P.P left
2C80: DAA724  	        JP      C,BSERR         ; ?BS Error if overflow
2C83: EB      	        EX      DE,HL
2C84: 29      	        ADD     HL,HL           ; Shift multiplier left
2C85: EB      	        EX      DE,HL
2C86: D28D2C  	        JP      NC,NOMLAD       ; Bit was zero - No add
2C89: 09      	        ADD     HL,BC           ; Add multiplicand
2C8A: DAA724  	        JP      C,BSERR         ; ?BS Error if overflow
2C8D: 3D      	NOMLAD: DEC     A               ; Count bits
2C8E: C27F2C  	        JP      NZ,MLDBLP       ; More
2C91: C9      	        RET
              	
2C92: FE2D    	ASCTFP: CP      '-'             ; Negative?
2C94: F5      	        PUSH    AF              ; Save it and flags
2C95: CA9E2C  	        JP      Z,CNVNUM        ; Yes - Convert number
2C98: FE2B    	        CP      '+'             ; Positive?
2C9A: CA9E2C  	        JP      Z,CNVNUM        ; Yes - Convert number
2C9D: 2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2C9E: CDAB29  	CNVNUM: CALL    RESZER          ; Set result to zero
2CA1: 47      	        LD      B,A             ; Digits after point counter
2CA2: 57      	        LD      D,A             ; Sign of exponent
2CA3: 5F      	        LD      E,A             ; Exponent of ten
2CA4: 2F      	        CPL
2CA5: 4F      	        LD      C,A             ; Before or after point flag
2CA6: CD271D  	MANLP:  CALL    GETCHR          ; Get next character
2CA9: DAEF2C  	        JP      C,ADDIG         ; Digit - Add to number
2CAC: FE2E    	        CP      '.'
2CAE: CACA2C  	        JP      Z,DPOINT        ; '.' - Flag point
2CB1: FE45    	        CP      'E'
2CB3: C2CE2C  	        JP      NZ,CONEXP       ; Not 'E' - Scale number
2CB6: CD271D  	        CALL    GETCHR          ; Get next character
2CB9: CDD222  	        CALL    SGNEXP          ; Get sign of exponent
2CBC: CD271D  	EXPLP:  CALL    GETCHR          ; Get next character
2CBF: DA112D  	        JP      C,EDIGIT        ; Digit - Add to exponent
2CC2: 14      	        INC     D               ; Is sign negative?
2CC3: C2CE2C  	        JP      NZ,CONEXP       ; No - Scale number
2CC6: AF      	        XOR     A
2CC7: 93      	        SUB     E               ; Negate exponent
2CC8: 5F      	        LD      E,A             ; And re-save it
2CC9: 0C      	        INC     C               ; Flag end of number
2CCA: 0C      	DPOINT: INC     C               ; Flag point passed
2CCB: CAA62C  	        JP      Z,MANLP         ; Zero - Get another digit
2CCE: E5      	CONEXP: PUSH    HL              ; Save code string address
2CCF: 7B      	        LD      A,E             ; Get exponent
2CD0: 90      	        SUB     B               ; Subtract digits after point
2CD1: F4E72C  	SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
2CD4: F2DD2C  	        JP      P,ENDCON        ; Positive - All done
2CD7: F5      	        PUSH    AF              ; Save number of times to /10
2CD8: CDD32A  	        CALL    DIV10           ; Divide by 10
2CDB: F1      	        POP     AF              ; Restore count
2CDC: 3C      	        INC     A               ; Count divides
              	
2CDD: C2D12C  	ENDCON: JP      NZ,SCALMI       ; More to do
2CE0: D1      	        POP     DE              ; Restore code string address
2CE1: F1      	        POP     AF              ; Restore sign of number
2CE2: CCB42B  	        CALL    Z,INVSGN        ; Negative - Negate number
2CE5: EB      	        EX      DE,HL           ; Code string address to HL
2CE6: C9      	        RET
              	
2CE7: C8      	SCALPL: RET     Z               ; Exit if no scaling needed
2CE8: F5      	MULTEN: PUSH    AF              ; Save count
2CE9: CD742B  	        CALL    MLSP10          ; Multiply number by 10
2CEC: F1      	        POP     AF              ; Restore count
2CED: 3D      	        DEC     A               ; Count multiplies
2CEE: C9      	        RET
              	
2CEF: D5      	ADDIG:  PUSH    DE              ; Save sign of exponent
2CF0: 57      	        LD      D,A             ; Save digit
2CF1: 78      	        LD      A,B             ; Get digits after point
2CF2: 89      	        ADC     A,C             ; Add one if after point
2CF3: 47      	        LD      B,A             ; Re-save counter
2CF4: C5      	        PUSH    BC              ; Save point flags
2CF5: E5      	        PUSH    HL              ; Save code string address
2CF6: D5      	        PUSH    DE              ; Save digit
2CF7: CD742B  	        CALL    MLSP10          ; Multiply number by 10
2CFA: F1      	        POP     AF              ; Restore digit
2CFB: D630    	        SUB     '0'             ; Make it absolute
2CFD: CD062D  	        CALL    RSCALE          ; Re-scale number
2D00: E1      	        POP     HL              ; Restore code string address
2D01: C1      	        POP     BC              ; Restore point flags
2D02: D1      	        POP     DE              ; Restore sign of exponent
2D03: C3A62C  	        JP      MANLP           ; Get another digit
              	
2D06: CDBC2B  	RSCALE: CALL    STAKFP          ; Put number on stack
2D09: CD9D2B  	        CALL    FLGREL          ; Digit to add to FPREG
2D0C: C1      	PADD:   POP     BC              ; Restore number
2D0D: D1      	        POP     DE
2D0E: C34529  	        JP      FPADD           ; Add BCDE to FPREG and return
              	
2D11: 7B      	EDIGIT: LD      A,E             ; Get digit
2D12: 07      	        RLCA                    ; Times 2
2D13: 07      	        RLCA                    ; Times 4
2D14: 83      	        ADD     A,E             ; Times 5
2D15: 07      	        RLCA                    ; Times 10
2D16: 86      	        ADD     A,(HL)          ; Add next digit
2D17: D630    	        SUB     '0'             ; Make it absolute
2D19: 5F      	        LD      E,A             ; Save new digit
2D1A: C3BC2C  	        JP      EXPLP           ; Look for another digit
              	
2D1D: E5      	LINEIN: PUSH    HL              ; Save code string address
2D1E: 216A18  	        LD      HL,INMSG        ; Output " in "
2D21: CD8226  	        CALL    PRS             ; Output string at HL
2D24: E1      	        POP     HL              ; Restore code string address
2D25: EB      	PRNTHL: EX      DE,HL           ; Code string address to DE
2D26: AF      	        XOR     A
2D27: 0698    	        LD      B,80H+24        ; 24 bits
2D29: CDA22B  	        CALL    RETINT          ; Return the integer
2D2C: 218126  	        LD      HL,PRNUMS       ; Print number string
2D2F: E5      	        PUSH    HL              ; Save for return
2D30: 212E81  	NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
2D33: E5      	        PUSH    HL              ; Save for return
2D34: CD8B2B  	        CALL    TSTSGN          ; Test sign of FPREG
2D37: 3620    	        LD      (HL),' '        ; Space at start
2D39: F23E2D  	        JP      P,SPCFST        ; Positive - Space to start
2D3C: 362D    	        LD      (HL),'-'        ; '-' sign at start
2D3E: 23      	SPCFST: INC     HL              ; First byte of number
2D3F: 3630    	        LD      (HL),'0'        ; '0' if zero
2D41: CAF42D  	        JP      Z,JSTZER        ; Return '0' if zero
2D44: E5      	        PUSH    HL              ; Save buffer address
2D45: FCB42B  	        CALL    M,INVSGN        ; Negate FPREG if negative
2D48: AF      	        XOR     A               ; Zero A
2D49: F5      	        PUSH    AF              ; Save it
2D4A: CDFA2D  	        CALL    RNGTST          ; Test number is in range
2D4D: 014391  	SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
2D50: 11F84F  	        LD      DE,4FF8H
2D53: CD062C  	        CALL    CMPNUM          ; Compare numbers
2D56: B7      	        OR      A
2D57: E26B2D  	        JP      PO,INRNG        ; > 99999.9 - Sort it out
2D5A: F1      	        POP     AF              ; Restore count
2D5B: CDE82C  	        CALL    MULTEN          ; Multiply by ten
2D5E: F5      	        PUSH    AF              ; Re-save count
2D5F: C34D2D  	        JP      SIXDIG          ; Test it again
              	
2D62: CDD32A  	GTSIXD: CALL    DIV10           ; Divide by 10
2D65: F1      	        POP     AF              ; Get count
2D66: 3C      	        INC     A               ; Count divides
2D67: F5      	        PUSH    AF              ; Re-save count
2D68: CDFA2D  	        CALL    RNGTST          ; Test number is in range
2D6B: CD3329  	INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
2D6E: 3C      	        INC     A
2D6F: CD332C  	        CALL    FPINT           ; F.P to integer
2D72: CDCC2B  	        CALL    FPBCDE          ; Move BCDE to FPREG
2D75: 010603  	        LD      BC,0306H        ; 1E+06 to 1E-03 range
2D78: F1      	        POP     AF              ; Restore count
2D79: 81      	        ADD     A,C             ; 6 digits before point
2D7A: 3C      	        INC     A               ; Add one
2D7B: FA872D  	        JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
2D7E: FE08    	        CP      6+1+1           ; More than 999999 ?
2D80: D2872D  	        JP      NC,MAKNUM       ; Yes - Do it in 'E' form
2D83: 3C      	        INC     A               ; Adjust for exponent
2D84: 47      	        LD      B,A             ; Exponent of number
2D85: 3E02    	        LD      A,2             ; Make it zero after
              	
2D87: 3D      	MAKNUM: DEC     A               ; Adjust for digits to do
2D88: 3D      	        DEC     A
2D89: E1      	        POP     HL              ; Restore buffer address
2D8A: F5      	        PUSH    AF              ; Save count
2D8B: 110D2E  	        LD      DE,POWERS       ; Powers of ten
2D8E: 05      	        DEC     B               ; Count digits before point
2D8F: C2982D  	        JP      NZ,DIGTXT       ; Not zero - Do number
2D92: 362E    	        LD      (HL),'.'        ; Save point
2D94: 23      	        INC     HL              ; Move on
2D95: 3630    	        LD      (HL),'0'        ; Save zero
2D97: 23      	        INC     HL              ; Move on
2D98: 05      	DIGTXT: DEC     B               ; Count digits before point
2D99: 362E    	        LD      (HL),'.'        ; Save point in case
2D9B: CCE12B  	        CALL    Z,INCHL         ; Last digit - move on
2D9E: C5      	        PUSH    BC              ; Save digits before point
2D9F: E5      	        PUSH    HL              ; Save buffer address
2DA0: D5      	        PUSH    DE              ; Save powers of ten
2DA1: CDD72B  	        CALL    BCDEFP          ; Move FPREG to BCDE
2DA4: E1      	        POP     HL              ; Powers of ten table
2DA5: 062F    	        LD      B, '0'-1        ; ASCII '0' - 1
2DA7: 04      	TRYAGN: INC     B               ; Count subtractions
2DA8: 7B      	        LD      A,E             ; Get LSB
2DA9: 96      	        SUB     (HL)            ; Subtract LSB
2DAA: 5F      	        LD      E,A             ; Save LSB
2DAB: 23      	        INC     HL
2DAC: 7A      	        LD      A,D             ; Get NMSB
2DAD: 9E      	        SBC     A,(HL)          ; Subtract NMSB
2DAE: 57      	        LD      D,A             ; Save NMSB
2DAF: 23      	        INC     HL
2DB0: 79      	        LD      A,C             ; Get MSB
2DB1: 9E      	        SBC     A,(HL)          ; Subtract MSB
2DB2: 4F      	        LD      C,A             ; Save MSB
2DB3: 2B      	        DEC     HL              ; Point back to start
2DB4: 2B      	        DEC     HL
2DB5: D2A72D  	        JP      NC,TRYAGN       ; No overflow - Try again
2DB8: CDEA29  	        CALL    PLUCDE          ; Restore number
2DBB: 23      	        INC     HL              ; Start of next number
2DBC: CDCC2B  	        CALL    FPBCDE          ; Move BCDE to FPREG
2DBF: EB      	        EX      DE,HL           ; Save point in table
2DC0: E1      	        POP     HL              ; Restore buffer address
2DC1: 70      	        LD      (HL),B          ; Save digit in buffer
2DC2: 23      	        INC     HL              ; And move on
2DC3: C1      	        POP     BC              ; Restore digit count
2DC4: 0D      	        DEC     C               ; Count digits
2DC5: C2982D  	        JP      NZ,DIGTXT       ; More - Do them
2DC8: 05      	        DEC     B               ; Any decimal part?
2DC9: CAD82D  	        JP      Z,DOEBIT        ; No - Do 'E' bit
2DCC: 2B      	SUPTLZ: DEC     HL              ; Move back through buffer
2DCD: 7E      	        LD      A,(HL)          ; Get character
2DCE: FE30    	        CP      '0'             ; '0' character?
2DD0: CACC2D  	        JP      Z,SUPTLZ        ; Yes - Look back for more
2DD3: FE2E    	        CP      '.'             ; A decimal point?
2DD5: C4E12B  	        CALL    NZ,INCHL        ; Move back over digit
              	
2DD8: F1      	DOEBIT: POP     AF              ; Get 'E' flag
2DD9: CAF72D  	        JP      Z,NOENED        ; No 'E' needed - End buffer
2DDC: 3645    	        LD      (HL),'E'        ; Put 'E' in buffer
2DDE: 23      	        INC     HL              ; And move on
2DDF: 362B    	        LD      (HL),'+'        ; Put '+' in buffer
2DE1: F2E82D  	        JP      P,OUTEXP        ; Positive - Output exponent
2DE4: 362D    	        LD      (HL),'-'        ; Put '-' in buffer
2DE6: 2F      	        CPL                     ; Negate exponent
2DE7: 3C      	        INC     A
2DE8: 062F    	OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
2DEA: 04      	EXPTEN: INC     B               ; Count subtractions
2DEB: D60A    	        SUB     10              ; Tens digit
2DED: D2EA2D  	        JP      NC,EXPTEN       ; More to do
2DF0: C63A    	        ADD     A,'0'+10        ; Restore and make ASCII
2DF2: 23      	        INC     HL              ; Move on
2DF3: 70      	        LD      (HL),B          ; Save MSB of exponent
2DF4: 23      	JSTZER: INC     HL              ;
2DF5: 77      	        LD      (HL),A          ; Save LSB of exponent
2DF6: 23      	        INC     HL
2DF7: 71      	NOENED: LD      (HL),C          ; Mark end of buffer
2DF8: E1      	        POP     HL              ; Restore code string address
2DF9: C9      	        RET
              	
2DFA: 017494  	RNGTST: LD      BC,9474H        ; BCDE = 999999.
2DFD: 11F723  	        LD      DE,23F7H
2E00: CD062C  	        CALL    CMPNUM          ; Compare numbers
2E03: B7      	        OR      A
2E04: E1      	        POP     HL              ; Return address to HL
2E05: E2622D  	        JP      PO,GTSIXD       ; Too big - Divide by ten
2E08: E9      	        JP      (HL)            ; Otherwise return to caller
              	
2E09: 00000080	HALF:   DB      00H,00H,00H,80H ; 0.5
              	
2E0D: A08601  	POWERS: DB      0A0H,086H,001H  ; 100000
2E10: 102700  	        DB      010H,027H,000H  ;  10000
2E13: E80300  	        DB      0E8H,003H,000H  ;   1000
2E16: 640000  	        DB      064H,000H,000H  ;    100
2E19: 0A0000  	        DB      00AH,000H,000H  ;     10
2E1C: 010000  	        DB      001H,000H,000H  ;      1
              	
2E1F: 21B42B  	NEGAFT: LD  HL,INVSGN           ; Negate result
2E22: E3      	        EX      (SP),HL         ; To be done after caller
2E23: E9      	        JP      (HL)            ; Return to caller
              	
2E24: CDBC2B  	SQR:    CALL    STAKFP          ; Put value on stack
2E27: 21092E  	        LD      HL,HALF         ; Set power to 1/2
2E2A: CDC92B  	        CALL    PHLTFP          ; Move 1/2 to FPREG
              	
2E2D: C1      	POWER:  POP     BC              ; Get base
2E2E: D1      	        POP     DE
2E2F: CD8B2B  	        CALL    TSTSGN          ; Test sign of power
2E32: 78      	        LD      A,B             ; Get exponent of base
2E33: CA722E  	        JP      Z,EXP           ; Make result 1 if zero
2E36: F23D2E  	        JP      P,POWER1        ; Positive base - Ok
2E39: B7      	        OR      A               ; Zero to negative power?
2E3A: CAD518  	        JP      Z,DZERR         ; Yes - ?/0 Error
2E3D: B7      	POWER1: OR      A               ; Base zero?
2E3E: CAAC29  	        JP      Z,SAVEXP        ; Yes - Return zero
2E41: D5      	        PUSH    DE              ; Save base
2E42: C5      	        PUSH    BC
2E43: 79      	        LD      A,C             ; Get MSB of base
2E44: F67F    	        OR      01111111B       ; Get sign status
2E46: CDD72B  	        CALL    BCDEFP          ; Move power to BCDE
2E49: F25A2E  	        JP      P,POWER2        ; Positive base - Ok
2E4C: D5      	        PUSH    DE              ; Save power
2E4D: C5      	        PUSH    BC
2E4E: CD5E2C  	        CALL    INT             ; Get integer of power
2E51: C1      	        POP     BC              ; Restore power
2E52: D1      	        POP     DE
2E53: F5      	        PUSH    AF              ; MSB of base
2E54: CD062C  	        CALL    CMPNUM          ; Power an integer?
2E57: E1      	        POP     HL              ; Restore MSB of base
2E58: 7C      	        LD      A,H             ; but don't affect flags
2E59: 1F      	        RRA                     ; Exponent odd or even?
2E5A: E1      	POWER2: POP     HL              ; Restore MSB and exponent
2E5B: 222B81  	        LD      (FPREG+2),HL    ; Save base in FPREG
2E5E: E1      	        POP     HL              ; LSBs of base
2E5F: 222981  	        LD      (FPREG),HL      ; Save in FPREG
2E62: DC1F2E  	        CALL    C,NEGAFT        ; Odd power - Negate result
2E65: CCB42B  	        CALL    Z,INVSGN        ; Negative base - Negate it
2E68: D5      	        PUSH    DE              ; Save power
2E69: C5      	        PUSH    BC
2E6A: CD3F2A  	        CALL    LOG             ; Get LOG of base
2E6D: C1      	        POP     BC              ; Restore power
2E6E: D1      	        POP     DE
2E6F: CD802A  	        CALL    FPMULT          ; Multiply LOG by power
              	
2E72: CDBC2B  	EXP:    CALL    STAKFP          ; Put value on stack
2E75: 013881  	        LD      BC,08138H       ; BCDE = 1/Ln(2)
2E78: 113BAA  	        LD      DE,0AA3BH
2E7B: CD802A  	        CALL    FPMULT          ; Multiply value by 1/LN(2)
2E7E: 3A2C81  	        LD      A,(FPEXP)       ; Get exponent
2E81: FE88    	        CP      80H+8           ; Is it in range?
2E83: D2672B  	        JP      NC,OVTST1       ; No - Test for overflow
2E86: CD5E2C  	        CALL    INT             ; Get INT of FPREG
2E89: C680    	        ADD     A,80H           ; For excess 128
2E8B: C602    	        ADD     A,2             ; Exponent > 126?
2E8D: DA672B  	        JP      C,OVTST1        ; Yes - Test for overflow
2E90: F5      	        PUSH    AF              ; Save scaling factor
2E91: 212E2A  	        LD      HL,UNITY        ; Point to 1.
2E94: CD3629  	        CALL    ADDPHL          ; Add 1 to FPREG
2E97: CD772A  	        CALL    MULLN2          ; Multiply by LN(2)
2E9A: F1      	        POP     AF              ; Restore scaling factor
2E9B: C1      	        POP     BC              ; Restore exponent
2E9C: D1      	        POP     DE
2E9D: F5      	        PUSH    AF              ; Save scaling factor
2E9E: CD4229  	        CALL    SUBCDE          ; Subtract exponent from FPREG
2EA1: CDB42B  	        CALL    INVSGN          ; Negate result
2EA4: 21B22E  	        LD      HL,EXPTAB       ; Coefficient table
2EA7: CDE22E  	        CALL    SMSER1          ; Sum the series
2EAA: 110000  	        LD      DE,0            ; Zero LSBs
2EAD: C1      	        POP     BC              ; Scaling factor
2EAE: 4A      	        LD      C,D             ; Zero MSB
2EAF: C3802A  	        JP      FPMULT          ; Scale result to correct value
              	
2EB2: 08      	EXPTAB: DB      8                       ; Table used by EXP
2EB3: 402E9474	        DB      040H,02EH,094H,074H     ; -1/7! (-1/5040)
2EB7: 704F2E77	        DB      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
2EBB: 6E02887A	        DB      06EH,002H,088H,07AH     ; -1/5! (-1/120)
2EBF: E6A02A7C	        DB      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
2EC3: 50AAAA7E	        DB      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
2EC7: FFFF7F7F	        DB      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
2ECB: 00008081	        DB      000H,000H,080H,081H     ; -1/1! (-1/1)
2ECF: 00000081	        DB      000H,000H,000H,081H     ;  1/0! ( 1/1)
              	
2ED3: CDBC2B  	SUMSER: CALL    STAKFP          ; Put FPREG on stack
2ED6: 117E2A  	        LD      DE,MULT         ; Multiply by "X"
2ED9: D5      	        PUSH    DE              ; To be done after
2EDA: E5      	        PUSH    HL              ; Save address of table
2EDB: CDD72B  	        CALL    BCDEFP          ; Move FPREG to BCDE
2EDE: CD802A  	        CALL    FPMULT          ; Square the value
2EE1: E1      	        POP     HL              ; Restore address of table
2EE2: CDBC2B  	SMSER1: CALL    STAKFP          ; Put value on stack
2EE5: 7E      	        LD      A,(HL)          ; Get number of coefficients
2EE6: 23      	        INC     HL              ; Point to start of table
2EE7: CDC92B  	        CALL    PHLTFP          ; Move coefficient to FPREG
2EEA: 06      	        DB      06H             ; Skip "POP AF"
2EEB: F1      	SUMLP:  POP     AF              ; Restore count
2EEC: C1      	        POP     BC              ; Restore number
2EED: D1      	        POP     DE
2EEE: 3D      	        DEC     A               ; Cont coefficients
2EEF: C8      	        RET     Z               ; All done
2EF0: D5      	        PUSH    DE              ; Save number
2EF1: C5      	        PUSH    BC
2EF2: F5      	        PUSH    AF              ; Save count
2EF3: E5      	        PUSH    HL              ; Save address in table
2EF4: CD802A  	        CALL    FPMULT          ; Multiply FPREG by BCDE
2EF7: E1      	        POP     HL              ; Restore address in table
2EF8: CDDA2B  	        CALL    LOADFP          ; Number at HL to BCDE
2EFB: E5      	        PUSH    HL              ; Save address in table
2EFC: CD4529  	        CALL    FPADD           ; Add coefficient to FPREG
2EFF: E1      	        POP     HL              ; Restore address in table
2F00: C3EB2E  	        JP      SUMLP           ; More coefficients
              	
2F03: CD8B2B  	RND:    CALL    TSTSGN          ; Test sign of FPREG
2F06: 215E80  	        LD      HL,SEED+2       ; Random number seed
2F09: FA642F  	        JP      M,RESEED        ; Negative - Re-seed
2F0C: 217F80  	        LD      HL,LSTRND       ; Last random number
2F0F: CDC92B  	        CALL    PHLTFP          ; Move last RND to FPREG
2F12: 215E80  	        LD      HL,SEED+2       ; Random number seed
2F15: C8      	        RET     Z               ; Return if RND(0)
2F16: 86      	        ADD     A,(HL)          ; Add (SEED)+2)
2F17: E607    	        AND     00000111B       ; 0 to 7
2F19: 0600    	        LD      B,0
2F1B: 77      	        LD      (HL),A          ; Re-save seed
2F1C: 23      	        INC     HL              ; Move to coefficient table
2F1D: 87      	        ADD     A,A             ; 4 bytes
2F1E: 87      	        ADD     A,A             ; per entry
2F1F: 4F      	        LD      C,A             ; BC = Offset into table
2F20: 09      	        ADD     HL,BC           ; Point to coefficient
2F21: CDDA2B  	        CALL    LOADFP          ; Coefficient to BCDE
2F24: CD802A  	        CALL    FPMULT  ;       ; Multiply FPREG by coefficient
2F27: 3A5D80  	        LD      A,(SEED+1)      ; Get (SEED+1)
2F2A: 3C      	        INC     A               ; Add 1
2F2B: E603    	        AND     00000011B       ; 0 to 3
2F2D: 0600    	        LD      B,0
2F2F: FE01    	        CP      1               ; Is it zero?
2F31: 88      	        ADC     A,B             ; Yes - Make it 1
2F32: 325D80  	        LD      (SEED+1),A      ; Re-save seed
2F35: 21682F  	        LD      HL,RNDTAB-4     ; Addition table
2F38: 87      	        ADD     A,A             ; 4 bytes
2F39: 87      	        ADD     A,A             ; per entry
2F3A: 4F      	        LD      C,A             ; BC = Offset into table
2F3B: 09      	        ADD     HL,BC           ; Point to value
2F3C: CD3629  	        CALL    ADDPHL          ; Add value to FPREG
2F3F: CDD72B  	RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
2F42: 7B      	        LD      A,E             ; Get LSB
2F43: 59      	        LD      E,C             ; LSB = MSB
2F44: EE4F    	        XOR     01001111B       ; Fiddle around
2F46: 4F      	        LD      C,A             ; New MSB
2F47: 3680    	        LD      (HL),80H        ; Set exponent
2F49: 2B      	        DEC     HL              ; Point to MSB
2F4A: 46      	        LD      B,(HL)          ; Get MSB
2F4B: 3680    	        LD      (HL),80H        ; Make value -0.5
2F4D: 215C80  	        LD      HL,SEED         ; Random number seed
2F50: 34      	        INC     (HL)            ; Count seed
2F51: 7E      	        LD      A,(HL)          ; Get seed
2F52: D6AB    	        SUB     171             ; Do it modulo 171
2F54: C25B2F  	        JP      NZ,RND2         ; Non-zero - Ok
2F57: 77      	        LD      (HL),A          ; Zero seed
2F58: 0C      	        INC     C               ; Fillde about
2F59: 15      	        DEC     D               ; with the
2F5A: 1C      	        INC     E               ; number
2F5B: CD9629  	RND2:   CALL    BNORM           ; Normalise number
2F5E: 217F80  	        LD      HL,LSTRND       ; Save random number
2F61: C3E32B  	        JP      FPTHL           ; Move FPREG to last and return
              	
2F64: 77      	RESEED: LD      (HL),A          ; Re-seed random numbers
2F65: 2B      	        DEC     HL
2F66: 77      	        LD      (HL),A
2F67: 2B      	        DEC     HL
2F68: 77      	        LD      (HL),A
2F69: C33F2F  	        JP      RND1            ; Return RND seed
              	
2F6C: 68B14668	RNDTAB: DB   068H,0B1H,046H,068H     ; Table used by RND
2F70: 99E99269	        DB   099H,0E9H,092H,069H
2F74: 10D17568	        DB   010H,0D1H,075H,068H
              	
2F78: 21C22F  	COS:    LD      HL,HALFPI       ; Point to PI/2
2F7B: CD3629  	        CALL    ADDPHL          ; Add it to PPREG
2F7E: CDBC2B  	SIN:    CALL    STAKFP          ; Put angle on stack
2F81: 014983  	        LD      BC,8349H        ; BCDE = 2 PI
2F84: 11DB0F  	        LD      DE,0FDBH
2F87: CDCC2B  	        CALL    FPBCDE          ; Move 2 PI to FPREG
2F8A: C1      	        POP     BC              ; Restore angle
2F8B: D1      	        POP     DE
2F8C: CDE12A  	        CALL    DVBCDE          ; Divide angle by 2 PI
2F8F: CDBC2B  	        CALL    STAKFP          ; Put it on stack
2F92: CD5E2C  	        CALL    INT             ; Get INT of result
2F95: C1      	        POP     BC              ; Restore number
2F96: D1      	        POP     DE
2F97: CD4229  	        CALL    SUBCDE          ; Make it 0 <= value < 1
2F9A: 21C62F  	        LD      HL,QUARTR       ; Point to 0.25
2F9D: CD3C29  	        CALL    SUBPHL          ; Subtract value from 0.25
2FA0: CD8B2B  	        CALL    TSTSGN          ; Test sign of value
2FA3: 37      	        SCF                     ; Flag positive
2FA4: F2AE2F  	        JP      P,SIN1          ; Positive - Ok
2FA7: CD3329  	        CALL    ROUND           ; Add 0.5 to value
2FAA: CD8B2B  	        CALL    TSTSGN          ; Test sign of value
2FAD: B7      	        OR      A               ; Flag negative
2FAE: F5      	SIN1:   PUSH    AF              ; Save sign
2FAF: F4B42B  	        CALL    P,INVSGN        ; Negate value if positive
2FB2: 21C62F  	        LD      HL,QUARTR       ; Point to 0.25
2FB5: CD3629  	        CALL    ADDPHL          ; Add 0.25 to value
2FB8: F1      	        POP     AF              ; Restore sign
2FB9: D4B42B  	        CALL    NC,INVSGN       ; Negative - Make positive
2FBC: 21CA2F  	        LD      HL,SINTAB       ; Coefficient table
2FBF: C3D32E  	        JP      SUMSER          ; Evaluate sum of series
              	
2FC2: DB0F4981	HALFPI: DB   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
              	
2FC6: 0000007F	QUARTR: DB   000H,000H,000H,07FH     ; 0.25
              	
2FCA: 05      	SINTAB: DB   5                       ; Table used by SIN
2FCB: BAD71E86	        DB   0BAH,0D7H,01EH,086H     ; 39.711
2FCF: 64269987	        DB   064H,026H,099H,087H     ;-76.575
2FD3: 58342387	        DB   058H,034H,023H,087H     ; 81.602
2FD7: E05DA586	        DB   0E0H,05DH,0A5H,086H     ;-41.342
2FDB: DA0F4983	        DB   0DAH,00FH,049H,083H     ;  6.2832
              	
2FDF: CDBC2B  	TAN:    CALL    STAKFP          ; Put angle on stack
2FE2: CD7E2F  	        CALL    SIN             ; Get SIN of angle
2FE5: C1      	        POP     BC              ; Restore angle
2FE6: E1      	        POP     HL
2FE7: CDBC2B  	        CALL    STAKFP          ; Save SIN of angle
2FEA: EB      	        EX      DE,HL           ; BCDE = Angle
2FEB: CDCC2B  	        CALL    FPBCDE          ; Angle to FPREG
2FEE: CD782F  	        CALL    COS             ; Get COS of angle
2FF1: C3DF2A  	        JP      DIV             ; TAN = SIN / COS
              	
2FF4: CD8B2B  	ATN:    CALL    TSTSGN          ; Test sign of value
2FF7: FC1F2E  	        CALL    M,NEGAFT        ; Negate result after if -ve
2FFA: FCB42B  	        CALL    M,INVSGN        ; Negate value if -ve
2FFD: 3A2C81  	        LD      A,(FPEXP)       ; Get exponent
3000: FE81    	        CP      81H             ; Number less than 1?
3002: DA1130  	        JP      C,ATN1          ; Yes - Get arc tangnt
3005: 010081  	        LD      BC,8100H        ; BCDE = 1
3008: 51      	        LD      D,C
3009: 59      	        LD      E,C
300A: CDE12A  	        CALL    DVBCDE          ; Get reciprocal of number
300D: 213C29  	        LD      HL,SUBPHL       ; Sub angle from PI/2
3010: E5      	        PUSH    HL              ; Save for angle > 1
3011: 211B30  	ATN1:   LD      HL,ATNTAB       ; Coefficient table
3014: CDD32E  	        CALL    SUMSER          ; Evaluate sum of series
3017: 21C22F  	        LD      HL,HALFPI       ; PI/2 - angle in case > 1
301A: C9      	        RET                     ; Number > 1 - Sub from PI/2
              	
301B: 09      	ATNTAB: DB   9                       ; Table used by ATN
301C: 4AD73B78	        DB   04AH,0D7H,03BH,078H     ; 1/17
3020: 026E847B	        DB   002H,06EH,084H,07BH     ;-1/15
3024: FEC12F7C	        DB   0FEH,0C1H,02FH,07CH     ; 1/13
3028: 74319A7D	        DB   074H,031H,09AH,07DH     ;-1/11
302C: 843D5A7D	        DB   084H,03DH,05AH,07DH     ; 1/9
3030: C87F917E	        DB   0C8H,07FH,091H,07EH     ;-1/7
3034: E4BB4C7E	        DB   0E4H,0BBH,04CH,07EH     ; 1/5
3038: 6CAAAA7F	        DB   06CH,0AAH,0AAH,07FH     ;-1/3
303C: 00000081	        DB   000H,000H,000H,081H     ; 1/1
              	
              	
3040: C9      	ARET:   RET                     ; A RETurn instruction
              	
3041: D7      	GETINP: RST	    10H             ;input a character
3042: C9      	        RET
              	
3043:         	CLSBAS: 
3043: E5      	        PUSH    HL              ; Save HL register
3044: 21E130  	        LD      HL,CLSSTR       ; Clear screen codes
3047: CD8226  	        CALL    PRS             ; Output string
304A: E1      	        POP     HL              ; Restore HL register
304B: AF      	        XOR     A               ; Set to position 0
304C: 32F080  	        LD      (CURPOS),A      ; Store it
304F: C9      	        RET
              	        
3050:         	INVERSEBAS: 
3050: E5      	        PUSH    HL              ; Save HL register
3051: 21E930  	        LD      HL,INVSTR       ; Inverse text screen codes
3054: CD8226  	        CALL    PRS             ; Output string
3057: E1      	        POP     HL              ; Restore HL register
3058: AF      	        XOR     A               ; Set to position 0
3059: 32F080  	        LD      (CURPOS),A      ; Store it
305C: C9      	        RET
              	        
305D:         	FLASHBAS: 
305D: E5      	        PUSH    HL              ; Save HL register
305E: 21EE30  	        LD      HL,FLASHSTR     ; Flash text screen codes
3061: CD8226  	        CALL    PRS             ; Output string
3064: E1      	        POP     HL              ; Restore HL register
3065: AF      	        XOR     A               ; Set to position 0
3066: 32F080  	        LD      (CURPOS),A      ; Store it
3069: C9      	        RET
              	
306A:         	NORMALBAS:
306A: E5      	        PUSH    HL              ; Save HL register
306B: 21F330  	        LD      HL,NORMALSTR       ; Normal text screen codes
306E: CD8226  	        CALL    PRS             ; Output string
3071: E1      	        POP     HL              ; Restore HL register
3072: AF      	        XOR     A               ; Set to position 0
3073: 32F080  	        LD      (CURPOS),A      ; Store it
3076: C9      	        RET
              	        
3077: CD0A29  	SCREEN: CALL    GETINT          ; set cursor position to column, row - first get column
307A: F5      	        PUSH    AF              ; Save column
307B: CDA01B  	        CALL    CHKSYN          ; Make sure ',' follows
307E: 2C      	        DB   ','
307F: CD0A29  	        CALL    GETINT          ; Get integer row
3082: F5      	        PUSH    AF              ; Save row
              	        
3083: E5      	        PUSH    HL
3084: 21F830  	        LD      HL,SCREEN1STR   ; "ESC["
3087: CD8226  	        CALL    PRS             ; Output string
308A: E1      	        POP     HL
              	        
308B: F1      	        POP     AF              ; Restore row
308C: E5      	        PUSH    HL
308D: 2600    	        LD      H,00
308F: 6F      	        LD      L,A
3090: CD252D  	        CALL    PRNTHL
              	        
3093: 21FB30  	        LD      HL,SCREEN2STR   ; print out ";"
3096: CD8226  	        CALL    PRS
3099: E1      	        POP     HL
              	        
309A: F1      	        POP     AF              ; Restore row
309B: E5      	        PUSH    HL
309C: 2600    	        LD      H,00
309E: 6F      	        LD      L,A
309F: CD252D  	        CALL    PRNTHL
              	        
30A2: 21FD30  	        LD      HL,SCREEN3STR   ; print out "H"
30A5: CD8226  	        CALL    PRS
              	        
30A8: E1      	        POP     HL              ; Restore HL register
              	        ;XOR     A               ; Set to position 0
              	        ;LD      (CURPOS),A      ; Store it
30A9: C9      	        RET
              	
              	                                ; colors are 0=black, 1=red, 2=green, 3=yellow, 4=blue, 5=magenta, 6=cyan, 7=white
              	                                ; when setting escape code, add 30 for foreground and 40 for background
30AA: CD0A29  	COLOR:  CALL    GETINT          ; set foreground and background color
30AD: F5      	        PUSH    AF              ; Save foreground color
30AE: CDA01B  	        CALL    CHKSYN          ; Make sure ',' follows
30B1: 2C      	        DB   ','
30B2: CD0A29  	        CALL    GETINT          ; Get integer background color
30B5: F5      	        PUSH    AF              ; Save background
              	        
30B6: E5      	        PUSH    HL
30B7: 21F830  	        LD      HL,SCREEN1STR   ; "ESC["
30BA: CD8226  	        CALL    PRS             ; Output string
30BD: E1      	        POP     HL
              	        
30BE: F1      	        POP     AF              ; Restore background
30BF: C628    	        ADD     A,40              ; add 40 decimal to get background range
30C1: E5      	        PUSH    HL
30C2: 2600    	        LD      H,00
30C4: 6F      	        LD      L,A
30C5: CD252D  	        CALL    PRNTHL
              	        
30C8: 21FB30  	        LD      HL,SCREEN2STR   ; print out ";"
30CB: CD8226  	        CALL    PRS
30CE: E1      	        POP     HL
              	                                
30CF: F1      	        POP     AF              ; Restore foreground
30D0: C61E    	        ADD     A,30              ; add 40 decimal to get background range
30D2: E5      	        PUSH    HL
30D3: 2600    	        LD      H,00
30D5: 6F      	        LD      L,A
30D6: CD252D  	        CALL    PRNTHL
              	        
30D9: 21FF30  	        LD      HL,SCREEN4STR   ; print out "m"
30DC: CD8226  	        CALL    PRS
              	        
30DF: E1      	        POP     HL              ; Restore HL register
              	        ;XOR     A               ; Set to position 0
              	        ;LD      (CURPOS),A      ; Store it
30E0: C9      	        RET
              	        
30E1: 1B5B324A	CLSSTR: DB      ESC,"[2J",ESC,"[H",00H
30E5: 1B5B4800	
30E9: 1B5B376D	INVSTR: DB      ESC,"[7m",00H
30ED: 00      	
30EE:         	FLASHSTR:
30EE: 1B5B356D	        DB      ESC,"[5m",00H
30F2: 00      	
30F3:         	NORMALSTR:
30F3: 1B5B306D	        DB      ESC,"[0m",00H
30F7: 00      	
30F8:         	SCREEN1STR:     
30F8: 1B5B00  	        DB      ESC,"[",00H
30FB:         	SCREEN2STR:     
30FB: 3B00    	        DB      ";",00H
30FD:         	SCREEN3STR:
30FD: 4800    	        DB      "H",00H
30FF:         	SCREEN4STR:
30FF: 6D00    	        DB      "m",00H
              	
3101: CD0A29  	WIDTH:  CALL    GETINT          ; Get integer 0-255
3104: 7B      	        LD      A,E             ; Width to A
3105: 328780  	        LD      (LWIDTH),A      ; Set width
3108: C9      	        RET
              	
3109: CD9921  	LINES:  CALL    GETNUM          ; Get a number
310C: CDDE1D  	        CALL    DEINT           ; Get integer -32768 to 32767
310F: ED538B80	        LD      (LINESC),DE     ; Set lines counter
3113: ED538D80	        LD      (LINESN),DE     ; Set lines number
3117: C9      	        RET
              	
3118: CDDE1D  	DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
311B: D5      	        PUSH    DE              ; Save number
311C: E1      	        POP     HL              ; Number to HL
311D: 46      	        LD      B,(HL)          ; Get LSB of contents
311E: 23      	        INC     HL
311F: 7E      	        LD      A,(HL)          ; Get MSB of contents
3120: C35425  	        JP      ABPASS          ; Return integer AB
              	
3123: CD9921  	DOKE:   CALL    GETNUM          ; Get a number
3126: CDDE1D  	        CALL    DEINT           ; Get integer -32768 to 32767
3129: D5      	        PUSH    DE              ; Save address
312A: CDA01B  	        CALL    CHKSYN          ; Make sure ',' follows
312D: 2C      	        DB      ','
312E: CD9921  	        CALL    GETNUM          ; Get a number
3131: CDDE1D  	        CALL    DEINT           ; Get integer -32768 to 32767
3134: E3      	        EX      (SP),HL         ; Save value,get address
3135: 73      	        LD      (HL),E          ; Save LSB of value
3136: 23      	        INC     HL
3137: 72      	        LD      (HL),D          ; Save MSB of value
3138: E1      	        POP     HL              ; Restore code string address
3139: C9      	        RET
              	
313A: E5      	DIR:    PUSH HL
313B: CDBB12  	        CALL directory
313E: E1      	        POP HL
313F: C9      	        RET
              	        
3140: D5      	DELETE: PUSH DE
3141: 1120FF  	        LD DE,filename_buffer   ;Pointer to filename buffer
3144: 0E00    	DEFN:   LD C,00H                ;CHECK IF END OF LINE
3146: B9      	        CP C
3147: 2808    	        JR Z,DOS_ERASE          ;IF END OF WORD TRY TO ERASE
3149: 12      	        LD (DE),A               ;STORE IN FILENAME BUFFER
314A: 13      	        INC DE
314B: CD271D  	        CALL GETCHR             ;GET THE CHAR FROM BUFFER
314E: C34431  	        JP DEFN                 ;GET NEXT CHARACTER
3151:         	DOS_ERASE:
3151: 3E00    	        LD A,00H
3153: 12      	        LD (DE),A
3154: E5      	        PUSH HL
3155: CD4B14  	        CALL ERASE
3158: E1      	        POP HL
3159: D1      	        POP DE
315A: C9      	        RET
              	        
315B:         	MSBASIC_SAVE:                    ; This Saves the current program to USB Drive with the given name.
315B: D5      	        push de
315C: E5      	        push hl
315D: F5      	        push af
315E: CDDA31  	        call msbasic_get_program_size
3161: 7C      	        ld a, h
3162: B5      	        or l
3163: FE00    	        cp 0
3165: 2024    	        jr nz, msbasic_save_continue1
3167: 217131  	        LD      HL,doserrmsg1   ; Print error
316A: CD8226  	        CALL    PRS             ; Output string
316D: F1      	        pop af
316E: E1      	        pop hl
316F: D1      	        pop de
3170: C9      	        ret
              	        
3171:         	doserrmsg1:
3171: 4E6F2070	        db 'No program yet to save!',13,10,0
3175: 726F6772	
3179: 616D2079	
317D: 65742074	
3181: 6F207361	
3185: 7665210D	
3189: 0A00    	
              	        
318B:         	msbasic_save_continue1:
318B: F1      	        pop af
318C: E1      	        pop hl
318D: 1120FF  	        LD DE,filename_buffer   ;Pointer to filename buffer
3190: 0E00    	DSFN:   LD C,00H                ;CHECK IF END OF LINE
3192: B9      	        CP C
3193: 2808    	        JR Z,DOS_SAVE           ;IF END OF WORD TRY TO ERASE
3195: 12      	        LD (DE),A               ;STORE IN FILENAME BUFFER
3196: 13      	        INC DE
3197: CD271D  	        CALL GETCHR             ;GET THE CHAR FROM BUFFER
319A: C39031  	        JP DSFN                 ;GET NEXT CHARACTER
319D:         	DOS_SAVE:
319D: 3E00    	        LD A,00H
319F: 12      	        LD (DE),A
              	        
31A0: E5      	        push hl
              	
31A1: CDF831  	        call msbasic_does_file_exist
31A4: CCE431  	        call z, msbasic_erase_file
              	        
31A7: CDCD11  	        call close_file
              	        
31AA: 21F114  	        ld hl, SLASHSTR
31AD: CDBA11  	        call open_file
31B0: 1120FF  	        ld de, filename_buffer
31B3: CDA511  	        call create_file
31B6: 284C    	        jr z, msbasic_save_continue
31B8: 21C131  	        LD      HL,doserrmsg2   ; Print error
31BB: CD8226  	        CALL    PRS             ; Output string
31BE: E1      	        pop hl
31BF: D1      	        pop de
31C0: C9      	        ret
              	        
31C1:         	doserrmsg2:
31C1: 436F756C	        db 'Could not create file.',13,10,0
31C5: 64206E6F	
31C9: 74206372	
31CD: 65617465	
31D1: 2066696C	
31D5: 652E0D0A	
31D9: 00      	
              	        
31DA:         	msbasic_get_program_size:
              	        ; Gets the total size of the program, in bytes, into hl
              	        ;ld hl, 0FDFFH
31DA: 2A1B81  	        LD   HL,(PROGND)       ;OP1 INTO HL
              	        ;LD  DE,(BASTXT)       ;OP2 INTO DE
31DD: 110080  	        LD  DE, 8000H         ;OP2 INTO DE
31E0: A7      	        AND  A                 ;CLEARY CARRY
31E1: ED52    	        SBC  HL,DE             ;OP1 - OP2
31E3: C9      	        ret
              	        
31E4:         	msbasic_erase_file:
31E4: 3E2F    	        ld a, SET_FILE_NAME
31E6: CD6A12  	        call send_command_byte
31E9: 2120FF  	        ld hl, filename_buffer
31EC: CD5412  	        call send_data_string
31EF: 3E35    	        ld a, FILE_ERASE
31F1: CD6A12  	        call send_command_byte
31F4: CDB212  	        call read_status_byte
31F7: C9      	        ret
              	        
31F8:         	msbasic_does_file_exist:
              	        ; Looks on disk for a file. Returns Z if file exists.
31F8: 21F114  	        ld hl, SLASHSTR
31FB: CDBA11  	        call open_file
31FE: 2120FF  	        ld hl, filename_buffer
3201: C3BA11  	        jp open_file
              	        
3204:         	msbasic_save_continue:
3204: CDCD11  	        call close_file
3207: 21F114  	        ld hl, SLASHSTR
320A: CDBA11  	        call open_file
320D: 2120FF  	        ld hl, filename_buffer
3210: CDBA11  	        call open_file
              	        
3213: 3E3C    	        ld a, BYTE_WRITE
3215: CD6A12  	        call send_command_byte
              	        
              	        ; Send number of bytes we are about to write, as 16 bit number, low first
3218: CDDA31  	        call msbasic_get_program_size
321B: 7D      	        ld a, l
321C: CD4E12  	        call send_data_byte
321F: 7C      	        ld a, h
3220: CD4E12  	        call send_data_byte
              	        
3223: 210080  	        ld hl, 8000H
3226: CD8C14  	        call write_loop
3229: CDCD11  	        call close_file
322C: E1      	        pop hl
322D: D1      	        pop de
322E: C9      	        ret
              	
322F:         	MSBASIC_LOAD:
322F: D5      	        PUSH DE
3230: 1120FF  	        LD DE,filename_buffer   ;Pointer to filename buffer
3233: 0E00    	DLFN:   LD C,00H                ;CHECK IF END OF LINE
3235: B9      	        CP C
3236: 2808    	        JR Z,DOS_LOAD           ;IF END OF WORD TRY TO ERASE
3238: 12      	        LD (DE),A               ;STORE IN FILENAME BUFFER
3239: 13      	        INC DE
323A: CD271D  	        CALL GETCHR             ;GET THE CHAR FROM BUFFER
323D: C33332  	        JP DLFN                 ;GET NEXT CHARACTER
3240:         	DOS_LOAD:
3240: 3E00    	        LD A,00H
3242: 12      	        LD (DE),A
              	        
3243: E5      	        push hl
              	        
3244: CDF831  	        call msbasic_does_file_exist
3247: 281B    	        jr z, msbasic_load_can_do
3249:         	mbasic_file_not_found
3249: 215232  	        LD      HL,doserrmsg3   ; Print error
324C: CD8226  	        CALL    PRS             ; Output string
324F: E1      	        pop hl
3250: D1      	        pop de
3251: C9      	        ret
              	
3252:         	doserrmsg3:
3252: 46696C65	        db 'File not found.',13,10,0
3256: 206E6F74	
325A: 20666F75	
325E: 6E642E0D	
3262: 0A00    	
              	        
3264:         	msbasic_load_can_do:
3264: 21F114  	        ld hl, SLASHSTR
3267: CDBA11  	        call open_file
326A: 2120FF  	        ld hl, filename_buffer
326D: CDBA11  	        call open_file
              	        
3270: 3E3A    	        ld a, BYTE_READ
3272: CD6A12  	        call send_command_byte
3275: 3EFF    	        ld a, 255                           ; Request all of the file
3277: CD4E12  	        call send_data_byte
327A: 3EFF    	        ld a, 255                           ; Yes, all!
327C: CD4E12  	        call send_data_byte
              	        
327F: 3E22    	        ld a, GET_STATUS
3281: CD6A12  	        call send_command_byte
3284: CD7312  	        call read_data_byte
3287: 210080  	        ld hl, 8000H                       ; Get back the target address
328A:         	msbasic_load_loop1:
328A: FE1D    	        cp USB_INT_DISK_READ
328C: 201F    	        jr nz, msbasic_load_finished
              	        
328E: E5      	        push hl
328F: 3E27    	        ld a, RD_USB_DATA0
3291: CD6A12  	        call send_command_byte
3294: CD7312  	        call read_data_byte
              	        ;push af
              	        ;ld a,"."
              	        ;call PRINT_CHAR
              	        ;pop af
3297: E1      	        pop hl
3298: CD7C12  	        call read_data_bytes_into_hl
329B: E5      	        push hl
329C: 3E3B    	        ld a, BYTE_RD_GO
329E: CD6A12  	        call send_command_byte
32A1: 3E22    	        ld a, GET_STATUS
32A3: CD6A12  	        call send_command_byte
32A6: CD7312  	        call read_data_byte
32A9: E1      	        pop hl
32AA: C38A32  	        jp msbasic_load_loop1
32AD:         	msbasic_load_finished:
              	        ;ld (TXTUNF), hl
32AD: CDCD11  	        call close_file
32B0: E1      	        pop hl
32B1: D1      	        pop de
32B2: C9      	        ret
              	
              	
              	; HEX$(nn) Convert 16 bit number to Hexadecimal string
              	
32B3: CD9C21  	HEX: 	CALL	TSTNUM          ; Verify it's a number
32B6: CDDE1D  	        CALL	DEINT           ; Get integer -32768 to 32767
32B9: C5      	        PUSH	BC              ; Save contents of BC
32BA: 212E81  	        LD	    HL,PBUFF
32BD: 7A      	        LD	    A,D             ; Get high order into A
32BE: FE00    	        CP      $0
32C0: 280C    			JR      Z,HEX2          ; Skip output if both high digits are zero
32C2: CDEB32  	        CALL    BYT2ASC         ; Convert D to ASCII
32C5: 78      			LD      A,B
32C6: FE30    			CP      '0'
32C8: 2802    			JR      Z,HEX1          ; Don't store high digit if zero
32CA: 70      	        LD	    (HL),B          ; Store it to PBUFF
32CB: 23      	        INC	    HL              ; Next location
32CC: 71      	HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
32CD: 23      	        INC     HL              ; Next location
32CE: 7B      	HEX2:   LD	    A,E             ; Get lower byte
32CF: CDEB32  	        CALL    BYT2ASC         ; Convert E to ASCII
32D2: 7A      			LD      A,D
32D3: FE00    	        CP      $0
32D5: 2005    			JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
32D7: 78      			LD      A,B
32D8: FE30    			CP      '0'             ; If high digit of lower byte is zero then don't print
32DA: 2802    			JR      Z,HEX4
32DC: 70      	HEX3:   LD      (HL),B          ; to PBUFF+2
32DD: 23      	        INC     HL              ; Next location
32DE: 71      	HEX4:   LD      (HL),C          ; to PBUFF+3
32DF: 23      	        INC     HL              ; PBUFF+4 to zero
32E0: AF      	        XOR     A               ; Terminating character
32E1: 77      	        LD      (HL),A          ; Store zero to terminate
32E2: 23      	        INC     HL              ; Make sure PBUFF is terminated
32E3: 77      	        LD      (HL),A          ; Store the double zero there
32E4: C1      	        POP     BC              ; Get BC back
32E5: 212E81  	        LD      HL,PBUFF        ; Reset to start of PBUFF
32E8: C31226  	        JP      STR1            ; Convert the PBUFF to a string and return it
              	
32EB: 47      	BYT2ASC	LD      B,A             ; Save original value
32EC: E60F    	        AND     $0F             ; Strip off upper nybble
32EE: FE0A    	        CP      $0A             ; 0-9?
32F0: 3802    	        JR      C,ADD30         ; If A-F, add 7 more
32F2: C607    	        ADD     A,$07           ; Bring value up to ASCII A-F
32F4: C630    	ADD30	ADD     A,$30           ; And make ASCII
32F6: 4F      	        LD      C,A             ; Save converted char to C
32F7: 78      	        LD      A,B             ; Retrieve original value
32F8: 0F      	        RRCA                    ; and Rotate it right
32F9: 0F      	        RRCA
32FA: 0F      	        RRCA
32FB: 0F      	        RRCA
32FC: E60F    	        AND     $0F             ; Mask off upper nybble
32FE: FE0A    	        CP      $0A             ; 0-9? < A hex?
3300: 3802    	        JR      C,ADD301        ; Skip Add 7
3302: C607    	        ADD     A,$07           ; Bring it up to ASCII A-F
3304: C630    	ADD301	ADD     A,$30           ; And make it full ASCII
3306: 47      	        LD      B,A             ; Store high order byte
3307: C9      	        RET	
              	
              	; Convert "&Hnnnn" to FPREG
              	; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
              	; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
3308: EB      	HEXTFP  EX      DE,HL           ; Move code string pointer to DE
3309: 210000  	        LD      HL,$0000        ; Zero out the value
330C: CD2133  	        CALL    GETHEX          ; Check the number for valid hex
330F: DA4133  	        JP      C,HXERR         ; First value wasn't hex, HX error
3312: 1805    	        JR      HEXLP1          ; Convert first character
3314: CD2133  	HEXLP   CALL    GETHEX          ; Get second and addtional characters
3317: 381F    	        JR      C,HEXIT         ; Exit if not a hex character
3319: 29      	HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
331A: 29      	        ADD     HL,HL
331B: 29      	        ADD     HL,HL
331C: 29      	        ADD     HL,HL
331D: B5      	        OR      L               ; Add in D0-D3 into L
331E: 6F      	        LD      L,A             ; Save new value
331F: 18F3    	        JR      HEXLP           ; And continue until all hex characters are in
              	
3321: 13      	GETHEX  INC     DE              ; Next location
3322: 1A      	        LD      A,(DE)          ; Load character at pointer
3323: FE20    	        CP      ' '
3325: CA2133  	        JP      Z,GETHEX        ; Skip spaces
3328: D630    	        SUB     $30             ; Get absolute value
332A: D8      	        RET     C               ; < "0", error
332B: FE0A    	        CP      $0A
332D: 3805    	        JR      C,NOSUB7        ; Is already in the range 0-9
332F: D607    	        SUB     $07             ; Reduce to A-F
3331: FE0A    	        CP      $0A             ; Value should be $0A-$0F at this point
3333: D8      	        RET     C               ; CY set if was :            ; < = > ? @
3334: FE10    	NOSUB7  CP      $10             ; > Greater than "F"?
3336: 3F      	        CCF
3337: C9      	        RET                     ; CY set if it wasn't valid hex
              	    
3338: EB      	HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
3339: 7A      	        LD      A,D             ; Load DE into AC
333A: 4B      	        LD      C,E             ; For prep to 
333B: E5      	        PUSH    HL
333C: CD5325  	        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
333F: E1      	        POP     HL
3340: C9      	        RET
              	
3341: 1E26    	HXERR:  LD      E,HX            ; ?HEX Error
3343: C3E618  	        JP      ERROR
              	
              	; BIN$(NN) Convert integer to a 1-16 char binary string
3346: CD9C21  	BIN:    CALL    TSTNUM          ; Verify it's a number
3349: CDDE1D  	        CALL    DEINT           ; Get integer -32768 to 32767
334C: C5      	BIN2:   PUSH    BC              ; Save contents of BC
334D: 212E81  	        LD      HL,PBUFF
3350: 0611    	        LD      B,17            ; One higher than max char count
3352:         	ZEROSUP:                        ; Suppress leading zeros
3352: 05      	        DEC     B               ; Max 16 chars
3353: 78      	        LD      A,B
3354: FE01    	        CP      $01
3356: 2808    	        JR      Z,BITOUT        ; Always output at least one character
3358: CB13    	        RL      E
335A: CB12    	        RL      D
335C: 30F4    	        JR      NC,ZEROSUP
335E: 1804    	        JR      BITOUT2
3360:         	BITOUT:      
3360: CB13    	        RL      E
3362: CB12    	        RL      D               ; Top bit now in carry
3364:         	BITOUT2:
3364: 3E30    	        LD      A,'0'           ; Char for '0'
3366: CE00    	        ADC     A,0             ; If carry set then '0' --> '1'
3368: 77      	        LD      (HL),A
3369: 23      	        INC     HL
336A: 05      	        DEC     B
336B: 20F3    	        JR      NZ,BITOUT
336D: AF      	        XOR     A               ; Terminating character
336E: 77      	        LD      (HL),A          ; Store zero to terminate
336F: 23      	        INC     HL              ; Make sure PBUFF is terminated
3370: 77      	        LD      (HL),A          ; Store the double zero there
3371: C1      	        POP     BC
3372: 212E81  	        LD      HL,PBUFF
3375: C31226  	        JP      STR1
              	
              	; Convert "&Bnnnn" to FPREG
              	; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
3378: EB      	BINTFP: EX      DE,HL           ; Move code string pointer to DE
3379: 210000  	        LD      HL,$0000        ; Zero out the value
337C: CD9533  	        CALL    CHKBIN          ; Check the number for valid bin
337F: DAA333  	        JP      C,BINERR        ; First value wasn't bin, HX error
3382: D630    	BINIT:  SUB     '0'
3384: 29      	        ADD     HL,HL           ; Rotate HL left
3385: B5      	        OR      L
3386: 6F      	        LD      L,A
3387: CD9533  	        CALL    CHKBIN          ; Get second and addtional characters
338A: 30F6    	        JR      NC,BINIT        ; Process if a bin character
338C: EB      	        EX      DE,HL           ; Value into DE, Code string into HL
338D: 7A      	        LD      A,D             ; Load DE into AC
338E: 4B      	        LD      C,E             ; For prep to 
338F: E5      	        PUSH    HL
3390: CD5325  	        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
3393: E1      	        POP     HL
3394: C9      	        RET
              	
              	; Char is in A, NC if char is 0 or 1
3395: 13      	CHKBIN: INC     DE
3396: 1A      	        LD      A,(DE)
3397: FE20    	        CP      ' '
3399: CA9533  	        JP      Z,CHKBIN        ; Skip spaces
339C: FE30    	        CP      '0'             ; Set C if < '0'
339E: D8      	        RET     C
339F: FE32    	        CP      '2'
33A1: 3F      	        CCF                     ; Set C if > '1'
33A2: C9      	        RET
              	
33A3: 1E28    	BINERR: LD      E,BN            ; ?BIN Error
33A5: C3E618  	        JP      ERROR
              	
              	
33A8:         	JJUMP1: 
33A8: DD21FFFF	        LD      IX,-1           ; Flag cold start
33AC: C30815  	        JP      CSTART          ; Go and initialise
              	
33AF:         	MONOUT: 
33AF: C30800  	        JP      $0008           ; output a char
              	
              	
33B2:         	MONITR: 
33B2: C30000  	        JP      $0000           ; Restart (Normally Monitor Start)
              	
              	
33B5: 3E00    	INITST: LD      A,0             ; Clear break flag
33B7: 329280  	        LD      (BRKFLG),A
33BA: C30F15  	        JP      INITMS
              	
33BD: ED45    	ARETN:  RETN                    ; Return from NMI
              	
              	
33BF: F5      	TSTBIT: PUSH    AF              ; Save bit mask
33C0: A0      	        AND     B               ; Get common bits
33C1: C1      	        POP     BC              ; Restore bit mask
33C2: B8      	        CP      B               ; Same bit set?
33C3: 3E00    	        LD      A,0             ; Return 0 in A
33C5: C9      	        RET
              	
33C6: CDAB1B  	OUTNCR: CALL    OUTC            ; Output character in A
33C9: C3D41F  	        JP      PRNTCRLF        ; Output CRLF
              	
              	
              	
              	        ENDIF
              	
              	        IF (CFORTH = 1)
              	        INCLUDE "camel80.asm"
              	        ENDIF
              	
              	
              	;-------------------------------------------------------------------------------
              	; MEMORY LOCATIONS FOR TinyBASIC
              	;-------------------------------------------------------------------------------
              	        IF (BASIC = 1)
              	LSTROM:                                 ;ALL ABOVE CAN BE ROM
              	;       ORG  08000H                     ;HERE DOWN MUST BE RAM
              	        ORG  0FF00H
              	VARBGN: DS   55                         ;VARIABLE @(0)
              	BUFFER: DS   64                         ;INPUT BUFFER
              	BUFEND: DS   1                          ;BUFFER ENDS
              	STKLMT: DS   1                          ;TOP LIMIT FOR STACKB
              	        ENDIF
              	        END


total time: 0.1304 sec.
no errors
